<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="jmpews,jmpews@gmail.com"><title>HookZz框架 · jmpews</title><meta name="description" content="hook framwork. 
ref to: frida-gum and minhook and substrate. special thanks to frida-gum&amp;#39;s perfect code and modular architecture.
still developing"><meta name="keywords" content="py,go,pwn,reverse"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">jmpews</a></h3><div class="description"><p>py &amp; go &amp; pwn &amp; reverse</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/jmpews"><i class="fa fa-twitter"></i></a></li><li><a href="http://weibo.com/winter1ife"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/jmpews"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>HookZz框架</a></h3></div><div class="post-content"><p><strong>hook framwork</strong>. </p>
<p><strong>ref to: <a href="https://github.com/frida/frida-gum" target="_blank" rel="external">frida-gum</a> and <a href="https://github.com/TsudaKageyu/minhook" target="_blank" rel="external">minhook</a> and <a href="https://github.com/jevinskie/substrate" target="_blank" rel="external">substrate</a>. special thanks to <code>frida-gum&#39;s</code> perfect code and modular architecture</strong>.</p>
<p><strong>still developing, for arm64/IOS now!</strong></p>
<h2 id="Hook架构设计"><a href="#Hook架构设计" class="headerlink" title="Hook架构设计"></a>Hook架构设计</h2><p>一般来说可以分为以下几个模块</p>
<ol>
<li>内存分配 模块</li>
<li>指令写 模块</li>
<li>指令读 模块</li>
<li>指令修复 模块</li>
<li>跳板 模块</li>
<li>调度器 模块</li>
</ol>
<h4 id="1-内存分配-模块"><a href="#1-内存分配-模块" class="headerlink" title="1. 内存分配 模块"></a>1. 内存分配 模块</h4><p>需要分配部分内存用于写入指令, 这里需要关注两个函数都是关于内存属性相关的. 1. 如何使内存 <code>可写</code> 2. 如何使内存 <code>可执行</code></p>
<p>这一部分与具体的操作系统有关. 比如 <code>darwin</code> 使用 <code>mach_vm_allocate</code></p>
<p>在 lldb 中可以通过 <code>memory region address</code> 查看地址的内存属性.</p>
<p>当然这里也存在一个巨大的坑, IOS 下无法分配 <code>rwx</code> 属性的内存页. 这导致 inlinehook 无法在非越狱系统上使用, 并且只有 <code>MobileSafari</code> 才有 <code>VM_FLAGS_MAP_JIT</code> 权限. 具体解释请参下方 [坑-rwx 与 codesigning].</p>
<h4 id="2-指令写-模块"><a href="#2-指令写-模块" class="headerlink" title="2. 指令写 模块"></a>2. 指令写 模块</h4><p>先说坑,  非越狱状态下不允许设置 <code>rw-</code> 为 <code>r-x</code>, 或者  设置 <code>r-x</code> 为 <code>rx-</code>. 具体解释请参考下方坑 [坑-rwx 与 codesigning].</p>
<p>其实这里的指令写有种简单的方法, 就是在本地生成指令的16进制串, 之后直接写即可. 但这种应该是属于 hardcode.</p>
<p>这里使用 <code>frida-gum</code> 和 <code>CydiaSubstrace</code> 都用的方法, 把需要用到的指令都写成一个小函数.</p>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">gum_arm64_writer_put_ldr_reg_address (GumArm64Writer * self,</div><div class="line">                                      arm64_reg reg,</div><div class="line">                                      GumAddress address)</div><div class="line">&#123;</div><div class="line">  gum_arm64_writer_put_ldr_reg_u64(self, reg, (guint64)address);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void</div><div class="line">gum_arm64_writer_put_ldr_reg_u64 (GumArm64Writer * self,</div><div class="line">                                  arm64_reg reg,</div><div class="line">                                  guint64 val)</div><div class="line">&#123;</div><div class="line">  GumArm64RegInfo ri;</div><div class="line"></div><div class="line">  gum_arm64_writer_describe_reg(self, reg, &amp;ri);</div><div class="line"></div><div class="line">  g_assert_cmpuint(ri.width, ==, 64);</div><div class="line"></div><div class="line">  gum_arm64_writer_add_literal_reference_here(self, val);</div><div class="line">  gum_arm64_writer_put_instruction(</div><div class="line">      self, (ri.is_integer ? 0x58000000 : 0x5c000000) | ri.index);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实有另外一个小思路,  有一点小不足, 就是确定指令片段的长度, 但其实也有解决方法, <strong>可以放几条特殊指令作为结尾标记</strong>.</p>
<p>先使用内联汇编写一个函数.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">__attribute__((__naked__)) static void ctx_save() &#123;</div><div class="line">  __asm__ volatile(</div><div class="line"></div><div class="line">      /* reserve space for next_hop */</div><div class="line">      &quot;sub sp, sp, #(2*8)\n&quot;</div><div class="line"></div><div class="line">      /* save &#123;q0-q7&#125; */</div><div class="line">      &quot;sub sp, sp, #(8*16)\n&quot;</div><div class="line">      &quot;stp q6, q7, [sp, #(6*16)]\n&quot;</div><div class="line">      &quot;stp q4, q5, [sp, #(4*16)]\n&quot;</div><div class="line">      &quot;stp q2, q3, [sp, #(2*16)]\n&quot;</div><div class="line">      &quot;stp q0, q1, [sp, #(0*16)]\n&quot;</div><div class="line"></div><div class="line">      /* save &#123;x1-x30&#125; */</div><div class="line">      &quot;sub sp, sp, #(30*8)\n&quot;</div><div class="line">      &quot;stp fp, lr, [sp, #(28*8)]\n&quot;</div><div class="line">      &quot;stp x27, x28, [sp, #(26*8)]\n&quot;</div><div class="line">      &quot;stp x25, x26, [sp, #(24*8)]\n&quot;</div><div class="line">      &quot;stp x23, x24, [sp, #(22*8)]\n&quot;</div><div class="line">      &quot;stp x21, x22, [sp, #(20*8)]\n&quot;</div><div class="line">      &quot;stp x19, x20, [sp, #(18*8)]\n&quot;</div><div class="line">      &quot;stp x17, x18, [sp, #(16*8)]\n&quot;</div><div class="line">      &quot;stp x15, x16, [sp, #(14*8)]\n&quot;</div><div class="line">      &quot;stp x13, x14, [sp, #(12*8)]\n&quot;</div><div class="line">      &quot;stp x11, x12, [sp, #(10*8)]\n&quot;</div><div class="line">      &quot;stp x9, x10, [sp, #(8*8)]\n&quot;</div><div class="line">      &quot;stp x7, x8, [sp, #(6*8)]\n&quot;</div><div class="line">      &quot;stp x5, x6, [sp, #(4*8)]\n&quot;</div><div class="line">      &quot;stp x3, x4, [sp, #(2*8)]\n&quot;</div><div class="line">      &quot;stp x1, x2, [sp, #(0*8)]\n&quot;</div><div class="line"></div><div class="line">      /* save sp, x0 */</div><div class="line">      &quot;sub sp, sp, #(2*8)\n&quot;</div><div class="line">      &quot;add x1, sp, #(2*8 + 8*16 + 30*8 + 2*8)\n&quot;</div><div class="line">      &quot;stp x1, x0, [sp, #(0*8)]\n&quot;</div><div class="line"></div><div class="line">      /* alignment padding + dummy PC */</div><div class="line">      &quot;sub sp, sp, #(2*8)\n&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后直接复制这块函数内存数据即可, 这一般适合那种指令片段堆.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">void zz_build_enter_thunk(ZZWriter *writer) &#123;</div><div class="line"></div><div class="line">    // pop x17</div><div class="line">    writer_put_ldr_reg_reg_offset(writer, ARM64_REG_X17, ARM64_REG_SP, 0);</div><div class="line">    writer_put_add_reg_reg_imm(writer, ARM64_REG_SP, ARM64_REG_SP, 16);</div><div class="line"></div><div class="line">    // TODO:  is bad code ?</div><div class="line">    writer_put_bytes(writer, (void *) ctx_save, 26 * 4);</div><div class="line"></div><div class="line">    // call `function_context_begin_invocation`</div><div class="line">    writer_put_bytes(writer, (void *) pass_enter_func_args, 4 * 4);</div><div class="line">    writer_put_ldr_reg_address(</div><div class="line">            writer, ARM64_REG_X17,</div><div class="line">            (zaddr) (zpointer) function_context_begin_invocation);</div><div class="line">    writer_put_blr_reg(writer, ARM64_REG_X17);</div><div class="line"></div><div class="line">    // TOOD: is bad code ?</div><div class="line">    writer_put_bytes(writer, (void *) ctx_restore, 23 * 4);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-指令读-模块"><a href="#3-指令读-模块" class="headerlink" title="3. 指令读 模块"></a>3. 指令读 模块</h4><p>这一部分实际上就是 <code>disassembler</code>, 这一部分可以直接使用 <code>capstone</code>, 这里需要把 <code>capstone</code> 编译成多种架构.</p>
<h4 id="4-指令修复-模块"><a href="#4-指令修复-模块" class="headerlink" title="4. 指令修复 模块"></a>4. 指令修复 模块</h4><p>这里的指令修复主要是发生在 hook 函数头几条指令, 由于备份指令到另一个地址, 这就需要对所有 <code>PC(IP)</code> 相关指令进行修复.</p>
<p>大致的思路就是: 判断 <code>capstone</code> 读取到的指令 ID, 针对特定指令写一个小函数进行修复</p>
<p>例如在 <code>frida-gum</code> 中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static gboolean</div><div class="line">gum_arm64_relocator_rewrite_b (GumArm64Relocator * self,</div><div class="line">                               GumCodeGenCtx * ctx)</div><div class="line">&#123;</div><div class="line">  const cs_arm64_op *target = &amp;ctx-&gt;detail-&gt;operands[0];</div><div class="line"></div><div class="line">  (void)self;</div><div class="line"></div><div class="line">  gum_arm64_writer_put_ldr_reg_address(ctx-&gt;output, ARM64_REG_X17, target-&gt;imm);</div><div class="line">  gum_arm64_writer_put_br_reg(ctx-&gt;output, ARM64_REG_X17);</div><div class="line"></div><div class="line">  return TRUE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5-跳板-模块"><a href="#5-跳板-模块" class="headerlink" title="5. 跳板 模块"></a>5. 跳板 模块</h4><p>跳板模块的设计是希望各个模块的实现更浅的耦合, 跳板函数主要作用就是进行跳转, 并准备 <code>跳转目标</code> 需要的参数. 举个例子, 被 hook 的函数经过入口跳板(<code>enter_trampoline</code>), 跳转到调度函数(<code>enter_chunk</code>), 需要被 hook 的函数相关信息等, 这个就需要在构造跳板是完成</p>
<h4 id="6-调度-模块"><a href="#6-调度-模块" class="headerlink" title="6. 调度 模块"></a>6. 调度 模块</h4><p>可以理解为所有被 hook 的函数都必须经过的函数, 类似于 <code>objc_msgSend</code>, 在这里通过栈来函数(<code>pre_call</code>, <code>replace_call</code>, <code>post_call</code>)调用顺序.</p>
<p>本质有些类似于 <code>objc_msgSend</code> 所有的被 hook 的函数都在经过 <code>enter_trampoline</code> 跳板后, 跳转到 <code>enter_thunk</code>, 在此进行下一步的跳转判断决定, 并不是直接跳转到 <code>replace_call</code>.</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><strong>export 3 func</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// initialize the interceptor and so on.</div><div class="line">ZZSTATUS ZZInitialize(void);</div><div class="line"></div><div class="line">// build hook with `replace_call`, `pre_call`, `post_call`, but not enable.</div><div class="line">ZZSTATUS ZZBuildHook(zpointer target_ptr, zpointer replace_ptr, zpointer *origin_ptr, zpointer pre_call_ptr, zpointer post_call_ptr);</div><div class="line"></div><div class="line">// enable hook, with `code patch`</div><div class="line">ZZSTATUS ZZEnableHook(zpointer target_ptr);</div></pre></td></tr></table></figure>
<p>**export 1 variable:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">// current all cpu register state, read `zzdefs.h` for detail.</div><div class="line">#if defined (__aarch64__)</div><div class="line">typedef union FPReg_ &#123;</div><div class="line">    __int128_t q;</div><div class="line">    struct &#123;</div><div class="line">        double d1; // Holds the double (LSB).</div><div class="line">        double d2;</div><div class="line">    &#125; d;</div><div class="line">    struct &#123;</div><div class="line">        float f1; // Holds the float (LSB).</div><div class="line">        float f2;</div><div class="line">        float f3;</div><div class="line">        float f4;</div><div class="line">    &#125; f;</div><div class="line">&#125; FPReg;</div><div class="line"></div><div class="line">// just ref how to backup/restore registers</div><div class="line">struct RegState_ &#123;</div><div class="line">    uint64_t pc;</div><div class="line">    uint64_t sp;</div><div class="line"></div><div class="line">    union &#123;</div><div class="line">        uint64_t x[29];</div><div class="line">        struct &#123;</div><div class="line">            uint64_t x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28;</div><div class="line">        &#125; regs;</div><div class="line">    &#125; general;</div><div class="line"></div><div class="line">    uint64_t fp;</div><div class="line">    uint64_t lr;</div><div class="line"></div><div class="line">    union &#123;</div><div class="line">        FPReg q[8];</div><div class="line">        FPReg q0,q1,q2,q3,q4,q5,q6,q7;</div><div class="line">    &#125; floating;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在 <code>pre_call</code> 和 <code>post_call</code> 传递该变量.</p>
<h4 id="使用-pre-call-和-post-call"><a href="#使用-pre-call-和-post-call" class="headerlink" title="使用 pre_call 和 post_call"></a>使用 <code>pre_call</code> 和 <code>post_call</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">void *orig_recvmsg;</div><div class="line">// bad code, should be `thread-local variable` and `lock`</div><div class="line">zpointer recvmsg_data;</div><div class="line">void recvmsg_pre_call(struct RegState_ *rs) &#123;</div><div class="line">  zpointer t = *((zpointer *)(rs-&gt;general.regs.x1) + 2);</div><div class="line">  recvmsg_data = *(zpointer *)t;</div><div class="line">&#125;</div><div class="line">void recvmsg_post_call(struct RegState_ *rs) &#123;</div><div class="line">  printf(&quot;@recvmsg@: %s\n&quot;, recvmsg_data);</div><div class="line">&#125;</div><div class="line">__attribute__((constructor)) void test_hook_recvmsg() &#123;</div><div class="line">  ZZInitialize();</div><div class="line">  ZZBuildHook((void *)recvmsg, NULL, (void **)(&amp;orig_recvmsg),</div><div class="line">              (zpointer)recvmsg_pre_call, (zpointer)recvmsg_post_call);</div><div class="line">  ZZEnableHook((void *)recvmsg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用-replace-call"><a href="#使用-replace-call" class="headerlink" title="使用 replace_call"></a>使用 <code>replace_call</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">void *orig_func;</div><div class="line">__attribute__((constructor)) void test_hook_recvmsg() &#123;</div><div class="line">  ZZInitialize();</div><div class="line">  ZZBuildHook((void *)func, (void *)fake_func, (void **)(&amp;orig_func), NULL,</div><div class="line">              NULL);</div><div class="line">  ZZEnableHook((void *)func);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="对于-Objective-C-方法呢"><a href="#对于-Objective-C-方法呢" class="headerlink" title="对于 Objective-C 方法呢 ?"></a>对于 Objective-C 方法呢 ?</h4><p>这里需要对 <code>&lt;objc/runtime.h&gt;</code> 里的函数比较了解. 也需要对 objc 的内存有一些了解.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">+ (void)load</div><div class="line">&#123;</div><div class="line">    [self zzMethodSwizzlingHook];</div><div class="line">&#125;</div><div class="line"></div><div class="line">void objcMethod_pre_call(struct RegState_ *rs) &#123;</div><div class="line">  NSLog(@&quot;hookzz OC-Method: -[ViewController %s]&quot;,</div><div class="line">        (zpointer)(rs-&gt;general.regs.x1));</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)zzMethodSwizzlingHook &#123;</div><div class="line">  Class hookClass = objc_getClass(&quot;UIViewController&quot;);</div><div class="line">  SEL oriSEL = @selector(viewWillAppear:);</div><div class="line">  Method oriMethod = class_getInstanceMethod(hookClass, oriSEL);</div><div class="line">  IMP oriImp = method_getImplementation(oriMethod);</div><div class="line"></div><div class="line">  ZZInitialize();</div><div class="line">  ZZBuildHook((void *)oriImp, NULL, NULL, (zpointer)objcMethod_pre_call, NULL);</div><div class="line">  ZZEnableHook((void *)oriImp);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="编译-amp-测试"><a href="#编译-amp-测试" class="headerlink" title="编译 &amp; 测试"></a>编译 &amp; 测试</h2><h4 id="arm64-amp-ios-架构"><a href="#arm64-amp-ios-架构" class="headerlink" title="arm64 &amp; ios 架构"></a>arm64 &amp; ios 架构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">λ : &gt;&gt;&gt; make -f darwin.ios.mk darwin.ios</div><div class="line">generate [src/allocator.o]!</div><div class="line">generate [src/interceptor.o]!</div><div class="line">generate [src/trampoline.o]!</div><div class="line">generate [src/platforms/darwin/memory-darwin.o]!</div><div class="line">generate [src/platforms/arm64/reader.o]!</div><div class="line">generate [src/platforms/arm64/relocator.o]!</div><div class="line">generate [src/platforms/arm64/thunker.o]!</div><div class="line">generate [src/platforms/arm64/writer.o]!</div><div class="line">generate [src/zzdeps/darwin/memory-utils.o]!</div><div class="line">build success for arm64(IOS)!</div></pre></td></tr></table></figure>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>已经生成编译测试的 <code>test_hook.dylib</code> 与 <code>test_ios.dylib</code> 请自行测试</p>
<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><h4 id="寄存器污染"><a href="#寄存器污染" class="headerlink" title="寄存器污染"></a>寄存器污染</h4><p>在进行 inlinehook 需要进行各种跳转, 通常会以以下模板进行跳转.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0:  ldr x16, 8;</div><div class="line">4:  br x16;</div><div class="line">8:  0x12345678</div><div class="line">12: 0x00000000</div></pre></td></tr></table></figure>
<p>问题在于这会造成 x16 寄存器被污染. 所以这里有两种思路解决这个问题.</p>
<p>思路一:</p>
<p>在使用寄存器之前进行 <code>push</code>, 跳转后 <code>pop</code>, 这里存在一个问题就是在原地址的几条指令进行 <code>patch code</code> 时一定会污染一个寄存器(也不能说一定, 如果这时进行压栈, 在之后的 <code>invoke_trampline</code> 会导致函数栈发生改变, 此时有个解决方法可以 pop 出来, 由 hookentry 或者其他变量暂时保存, 但这时需要处理锁的问题. )</p>
<p>思路二:</p>
<p>挑选合适的寄存器, 不考虑污染问题. 这时可以参考, 下面的资料, 选择 x16 or x17, 或者自己做一个实验 <code>otool -tv ~/Downloads/DiSpecialDriver64 &gt; ~/Downloads/DiSpecialDriver64.txt</code> 通过 dump 一个 arm64 程序的指令, 来判断哪个寄存器用的最少, 但是不要使用 x18 寄存器, 你对该寄存器的修改是无效的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PAGE: 9-3</div><div class="line">Programmer’s Guide for ARMv8-A</div><div class="line">9.1 Register use in the AArch64 Procedure Call Standard </div><div class="line">9.1.1 Parameters in general-purpose registers</div></pre></td></tr></table></figure>
<p>这里也有一个问题,  这也是 <code>frida-gum</code> 中遇到一个问题, 就是对于 svc 类系统调用, 系统调用号(syscall number)的传递是利用 x16 寄存器进行传递的, 所以本框架使用 x17 寄存器, 并且在传递参数时使用, <code>push</code> &amp; <code>pop</code>, 在跳转后恢复 x17.</p>
<h4 id="rwx-与-codesigning"><a href="#rwx-与-codesigning" class="headerlink" title="rwx 与 codesigning"></a>rwx 与 codesigning</h4><p>对于非越狱, 不能分配可执行内存, 不能进行 <code>code patch</code>.</p>
<p>两篇原理讲解 codesign 的原理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">https://papers.put.as/papers/ios/2011/syscan11_breaking_ios_code_signing.pdf</div><div class="line">http://www.newosxbook.com/articles/CodeSigning.pdf</div></pre></td></tr></table></figure>
<p>以及源码分析如下:</p>
<p>crash 异常如下, 其中 <code>0x0000000100714000</code> 是 mmap 分配的页.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Exception Type:  EXC_BAD_ACCESS (SIGKILL - CODESIGNING)</div><div class="line">Exception Subtype: unknown at 0x0000000100714000</div><div class="line">Termination Reason: Namespace CODESIGNING, Code 0x2</div><div class="line">Triggered by Thread:  0</div></pre></td></tr></table></figure>
<p>寻找对应的错误码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">xnu-3789.41.3/bsd/sys/reason.h</div><div class="line">/*</div><div class="line"> * codesigning exit reasons</div><div class="line"> */</div><div class="line">#define CODESIGNING_EXIT_REASON_TASKGATED_INVALID_SIG 1</div><div class="line">#define CODESIGNING_EXIT_REASON_INVALID_PAGE          2</div><div class="line">#define CODESIGNING_EXIT_REASON_TASK_ACCESS_PORT      3</div></pre></td></tr></table></figure>
<p>找到对应处理函数, 请仔细阅读注释里内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"># xnu-3789.41.3/osfmk/vm/vm_fault.c:2632</div><div class="line"></div><div class="line">  /* If the map is switched, and is switch-protected, we must protect</div><div class="line">   * some pages from being write-faulted: immutable pages because by </div><div class="line">   * definition they may not be written, and executable pages because that</div><div class="line">   * would provide a way to inject unsigned code.</div><div class="line">   * If the page is immutable, we can simply return. However, we can&apos;t</div><div class="line">   * immediately determine whether a page is executable anywhere. But,</div><div class="line">   * we can disconnect it everywhere and remove the executable protection</div><div class="line">   * from the current map. We do that below right before we do the </div><div class="line">   * PMAP_ENTER.</div><div class="line">   */</div><div class="line">  cs_enforcement_enabled = cs_enforcement(NULL);</div><div class="line"></div><div class="line">  if(cs_enforcement_enabled &amp;&amp; map_is_switched &amp;&amp; </div><div class="line">     map_is_switch_protected &amp;&amp; page_immutable(m, prot) &amp;&amp; </div><div class="line">     (prot &amp; VM_PROT_WRITE))</div><div class="line">  &#123;</div><div class="line">    return KERN_CODESIGN_ERROR;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (cs_enforcement_enabled &amp;&amp; page_nx(m) &amp;&amp; (prot &amp; VM_PROT_EXECUTE)) &#123;</div><div class="line">    if (cs_debug)</div><div class="line">      printf(&quot;page marked to be NX, not letting it be mapped EXEC\n&quot;);</div><div class="line">    return KERN_CODESIGN_ERROR;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (cs_enforcement_enabled &amp;&amp;</div><div class="line">      !m-&gt;cs_validated &amp;&amp;</div><div class="line">      (prot &amp; VM_PROT_EXECUTE) &amp;&amp;</div><div class="line">      !(caller_prot &amp; VM_PROT_EXECUTE)) &#123;</div><div class="line">    /*</div><div class="line">     * FOURK PAGER:</div><div class="line">     * This page has not been validated and will not be</div><div class="line">     * allowed to be mapped for &quot;execute&quot;.</div><div class="line">     * But the caller did not request &quot;execute&quot; access for this</div><div class="line">     * fault, so we should not raise a code-signing violation</div><div class="line">     * (and possibly kill the process) below.</div><div class="line">     * Instead, let&apos;s just remove the &quot;execute&quot; access request.</div><div class="line">     * </div><div class="line">     * This can happen on devices with a 4K page size if a 16K</div><div class="line">     * page contains a mix of signed&amp;executable and</div><div class="line">     * unsigned&amp;non-executable 4K pages, making the whole 16K</div><div class="line">     * mapping &quot;executable&quot;.</div><div class="line">     */</div><div class="line">    prot &amp;= ~VM_PROT_EXECUTE;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /* A page could be tainted, or pose a risk of being tainted later.</div><div class="line">   * Check whether the receiving process wants it, and make it feel</div><div class="line">   * the consequences (that hapens in cs_invalid_page()).</div><div class="line">   * For CS Enforcement, two other conditions will </div><div class="line">   * cause that page to be tainted as well: </div><div class="line">   * - pmapping an unsigned page executable - this means unsigned code;</div><div class="line">   * - writeable mapping of a validated page - the content of that page</div><div class="line">   *   can be changed without the kernel noticing, therefore unsigned</div><div class="line">   *   code can be created</div><div class="line">   */</div><div class="line">  if (!cs_bypass &amp;&amp;</div><div class="line">      (m-&gt;cs_tainted ||</div><div class="line">       (cs_enforcement_enabled &amp;&amp;</div><div class="line">        (/* The page is unsigned and wants to be executable */</div><div class="line">         (!m-&gt;cs_validated &amp;&amp; (prot &amp; VM_PROT_EXECUTE))  ||</div><div class="line">         /* The page should be immutable, but is in danger of being modified</div><div class="line">    * This is the case where we want policy from the code directory -</div><div class="line">    * is the page immutable or not? For now we have to assume that </div><div class="line">    * code pages will be immutable, data pages not.</div><div class="line">    * We&apos;ll assume a page is a code page if it has a code directory </div><div class="line">    * and we fault for execution.</div><div class="line">    * That is good enough since if we faulted the code page for</div><div class="line">    * writing in another map before, it is wpmapped; if we fault</div><div class="line">    * it for writing in this map later it will also be faulted for executing </div><div class="line">    * at the same time; and if we fault for writing in another map</div><div class="line">    * later, we will disconnect it from this pmap so we&apos;ll notice</div><div class="line">    * the change.</div><div class="line">    */</div><div class="line">        (page_immutable(m, prot) &amp;&amp; ((prot &amp; VM_PROT_WRITE) || m-&gt;wpmapped))</div><div class="line">        ))</div><div class="line">        )) </div><div class="line">  &#123;</div></pre></td></tr></table></figure>
<h4 id="其他文章"><a href="#其他文章" class="headerlink" title="其他文章:"></a>其他文章:</h4><p><a href="http://ddeville.me/2014/04/dynamic-linking" target="_blank" rel="external">http://ddeville.me/2014/04/dynamic-linking</a></p>
<blockquote>
<p>Later on, whenever a page fault occurs the vm_fault function in <code>vm_fault.c</code> is called. During the page fault the signature is validated if necessary. The signature will need to be validated if the page is mapped in user space, if the page belongs to a code-signed object, if the page will be writable or simply if it has not previously been validated. Validation happens in the <code>vm_page_validate_cs</code> function inside vm_fault.c (the validation process and how it is enforced continually and not only at load time is interesting, see Charlie Miller’s book for more details).</p>
<p>If for some reason the page cannot be validated, the kernel checks whether the <code>CS_KILL</code> flag has been set and kills the process if necessary. There is a major distinction between iOS and OS X regarding this flag. All iOS processes have this flag set whereas on OS X, although code signing is checked it is not set and thus not enforced.</p>
<p>In our case we can safely assume that the (missing) code signature couldn’t be verified leading to the kernel killing the process.</p>
</blockquote>
<hr>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-08-01</span><i class="fa fa-tag"></i><a href="/categories/pwn/" title="pwn" class="tag">pwn </a><a href="/tags/hook/" title="hook" class="tag">hook </a><a href="/tags/inline-hook/" title="inline-hook" class="tag">inline-hook </a><a href="/tags/pwn/" title="pwn" class="tag">pwn </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://jmpews.github.com/2017/08/01/pwn/HookZz框架/,jmpews,HookZz框架,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2017/06/27/pwn/frida-gum源码解读/" title="frida-gum源码解读" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2017/08/09/darwin/反注入及绕过/" title="反注入及绕过[doing]" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>