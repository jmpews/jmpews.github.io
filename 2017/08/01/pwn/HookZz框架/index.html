<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="jmpews,jmpews@gmail.com"><title>HookZz框架 · jmpews</title><meta name="description" content="What is HookZz ?a cute hook framwork. 
still developing, for arm64/IOS now!
ref to: frida-gum and minhook and substrate.
special thanks to frida-gum&amp;#"><meta name="keywords" content="py,go,pwn,reverse"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">jmpews</a></h3><div class="description"><p>py &amp; go &amp; pwn &amp; reverse</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/jmpews"><i class="fa fa-twitter"></i></a></li><li><a href="http://weibo.com/winter1ife"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/jmpews"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>HookZz框架</a></h3></div><div class="post-content"><h1 id="What-is-HookZz"><a href="#What-is-HookZz" class="headerlink" title="What is HookZz ?"></a>What is HookZz ?</h1><p><strong>a cute hook framwork</strong>. </p>
<p><strong>still developing, for arm64/IOS now!</strong></p>
<p>ref to: <a href="https://github.com/frida/frida-gum" target="_blank" rel="external">frida-gum</a> and <a href="https://github.com/TsudaKageyu/minhook" target="_blank" rel="external">minhook</a> and <a href="https://github.com/jevinskie/substrate" target="_blank" rel="external">substrate</a>.</p>
<p><strong>special thanks to <code>frida-gum&#39;s</code> perfect code and modular architecture, frida is aircraft carrier, HookZz is boat.</strong></p>
<h1 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h1><ul>
<li><p><a href="https://github.com/jmpews/HookZzModules" target="_blank" rel="external">HookZz-Modules help you to hook.</a></p>
</li>
<li><p>the power to access registers directly</p>
</li>
<li><p>hook function with <code>replace_call</code></p>
</li>
<li><p>hook function with <code>pre_call</code> and <code>post_call</code></p>
</li>
<li><p>hook <strong>address(a piece of code)</strong> with <code>pre_call</code> and <code>half_call</code></p>
</li>
<li><p>(almost)only <strong>one instruction</strong> to hook(i.e.hook <strong>short funciton, even only one instruction</strong>)</p>
</li>
<li><p>runtime code patch, without codesign limit</p>
</li>
<li><p>it’s cute</p>
</li>
</ul>
<h1 id="HookFramework-架构设计"><a href="#HookFramework-架构设计" class="headerlink" title="HookFramework 架构设计"></a>HookFramework 架构设计</h1><p>一般来说可以分为以下几个模块</p>
<ol>
<li>内存分配 模块</li>
<li>指令写 模块</li>
<li>指令读 模块</li>
<li>指令修复 模块</li>
<li>跳板 模块</li>
<li>调度器 模块</li>
<li>栈 模块</li>
</ol>
<h4 id="1-内存分配-模块"><a href="#1-内存分配-模块" class="headerlink" title="1. 内存分配 模块"></a>1. 内存分配 模块</h4><p>需要分配部分内存用于写入指令, 这里需要关注两个函数都是关于内存属性相关的. 1. 如何使内存 <code>可写</code> 2. 如何使内存 <code>可执行</code> 3. 如何分配相近的内存来达到 <code>near jump</code></p>
<p>这一部分与具体的操作系统有关. 比如 <code>darwin</code> 下分配内存使用 <code>mmap</code> 实际使用的是 <code>mach_vm_allocate</code>. <a href="https://github.com/bminor/glibc/blob/master/sysdeps/mach/hurd/mmap.c" target="_blank" rel="external">move to detail</a>.</p>
<p>在 lldb 中可以通过 <code>memory region address</code> 查看地址的内存属性.</p>
<p>当然这里也存在一个巨大的坑, IOS 下无法分配 <code>rwx</code> 属性的内存页. 这导致 inlinehook 无法在非越狱系统上使用, 并且只有 <code>MobileSafari</code> 才有 <code>VM_FLAGS_MAP_JIT</code> 权限. 具体解释请参下方 <strong>[坑 - rwx 与 codesigning]</strong>.</p>
<p>另一个坑就是如何在 hook 目标周围分配内存, 如果可以分配到周围的内存, 可以直接使用 <code>b</code> 指令进行相对地址跳(<code>near jump</code>), 从而可以可以实现单指令的 hook.</p>
<p>举个例子比如 <code>b label</code>, 在 armv8 中的可以想在 <code>+-128MB</code> 范围内进行 <code>near jump</code>, 具体可以参考 <code>ARM Architecture Reference Manual ARMv8, for ARMv8-A architecture profile Page: C6-550</code>.</p>
<p>这里可以有三个尝试.</p>
<ol>
<li><p>使用 <code>mmap</code> 的 <code>MAP_FIXED</code> 尝试在周围地址分配内存页, 成功几率小.</p>
</li>
<li><p>尝试使用 <code>vm_region_recurse_64</code> 搜索 <code>protection</code> 为 <code>PROT_EXEC</code> &amp; <code>PROT_READ</code> 的 <code>code cave</code>. (通常用来暴力查找 <code>dyld</code> 的地址)</p>
</li>
<li><p>尝试搜索内存空洞(<code>code cave</code>), 搜索 <code>__text</code> 这个 <code>section</code> 其实更准确来说是搜索 <code>__TEXT</code> 这个 <code>segment</code>. 由于内存页对齐的原因以及其他原因很容易出现 <code>code cave</code>. 所以只需要搜索这个区间内的 <code>00</code> 即可, <code>00</code> 本身就是无效指令, 所以可以判断该位置无指令使用.</p>
</li>
</ol>
<p>当然还可以有强制相对跳(<code>double jump</code>), 直接对 <code>+-128MB</code> 内选一个地址强制 code patch 并修复.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">__asm__ &#123;</div><div class="line">  // 第一次绝对地址跳, 跳转到修复模块, 执行正常流程</div><div class="line">  &quot;ldr x17, #0x8\n&quot;</div><div class="line">  &quot;b #0xc\n&quot;</div><div class="line">  &quot;.long\n&quot;</div><div class="line">  &quot;.long\n&quot;</div><div class="line">  &quot;br x17&quot;</div><div class="line"></div><div class="line">  // double jump, 跳转到 on_enter_trampoline</div><div class="line">  &quot;ldr x17, #0x8\n&quot;</div><div class="line">  &quot;b #0xc\n&quot;</div><div class="line">  &quot;.long\n&quot;</div><div class="line">  &quot;.long\n&quot;</div><div class="line">  &quot;br x17&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-指令写-模块"><a href="#2-指令写-模块" class="headerlink" title="2. 指令写 模块"></a>2. 指令写 模块</h4><p>先说坑,  非越狱状态下不允许设置 <code>rw-</code> 为 <code>r-x</code>, 或者  设置 <code>r-x</code> 为 <code>rx-</code>. 具体解释请参考下方坑 <strong>[坑-rwx 与 codesigning]</strong>.</p>
<p>其实这里的指令写有种简单的方法, 就是在本地生成指令的16进制串, 之后直接写即可. 但这种应该是属于 hardcode.</p>
<p>这里使用 <code>frida-gum</code> 和 <code>CydiaSubstrace</code> 都用的方法, 把需要用到的指令都写成一个小函数.</p>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// frida-gum/gum/arch-arm64/gumarm64writer.c</div><div class="line">void</div><div class="line">gum_arm64_writer_put_ldr_reg_address (GumArm64Writer * self,</div><div class="line">                                      arm64_reg reg,</div><div class="line">                                      GumAddress address)</div><div class="line">&#123;</div><div class="line">  gum_arm64_writer_put_ldr_reg_u64 (self, reg, (guint64) address);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void</div><div class="line">gum_arm64_writer_put_ldr_reg_u64 (GumArm64Writer * self,</div><div class="line">                                  arm64_reg reg,</div><div class="line">                                  guint64 val)</div><div class="line">&#123;</div><div class="line">  GumArm64RegInfo ri;</div><div class="line"></div><div class="line">  gum_arm64_writer_describe_reg (self, reg, &amp;ri);</div><div class="line"></div><div class="line">  g_assert_cmpuint (ri.width, ==, 64);</div><div class="line"></div><div class="line">  gum_arm64_writer_add_literal_reference_here (self, val);</div><div class="line">  gum_arm64_writer_put_instruction (self,</div><div class="line">      (ri.is_integer ? 0x58000000 : 0x5c000000) | ri.index);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实有另外一个小思路,  有一点小不足, 就是确定指令片段的长度, 但其实也有解决方法, <strong>可以放几条特殊指令作为结尾标记</strong>.</p>
<p>先使用内联汇编写一个函数.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">__attribute__((__naked__)) static void ctx_save() &#123;</div><div class="line">  __asm__ volatile(</div><div class="line"></div><div class="line">      /* reserve space for next_hop */</div><div class="line">      &quot;sub sp, sp, #(2*8)\n&quot;</div><div class="line"></div><div class="line">      /* save &#123;q0-q7&#125; */</div><div class="line">      &quot;sub sp, sp, #(8*16)\n&quot;</div><div class="line">      &quot;stp q6, q7, [sp, #(6*16)]\n&quot;</div><div class="line">      &quot;stp q4, q5, [sp, #(4*16)]\n&quot;</div><div class="line">      &quot;stp q2, q3, [sp, #(2*16)]\n&quot;</div><div class="line">      &quot;stp q0, q1, [sp, #(0*16)]\n&quot;</div><div class="line"></div><div class="line">      /* save &#123;x1-x30&#125; */</div><div class="line">      &quot;sub sp, sp, #(30*8)\n&quot;</div><div class="line">      &quot;stp fp, lr, [sp, #(28*8)]\n&quot;</div><div class="line">      &quot;stp x27, x28, [sp, #(26*8)]\n&quot;</div><div class="line">      &quot;stp x25, x26, [sp, #(24*8)]\n&quot;</div><div class="line">      &quot;stp x23, x24, [sp, #(22*8)]\n&quot;</div><div class="line">      &quot;stp x21, x22, [sp, #(20*8)]\n&quot;</div><div class="line">      &quot;stp x19, x20, [sp, #(18*8)]\n&quot;</div><div class="line">      &quot;stp x17, x18, [sp, #(16*8)]\n&quot;</div><div class="line">      &quot;stp x15, x16, [sp, #(14*8)]\n&quot;</div><div class="line">      &quot;stp x13, x14, [sp, #(12*8)]\n&quot;</div><div class="line">      &quot;stp x11, x12, [sp, #(10*8)]\n&quot;</div><div class="line">      &quot;stp x9, x10, [sp, #(8*8)]\n&quot;</div><div class="line">      &quot;stp x7, x8, [sp, #(6*8)]\n&quot;</div><div class="line">      &quot;stp x5, x6, [sp, #(4*8)]\n&quot;</div><div class="line">      &quot;stp x3, x4, [sp, #(2*8)]\n&quot;</div><div class="line">      &quot;stp x1, x2, [sp, #(0*8)]\n&quot;</div><div class="line"></div><div class="line">      /* save sp, x0 */</div><div class="line">      &quot;sub sp, sp, #(2*8)\n&quot;</div><div class="line">      &quot;add x1, sp, #(2*8 + 8*16 + 30*8 + 2*8)\n&quot;</div><div class="line">      &quot;stp x1, x0, [sp, #(0*8)]\n&quot;</div><div class="line"></div><div class="line">      /* alignment padding + dummy PC */</div><div class="line">      &quot;sub sp, sp, #(2*8)\n&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后直接复制这块函数内存数据即可, 这一般适合那种指令片段堆.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">void ZzThunkerBuildEnterThunk(ZzWriter *writer)</div><div class="line">&#123;</div><div class="line"></div><div class="line">    // pop x17</div><div class="line">    writer_put_ldr_reg_reg_offset(writer, ARM64_REG_X17, ARM64_REG_SP, 0);</div><div class="line">    writer_put_add_reg_reg_imm(writer, ARM64_REG_SP, ARM64_REG_SP, 16);</div><div class="line"></div><div class="line">    writer_put_bytes(writer, (void *)ctx_save, 26 * 4);</div><div class="line"></div><div class="line">    // call `function_context_begin_invocation`</div><div class="line">    writer_put_bytes(writer, (void *)pass_enter_func_args, 4 * 4);</div><div class="line">    writer_put_ldr_reg_address(</div><div class="line">        writer, ARM64_REG_X17,</div><div class="line">        (zaddr)(zpointer)function_context_begin_invocation);</div><div class="line">    writer_put_blr_reg(writer, ARM64_REG_X17);</div><div class="line"></div><div class="line">    writer_put_bytes(writer, (void *)ctx_restore, 23 * 4);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-指令读-模块"><a href="#3-指令读-模块" class="headerlink" title="3. 指令读 模块"></a>3. 指令读 模块</h4><p>这一部分实际上就是 <code>disassembler</code>, 这一部分可以直接使用 <code>capstone</code>, 这里需要把 <code>capstone</code> 编译成多种架构.</p>
<h4 id="4-指令修复-模块"><a href="#4-指令修复-模块" class="headerlink" title="4. 指令修复 模块"></a>4. 指令修复 模块</h4><p>这里的指令修复主要是发生在 hook 函数头几条指令, 由于备份指令到另一个地址, 这就需要对所有 <code>PC(IP)</code> 相关指令进行修复. 对于确定的哪些指令需要修复可以参考 <a href="http://jmpews.github.io/2017/05/17/pwn/%E8%A7%A3%E6%9E%90ARM%E5%92%8Cx86_x64%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F/" target="_blank" rel="external">Move to &lt;解析ARM和x86_x64指令格式&gt;</a>.</p>
<p>大致的思路就是: 判断 <code>capstone</code> 读取到的指令 ID, 针对特定指令写一个小函数进行修复.</p>
<p>例如在 <code>frida-gum</code> 中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">frida-gum/gum/arch-arm64/gumarm64relocator.c</div><div class="line">static gboolean</div><div class="line">gum_arm64_relocator_rewrite_b (GumArm64Relocator * self,</div><div class="line">                               GumCodeGenCtx * ctx)</div><div class="line">&#123;</div><div class="line">  const cs_arm64_op * target = &amp;ctx-&gt;detail-&gt;operands[0];</div><div class="line"></div><div class="line">  (void) self;</div><div class="line"></div><div class="line">  gum_arm64_writer_put_ldr_reg_address (ctx-&gt;output, ARM64_REG_X16,</div><div class="line">      target-&gt;imm);</div><div class="line">  gum_arm64_writer_put_br_reg (ctx-&gt;output, ARM64_REG_X16);</div><div class="line"></div><div class="line">  return TRUE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5-跳板-模块"><a href="#5-跳板-模块" class="headerlink" title="5. 跳板 模块"></a>5. 跳板 模块</h4><p>跳板模块的设计是希望各个模块的实现更浅的耦合, 跳板函数主要作用就是进行跳转, 并准备 <code>跳转目标</code> 需要的参数. 举个例子, 被 hook 的函数经过入口跳板(<code>enter_trampoline</code>), 跳转到调度函数(<code>enter_chunk</code>), 需要被 hook 的函数相关信息等, 这个就需要在构造跳板时完成.</p>
<h4 id="6-调度-模块"><a href="#6-调度-模块" class="headerlink" title="6. 调度 模块"></a>6. 调度 模块</h4><p>可以理解为所有被 hook 的函数都必须经过的函数, 类似于 <code>objc_msgSend</code>, 在这里通过栈返回值来控制函数(<code>replace_call</code>, <code>pre_call</code>, <code>half_call</code>, <code>post_call</code>)调用顺序.</p>
<p>本质有些类似于 <code>objc_msgSend</code> 所有的被 hook 的函数都在经过 <code>enter_trampoline</code> 跳板后, 跳转到 <code>enter_thunk</code>, 在此进行下一步的跳转判断决定, 并不是直接跳转到 <code>replace_call</code>.</p>
<h4 id="7-栈模块"><a href="#7-栈模块" class="headerlink" title="7. 栈模块"></a>7. 栈模块</h4><p>如果希望在 <code>pre_call</code> 和 <code>post_call</code>  使用同一个局部变量, 就想在同一个函数内一样. 在 <code>frida-js</code> 中也就是 <code>this</code> 这个关键字. 这就需要自建函数栈, 模拟栈的行为. 同时还要避免线程冲突, 所以需要使用 <code>thread local variable</code>, 为每一个线程中的每一个 <code>hook-entry</code> 添加线程栈, 同时为每一次调用添加函数栈. 所以这里存在两种栈. 1. 线程栈(保存了该 hook-entry 的所有当前函数调用栈) 2. 函数调用栈(本次函数调用时的栈)</p>
<h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><h2 id="ldr-指令"><a href="#ldr-指令" class="headerlink" title="ldr 指令"></a><code>ldr</code> 指令</h2><p>在进行指令修复时, 需要需要将 PC 相关的地址转换为绝对地址, 其中涉及到保存地址到寄存器. 一般来说是使用指令 <code>ldr</code>. 也就是说如何完成该函数 <code>writer_put_ldr_reg_address(relocate_writer, ARM64_REG_X17, target_addr);</code></p>
<p><code>frida-gum</code> 的实现原理是, 有一个相对地址表, 在整体一段写完后进行修复.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">gum_arm64_writer_put_ldr_reg_u64 (GumArm64Writer * self,</div><div class="line">                                  arm64_reg reg,</div><div class="line">                                  guint64 val)</div><div class="line">&#123;</div><div class="line">  GumArm64RegInfo ri;</div><div class="line"></div><div class="line">  gum_arm64_writer_describe_reg (self, reg, &amp;ri);</div><div class="line"></div><div class="line">  g_assert_cmpuint (ri.width, ==, 64);</div><div class="line"></div><div class="line">  gum_arm64_writer_add_literal_reference_here (self, val);</div><div class="line">  gum_arm64_writer_put_instruction (self,</div><div class="line">      (ri.is_integer ? 0x58000000 : 0x5c000000) | ri.index);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 HookZz 中的实现, 直接将地址写在指令后, 之后使用 <code>b</code> 到正常的下一条指令, 从而实现将地址保存到寄存器.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void writer_put_ldr_reg_address(ZzWriter *self, arm64_reg reg, zaddr address)</div><div class="line">&#123;</div><div class="line">    writer_put_ldr_reg_imm(self, reg, (zuint)0x8);</div><div class="line">    writer_put_b_imm(self, (zaddr)0xc);</div><div class="line">    writer_put_bytes(self, (zpointer)&amp;address, sizeof(address));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是下面的样子.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">__asm__ &#123;</div><div class="line">  &quot;ldr x17, #0x8\n&quot;</div><div class="line">  &quot;b #0xc\n&quot;</div><div class="line">  &quot;.long\n&quot;</div><div class="line">  &quot;.long\n&quot;</div><div class="line">  &quot;br x17&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="寄存器污染"><a href="#寄存器污染" class="headerlink" title="寄存器污染"></a>寄存器污染</h2><p>在进行 inlinehook 需要进行各种跳转, 通常会以以下模板进行跳转.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0:  ldr x16, 8;</div><div class="line">4:  br x16;</div><div class="line">8:  0x12345678</div><div class="line">12: 0x00000000</div></pre></td></tr></table></figure>
<p>问题在于这会造成 x16 寄存器被污染(arm64 中 <code>svc #0x80</code> 使用 x16 传递系统调用号) 所以这里有两种思路解决这个问题.</p>
<p>思路一:</p>
<p>在使用寄存器之前进行 <code>push</code>, 跳转后 <code>pop</code>, 这里存在一个问题就是在原地址的几条指令进行 <code>patch code</code> 时一定会污染一个寄存器(也不能说一定, 如果这时进行压栈, 在之后的 <code>invoke_trampline</code> 会导致函数栈发生改变, 此时有个解决方法可以 <code>pop</code> 出来, 由 hook-entry 或者其他变量暂时保存, 但这时需要处理锁的问题. )</p>
<p>思路二:</p>
<p>挑选合适的寄存器, 不考虑污染问题. 这时可以参考, 下面的资料, 选择 x16 or x17, 或者自己做一个实验 <code>otool -tv ~/Downloads/DiSpecialDriver64 &gt; ~/Downloads/DiSpecialDriver64.txt</code> 通过 dump 一个 arm64 程序的指令, 来判断哪个寄存器用的最少, 但是不要使用 <code>x18</code> 寄存器, 你对该寄存器的修改是无效的.</p>
<p>Tips: 之前还想过为对每一个寄存器都做适配, 用户可以选择当前的 <code>hook-entry</code> 选择哪一个寄存器作为临时寄存器.</p>
<p>参考资料:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PAGE: 9-3</div><div class="line">Programmer’s Guide for ARMv8-A</div><div class="line">9.1 Register use in the AArch64 Procedure Call Standard </div><div class="line">9.1.1 Parameters in general-purpose registers</div></pre></td></tr></table></figure>
<p>这里也有一个问题,  这也是 <code>frida-gum</code> 中遇到一个问题, 就是对于 <code>svc #0x80</code> 类系统调用, 系统调用号(syscall number)的传递是利用 <code>x16</code> 寄存器进行传递的, 所以本框架使用 <code>x17</code> 寄存器, 并且在传递参数时使用 <code>push</code> &amp; <code>pop</code>, 在跳转后恢复 <code>x17</code>, 避免了一个寄存器的使用.</p>
<h2 id="rwx-与-codesigning"><a href="#rwx-与-codesigning" class="headerlink" title="rwx 与 codesigning"></a><code>rwx</code> 与 <code>codesigning</code></h2><p>对于非越狱, 不能分配可执行内存, 不能进行 <code>code patch</code>.</p>
<p>两篇原理讲解 codesign 的原理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">https://papers.put.as/papers/ios/2011/syscan11_breaking_ios_code_signing.pdf</div><div class="line">http://www.newosxbook.com/articles/CodeSigning.pdf</div></pre></td></tr></table></figure>
<p>以及源码分析如下:</p>
<p>crash 异常如下, 其中 <code>0x0000000100714000</code> 是 mmap 分配的页.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Exception Type:  EXC_BAD_ACCESS (SIGKILL - CODESIGNING)</div><div class="line">Exception Subtype: unknown at 0x0000000100714000</div><div class="line">Termination Reason: Namespace CODESIGNING, Code 0x2</div><div class="line">Triggered by Thread:  0</div></pre></td></tr></table></figure>
<p>寻找对应的错误码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">xnu-3789.41.3/bsd/sys/reason.h</div><div class="line">/*</div><div class="line"> * codesigning exit reasons</div><div class="line"> */</div><div class="line">#define CODESIGNING_EXIT_REASON_TASKGATED_INVALID_SIG 1</div><div class="line">#define CODESIGNING_EXIT_REASON_INVALID_PAGE          2</div><div class="line">#define CODESIGNING_EXIT_REASON_TASK_ACCESS_PORT      3</div></pre></td></tr></table></figure>
<p>找到对应处理函数, 请仔细阅读注释里内容, 不做解释了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"># xnu-3789.41.3/osfmk/vm/vm_fault.c:2632</div><div class="line"></div><div class="line">  /* If the map is switched, and is switch-protected, we must protect</div><div class="line">   * some pages from being write-faulted: immutable pages because by </div><div class="line">   * definition they may not be written, and executable pages because that</div><div class="line">   * would provide a way to inject unsigned code.</div><div class="line">   * If the page is immutable, we can simply return. However, we can&apos;t</div><div class="line">   * immediately determine whether a page is executable anywhere. But,</div><div class="line">   * we can disconnect it everywhere and remove the executable protection</div><div class="line">   * from the current map. We do that below right before we do the </div><div class="line">   * PMAP_ENTER.</div><div class="line">   */</div><div class="line">  cs_enforcement_enabled = cs_enforcement(NULL);</div><div class="line"></div><div class="line">  if(cs_enforcement_enabled &amp;&amp; map_is_switched &amp;&amp; </div><div class="line">     map_is_switch_protected &amp;&amp; page_immutable(m, prot) &amp;&amp; </div><div class="line">     (prot &amp; VM_PROT_WRITE))</div><div class="line">  &#123;</div><div class="line">    return KERN_CODESIGN_ERROR;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (cs_enforcement_enabled &amp;&amp; page_nx(m) &amp;&amp; (prot &amp; VM_PROT_EXECUTE)) &#123;</div><div class="line">    if (cs_debug)</div><div class="line">      printf(&quot;page marked to be NX, not letting it be mapped EXEC\n&quot;);</div><div class="line">    return KERN_CODESIGN_ERROR;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (cs_enforcement_enabled &amp;&amp;</div><div class="line">      !m-&gt;cs_validated &amp;&amp;</div><div class="line">      (prot &amp; VM_PROT_EXECUTE) &amp;&amp;</div><div class="line">      !(caller_prot &amp; VM_PROT_EXECUTE)) &#123;</div><div class="line">    /*</div><div class="line">     * FOURK PAGER:</div><div class="line">     * This page has not been validated and will not be</div><div class="line">     * allowed to be mapped for &quot;execute&quot;.</div><div class="line">     * But the caller did not request &quot;execute&quot; access for this</div><div class="line">     * fault, so we should not raise a code-signing violation</div><div class="line">     * (and possibly kill the process) below.</div><div class="line">     * Instead, let&apos;s just remove the &quot;execute&quot; access request.</div><div class="line">     * </div><div class="line">     * This can happen on devices with a 4K page size if a 16K</div><div class="line">     * page contains a mix of signed&amp;executable and</div><div class="line">     * unsigned&amp;non-executable 4K pages, making the whole 16K</div><div class="line">     * mapping &quot;executable&quot;.</div><div class="line">     */</div><div class="line">    prot &amp;= ~VM_PROT_EXECUTE;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /* A page could be tainted, or pose a risk of being tainted later.</div><div class="line">   * Check whether the receiving process wants it, and make it feel</div><div class="line">   * the consequences (that hapens in cs_invalid_page()).</div><div class="line">   * For CS Enforcement, two other conditions will </div><div class="line">   * cause that page to be tainted as well: </div><div class="line">   * - pmapping an unsigned page executable - this means unsigned code;</div><div class="line">   * - writeable mapping of a validated page - the content of that page</div><div class="line">   *   can be changed without the kernel noticing, therefore unsigned</div><div class="line">   *   code can be created</div><div class="line">   */</div><div class="line">  if (!cs_bypass &amp;&amp;</div><div class="line">      (m-&gt;cs_tainted ||</div><div class="line">       (cs_enforcement_enabled &amp;&amp;</div><div class="line">        (/* The page is unsigned and wants to be executable */</div><div class="line">         (!m-&gt;cs_validated &amp;&amp; (prot &amp; VM_PROT_EXECUTE))  ||</div><div class="line">         /* The page should be immutable, but is in danger of being modified</div><div class="line">    * This is the case where we want policy from the code directory -</div><div class="line">    * is the page immutable or not? For now we have to assume that </div><div class="line">    * code pages will be immutable, data pages not.</div><div class="line">    * We&apos;ll assume a page is a code page if it has a code directory </div><div class="line">    * and we fault for execution.</div><div class="line">    * That is good enough since if we faulted the code page for</div><div class="line">    * writing in another map before, it is wpmapped; if we fault</div><div class="line">    * it for writing in this map later it will also be faulted for executing </div><div class="line">    * at the same time; and if we fault for writing in another map</div><div class="line">    * later, we will disconnect it from this pmap so we&apos;ll notice</div><div class="line">    * the change.</div><div class="line">    */</div><div class="line">        (page_immutable(m, prot) &amp;&amp; ((prot &amp; VM_PROT_WRITE) || m-&gt;wpmapped))</div><div class="line">        ))</div><div class="line">        )) </div><div class="line">  &#123;</div></pre></td></tr></table></figure>
<h4 id="其他文章"><a href="#其他文章" class="headerlink" title="其他文章:"></a>其他文章:</h4><p><a href="http://ddeville.me/2014/04/dynamic-linking" target="_blank" rel="external">http://ddeville.me/2014/04/dynamic-linking</a></p>
<blockquote>
<p>Later on, whenever a page fault occurs the vm_fault function in <code>vm_fault.c</code> is called. During the page fault the signature is validated if necessary. The signature will need to be validated if the page is mapped in user space, if the page belongs to a code-signed object, if the page will be writable or simply if it has not previously been validated. Validation happens in the <code>vm_page_validate_cs</code> function inside vm_fault.c (the validation process and how it is enforced continually and not only at load time is interesting, see Charlie Miller’s book for more details).</p>
<p>If for some reason the page cannot be validated, the kernel checks whether the <code>CS_KILL</code> flag has been set and kills the process if necessary. There is a major distinction between iOS and OS X regarding this flag. All iOS processes have this flag set whereas on OS X, although code signing is checked it is not set and thus not enforced.</p>
<p>In our case we can safely assume that the (missing) code signature couldn’t be verified leading to the kernel killing the process.</p>
</blockquote>
<hr>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-08-01</span><i class="fa fa-tag"></i><a href="/categories/pwn/" title="pwn" class="tag">pwn </a><a href="/tags/hook/" title="hook" class="tag">hook </a><a href="/tags/pwn/" title="pwn" class="tag">pwn </a><a href="/tags/inline-hook/" title="inline-hook" class="tag">inline-hook </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://jmpews.github.com/2017/08/01/pwn/HookZz框架/,jmpews,HookZz框架,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2017/06/27/pwn/frida-gum源码解读/" title="frida-gum源码解读" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2017/08/09/darwin/反注入及绕过/" title="反注入及绕过[doing]" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>