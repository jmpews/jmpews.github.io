<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="jmpews,jmpews@gmail.com"><title>反注入及绕过 · jmpews</title><meta name="description" content="任何带特征的检测都是不安全的 &amp;amp; 隐而不发
之前说了下关于反调试的相关, 这次说下反注入相关.
前言要实现 hook 的首要前提就是能够注入. 但是注入的手段比较多, 目前常见的三种, 
1. DYLD_INSERT_LIBRARIES
这种主要是 CydiaSubstrate 使用的注入方"><meta name="keywords" content="py,go,pwn,reverse"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">jmpews</a></h3><div class="description"><p>py &amp; go &amp; pwn &amp; reverse</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/jmpews"><i class="fa fa-twitter"></i></a></li><li><a href="http://weibo.com/winter1ife"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/jmpews"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>反注入及绕过</a></h3></div><div class="post-content"><p><strong>任何带特征的检测都是不安全的 &amp; 隐而不发</strong></p>
<p>之前说了下关于反调试的相关, 这次说下反注入相关.</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>要实现 hook 的首要前提就是能够注入. 但是注入的手段比较多, 目前常见的三种, </p>
<p><strong>1. <code>DYLD_INSERT_LIBRARIES</code></strong></p>
<p>这种主要是 <code>CydiaSubstrate</code> 使用的注入方式, 首先将自身通过 <code>pthread</code> 远程线程注入到 <code>launchd</code>. 之后通过 <code>hook_posix_spawn_generic</code> 这个函数为启动的 app, 添加 <code>DYLD_INSERT_LIBRARIES</code> env.</p>
<p><strong>2. <code>LC_LOAD_DYLIB</code></strong></p>
<p>修改 macho 文件结构, 写入依赖库.</p>
<p><code>__restrict</code>, <code>optool</code>, <code>yololib</code></p>
<p><strong>3. <code>dlopen</code></strong></p>
<p><strong>4. <code>frida-core</code></strong></p>
<p><strong>4. <code>pthread</code> 远程注入</strong></p>
<p><a href="http://bbs.pediy.com/thread-187833.htm" target="_blank" rel="external">http://bbs.pediy.com/thread-187833.htm</a></p>
<h2 id="反注入-绕过"><a href="#反注入-绕过" class="headerlink" title="反注入 绕过"></a>反注入 绕过</h2><p>先对这些进行 hook, 这些都是存在 反注入的可能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * The following functions allow you to iterate through all loaded images.  </div><div class="line"> * This is not a thread safe operation.  Another thread can add or remove</div><div class="line"> * an image during the iteration.  </div><div class="line"> *</div><div class="line"> * Many uses of these routines can be replace by a call to dladdr() which </div><div class="line"> * will return the mach_header and name of an image, given an address in </div><div class="line"> * the image. dladdr() is thread safe.</div><div class="line"> */</div><div class="line">extern uint32_t                    _dyld_image_count(void)                              __OSX_AVAILABLE_STARTING(__MAC_10_1, __IPHONE_2_0);</div><div class="line">extern const struct mach_header*   _dyld_get_image_header(uint32_t image_index)         __OSX_AVAILABLE_STARTING(__MAC_10_1, __IPHONE_2_0);</div><div class="line">extern intptr_t                    _dyld_get_image_vmaddr_slide(uint32_t image_index)   __OSX_AVAILABLE_STARTING(__MAC_10_1, __IPHONE_2_0);</div><div class="line">extern const char*                 _dyld_get_image_name(uint32_t image_index)           __OSX_AVAILABLE_STARTING(__MAC_10_1, __IPHONE_2_0);</div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line"> * The following functions allow you to install callbacks which will be called   </div><div class="line"> * by dyld whenever an image is loaded or unloaded.  During a call to _dyld_register_func_for_add_image()</div><div class="line"> * the callback func is called for every existing image.  Later, it is called as each new image</div><div class="line"> * is loaded and bound (but initializers not yet run).  The callback registered with</div><div class="line"> * _dyld_register_func_for_remove_image() is called after any terminators in an image are run</div><div class="line"> * and before the image is un-memory-mapped.</div><div class="line"> */</div><div class="line">extern void _dyld_register_func_for_add_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide))    __OSX_AVAILABLE_STARTING(__MAC_10_1, __IPHONE_2_0);</div><div class="line">extern void _dyld_register_func_for_remove_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)) __OSX_AVAILABLE_STARTING(__MAC_10_1, __IPHONE_2_0);</div></pre></td></tr></table></figure>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><code>frida-core</code> 的模块化封装太好了, 里面很多高端的姿势.</p>
<p>太高端, 简单介绍下.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">What now happens behind the scenes is this:</div><div class="line"></div><div class="line">1. We inject our [launchd.js][] agent into launchd (if not done already).</div><div class="line">2. Call the agent&apos;s RPC-exported [prepareForLaunch()][] giving it the identifier</div><div class="line">  of the app we&apos;re about to launch.</div><div class="line">3. Call [SBSLaunchApplicationWithIdentifierAndLaunchOptions()][] so SpringBoard</div><div class="line">  launches the app.</div><div class="line">4. Our launchd.js agent then intercept launchd&apos;s *__posix_spawn()* and adds</div><div class="line">  [POSIX_SPAWN_START_SUSPENDED][], and [signals back][] the identifier and PID.</div><div class="line">  This is the */usr/libexec/xpcproxy* helper that will perform an exec()-style</div><div class="line">  transition to become the app.</div><div class="line">5. We then inject our [xpcproxy.js][] agent into this so it can hook</div><div class="line">  *__posix_spawn()* and add *POSIX_SPAWN_START_SUSPENDED* just like our launchd</div><div class="line">  agent did. This one will however also have *POSIX_SPAWN_SETEXEC*, so that</div><div class="line">  means it will replace itself with the app to be launched.</div><div class="line">6. We *resume()* the xpcproxy process and [wait for the exec][] to happen and the</div><div class="line">  process to be suspended.</div><div class="line"></div><div class="line">At this point we let the *device.spawn()* return with the PID of the app that</div><div class="line">was just launched. The app&apos;s process has been created, and the main thread is</div><div class="line">suspended at dyld&apos;s entrypoint. frida-trace will then want to attach to it</div><div class="line">so it can load its agent that hooks *open*. So it goes ahead and does something</div><div class="line">similar to this:</div></pre></td></tr></table></figure>
<p>上面简单介绍了流程. 具体在代码中. <code>frida-core/src/darwin/frida-helper-backend-glue.m</code>, 大致流程就是在注入 <code>launchd</code> 利用 hook <code>spawn</code> 和  <code>POSIX_SPAWN_START_SUSPENDED</code>, 在 <code>__dyld_start</code> 时, 在  <code>dyld::initializeMainExecutable()</code> 写入 load frida-agent 的指令, 进而实现优先加载 dylib.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">// frida-core/src/darwin/frida-helper-backend-glue.m</div><div class="line">void</div><div class="line">_frida_darwin_helper_backend_prepare_spawn_instance_for_injection (FridaDarwinHelperBackend * self, void * opaque_instance, guint task, GError ** error)</div><div class="line">&#123;</div><div class="line">  FridaSpawnInstance * instance = opaque_instance;</div><div class="line">  FridaHelperContext * ctx = self-&gt;context;</div><div class="line">  const gchar * failed_operation;</div><div class="line">  kern_return_t ret;</div><div class="line">  mach_port_t self_task, child_thread;</div><div class="line">  guint page_size;</div><div class="line">  thread_act_array_t threads;</div><div class="line">  guint thread_index;</div><div class="line">  mach_msg_type_number_t thread_count = 0;</div><div class="line">  GumDarwinUnifiedThreadState state;</div><div class="line">  mach_msg_type_number_t state_count = GUM_DARWIN_THREAD_STATE_COUNT;</div><div class="line">  thread_state_flavor_t state_flavor = GUM_DARWIN_THREAD_STATE_FLAVOR;</div><div class="line">  GumAddress dyld_start, dyld_granularity, dyld_chunk, dyld_header;</div><div class="line">  GumAddress probe_address, dlerror_clear_address;</div><div class="line">  GumDarwinModule * dyld;</div><div class="line">  FridaExceptionPortSet * previous_ports;</div><div class="line">  dispatch_source_t source;</div><div class="line"></div><div class="line">  /*</div><div class="line">   * We POSIX_SPAWN_START_SUSPENDED which means that the kernel will create</div><div class="line">   * the task and its main thread, with the main thread&apos;s instruction pointer</div><div class="line">   * pointed at __dyld_start. At this point neither dyld nor libc have been</div><div class="line">   * initialized, so we won&apos;t be able to inject frida-agent at this point.</div><div class="line">   *</div><div class="line">   * So here&apos;s what we&apos;ll do before we consider spawn() done:</div><div class="line">   * - Get hold of the main thread to read its instruction pointer, which will</div><div class="line">   *   tell us where dyld is in memory.</div><div class="line">   * - Walk backwards to find dyld&apos;s Mach-O header.</div><div class="line">   * - Walk its symbols and find a function that&apos;s called at a point where the</div><div class="line">   *   process is sufficiently initialized to load frida-agent, but early enough</div><div class="line">   *   so that app&apos;s initializer still didn&apos;t run. In this case we choose</div><div class="line">   *   dyld::initializeMainExecutable(). At the beginning of this function dyld is</div><div class="line">   *   initialized but libSystem is still missing.</div><div class="line">   * - Set a hardware breakpoint at the beginning of this function.</div><div class="line">   * - Swap out the thread&apos;s exception ports with our own.</div><div class="line">   * - Resume the task.</div><div class="line">   * - Wait until we get a message on our exception port, meaning our breakpoint</div><div class="line">   *   was hit.</div><div class="line">   * - Hijack thread&apos;s instruction pointer to call dlopen(&quot;/usr/lib/libSystem.B.dylib&quot;)</div><div class="line">   *   and then return back to the beginning of initializeMainExecutable() and restore</div><div class="line">   *   previous thread state.</div><div class="line">   * - Swap back the thread&apos;s orginal exception ports.</div><div class="line">   * - Clear the hardware breakpoint by restoring the thread&apos;s debug registers.</div><div class="line">   *</div><div class="line">   * It&apos;s actually more complex than that, because:</div><div class="line">   * - This doesn&apos;t work on newer versions of dyld because to call dlopen() it&apos;s</div><div class="line">   *   necessary to registerThreadHelpers() first, which is normally done by libSystem</div><div class="line">   *   itself during its initialization.</div><div class="line">   * - To overcome this catch-22 we alloc a fake LibSystemHelpers object and register</div><div class="line">   *   it (also by hijacking thread&apos;s instruction pointer as described above).</div><div class="line">   * - On older dyld versions, registering helpers before loading libSystem led to</div><div class="line">   *   crashes, so we detect this condition and unset the helpers before calling dlopen(),</div><div class="line">   *   by writing a NULL directly into the global dyld::gLibSystemHelpers because in</div><div class="line">   *   some dyld versions calling registerThreadHelpers(NULL) causes a NULL dereference.</div><div class="line">   * - At the end of dlopen(), we set the global &quot;libSystemInitialized&quot; flag present in</div><div class="line">   *   the global dyld::qProcessInfo structure, because on newer dyld versions that doesn&apos;t</div><div class="line">   *   happen automatically due to the presence of our fake helpers.</div><div class="line">   * - One of the functions provided by the helper should return a buffer for the errors,</div><div class="line">   *   but since our fake helpers object implements its functions only using a return,</div><div class="line">   *   it will not return any buffer. To avoid this to happen, we set a breakpoint also</div><div class="line">   *   on dyld:dlerrorClear function and inject an immediate return,</div><div class="line">   *   effectively disabling the function.</div><div class="line">   * - At the end of dlopen() we finally deallocate our fake helpers (because now they&apos;ve</div><div class="line">   *   been replaced by real libSystem ones) and the string we used as a parameter for dlopen.</div><div class="line">   *</div><div class="line">   * Then later when resume() is called:</div><div class="line">   * - Send a response to the message we got on our exception port, so the</div><div class="line">   *   kernel considers it handled and resumes the main thread for us.</div><div class="line">   */</div></pre></td></tr></table></figure>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-08-09</span><i class="fa fa-tag"></i><a href="/categories/darwin/" title="darwin" class="tag">darwin </a><a href="/tags/darwin/" title="darwin" class="tag">darwin </a><a href="/tags/darwin逆向/" title="darwin逆向" class="tag">darwin逆向 </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://jmpews.github.com/2017/08/09/darwin/反注入及绕过/,jmpews,反注入及绕过,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2017/08/01/pwn/HookZz框架/" title="HookZz框架" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2017/08/09/darwin/反调试及绕过/" title="反调试及绕过" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>