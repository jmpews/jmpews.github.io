<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="jmpews,jmpews@gmail.com"><title>反调试及绕过 · jmpews</title><meta name="description" content="任何带特征的检测都是不安全的 &amp;amp; 隐而不发
AntiDebugBypass on github
代码依赖于 HookZz, MachoParser
HookZz, 是一个 hook 框架, 目前暴露 3 个函数 
123456789101112131415161718192021```## "><meta name="keywords" content="py,go,pwn,reverse"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">jmpews</a></h3><div class="description"><p>py &amp; go &amp; pwn &amp; reverse</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/jmpews"><i class="fa fa-twitter"></i></a></li><li><a href="http://weibo.com/winter1ife"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/jmpews"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>反调试及绕过</a></h3></div><div class="post-content"><p><strong>任何带特征的检测都是不安全的 &amp; 隐而不发</strong></p>
<p><strong><a href="https://github.com/jmpews/HookZzModules/tree/master/AntiDebugBypass" target="_blank" rel="external">AntiDebugBypass on github</a></strong></p>
<p><strong>代码依赖于 <a href="https://github.com/jmpews/HookZz" target="_blank" rel="external">HookZz</a>, <a href="https://github.com/jmpews/MachoParser" target="_blank" rel="external">MachoParser</a></strong></p>
<p>HookZz, 是一个 hook 框架, 目前暴露 3 个函数 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"></div><div class="line">## 前言</div><div class="line"></div><div class="line">对于应用安全甲方一般会在这三个方面做防御. </div><div class="line"></div><div class="line">按逻辑分类的话应该应该分为这三类, 但如果从实现原理的话, 应该分为两类, `用API实现的` 和 `不用API实现的`(这说的不用 API 实现, 不是指换成 inine 函数就行) . 首先使用 API 实现基本统统沦陷. 直接通过指令实现的机制还有一丝存活的可能.</div><div class="line"></div><div class="line">本文所有相关仅仅针对 aarch64.</div><div class="line"></div><div class="line">假设读者对下知识有了解</div><div class="line"></div><div class="line">0. arm64 相关知识</div><div class="line">1. macho 文件结构以及加载相关知识</div><div class="line">2. dyld 链接 dylib 相关函数等知识</div><div class="line"></div><div class="line">如何 hook 不定参数函数? </div><div class="line"></div><div class="line">技巧在于伪造原栈的副本. 具体参考下文.</div><div class="line"></div><div class="line">通常来说必备手册</div></pre></td></tr></table></figure>
<p>// 指令格式等细节<br>ARM Architecture Reference Manual(ARMv8, for ARMv8-A architecture profile)<br><a href="https://static.docs.arm.com/ddi0487/b/DDI0487B_a_armv8_arm.pdf" target="_blank" rel="external">https://static.docs.arm.com/ddi0487/b/DDI0487B_a_armv8_arm.pdf</a></p>
<p>ARM Cortex -A Series Programmer’s Guide for ARMv8-A<br><a href="http://infocenter.arm.com/help/topic/com.arm.doc.den0024a/DEN0024A_v8_architecture_PG.pdf" target="_blank" rel="external">http://infocenter.arm.com/help/topic/com.arm.doc.den0024a/DEN0024A_v8_architecture_PG.pdf</a></p>
<p>Calling conventions for different C++ compilers and operating systems<br><a href="http://www.agner.org/optimize/calling_conventions.pdf" target="_blank" rel="external">http://www.agner.org/optimize/calling_conventions.pdf</a></p>
<p>Procedure Call Standard for the ARM 64-bit Architecture (AArch64)<br><a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf" target="_blank" rel="external">http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">通常来说必备源码</div></pre></td></tr></table></figure></p>
<p>// dyld<br><a href="https://opensource.apple.com/tarballs/dyld/" target="_blank" rel="external">https://opensource.apple.com/tarballs/dyld/</a></p>
<p>// xnu<br><a href="https://opensource.apple.com/tarballs/xnu/" target="_blank" rel="external">https://opensource.apple.com/tarballs/xnu/</a></p>
<p>// objc<br><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">https://opensource.apple.com/tarballs/objc4/</a><br><a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="external">https://github.com/RetVal/objc-runtime</a> (可编译)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 反调试</div><div class="line"></div><div class="line">反调试从逻辑上分大概分为, 一种是直接屏蔽调试器挂载, 另一种就是根据特征手动检测调试器挂载. 当然也分为使用函数实现 和 直接使用内联 asm 实现.</div><div class="line"></div><div class="line">#### ptrace 反调试</div><div class="line"></div><div class="line">ptrace 反调试可以使用四种方法实现.</div><div class="line"></div><div class="line">**1. 直接使用 ptrace 函数**</div></pre></td></tr></table></figure></p>
<p>#if !defined(PT_DENY_ATTACH)</p>
<p>#define PT_DENY_ATTACH 31</p>
<p>#endif<br>typedef int (*PTRACE_T)(int request, pid_t pid, caddr_t addr, int data);</p>
<p>// ——————————————————————</p>
<p>static void AntiDebug_ptrace() {<br>    void *handle = dlopen(NULL, RTLD_GLOBAL | RTLD_NOW);<br>    PTRACE_T ptrace_ptr = dlsym(handle, “ptrace”);<br>    ptrace_ptr(PT_DENY_ATTACH, 0, 0, 0);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**2. 使用 syscall 实现**</div></pre></td></tr></table></figure></p>
<p>#include <sys syscall.h=""></sys></p>
<p>#if !defined(SYS_ptrace)</p>
<p>#define SYS_ptrace 26</p>
<p>#endif<br>void AntiDebug_syscall() { syscall(SYS_ptrace, PT_DENY_ATTACH, 0, 0, 0); }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">**3. 内联 svc + ptrace 实现**</div><div class="line"></div><div class="line">其实这种方法等同于直接使用 ptrace, 此时系统调用号是 `SYS_ptrace`</div></pre></td></tr></table></figure></p>
<p>static <strong>attribute</strong>((always_inline)) void AntiDebug_svc() {</p>
<p>#ifdef <strong>arm64</strong><br>    <strong>asm</strong>(<br>        “mov X0, #31\n”<br>        “mov X1, #0\n”<br>        “mov X2, #0\n”<br>        “mov X3, #0\n”<br>        “mov w16, #26\n”<br>        “svc #0x80”);</p>
<p>#endif<br>    return;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**4. 内联 svc + syscall + ptrace 实现**</div><div class="line"></div><div class="line">其实这种方法等同于使用 `syscall(SYS_ptrace, PT_DENY_ATTACH, 0, 0, 0)`, 这里需要注意, 此时的系统调用号是 0, 也就是 `SYS_syscall`</div></pre></td></tr></table></figure></p>
<p>static <strong>attribute</strong>((always_inline)) void AntiDebug_svc_syscall_syscall() {</p>
<p>#ifdef <strong>arm64</strong><br>    <strong>asm</strong>(<br>        “mov X0, #26\n”<br>        “mov X1, #31\n”<br>        “mov X2, #0\n”<br>        “mov X3, #0\n”<br>        “mov X4, #0\n”<br>        “mov w16, #0\n”<br>        “svc #0x80”);</p>
<p>#endif<br>    return;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">简单整理下系统调用流程, 只能以 `xnu-3789.41.3` 源码举例.</div><div class="line"></div><div class="line">Supervisor Call causes a Supervisor Call exception. svc 切换 `Exception Levels ` 从 `EL0(Unprivileged)` 到 `EL1(Privileged)`</div><div class="line"></div><div class="line">![C06F60DB066D85C69DC318113539A69C.jpg](/images/C06F60DB066D85C69DC318113539A69C.jpg)</div><div class="line"></div><div class="line">上面说的是指令层相关, 再说系统层相关, 使用 svc 进行系统中断调用需要明确 3 个点: 中断号, 系统调用号, 以及参数. 下面以 x86-64 举例.</div><div class="line"></div><div class="line">中断向量表</div></pre></td></tr></table></figure></p>
<p>// xnu-3789.41.3/osfmk/x86_64/idt_table.h<br>USER_TRAP_SPC(0x80,idt64_unix_scall)<br>USER_TRAP_SPC(0x81,idt64_mach_scall)<br>USER_TRAP_SPC(0x82,idt64_mdep_scall)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">中断处理函数</div></pre></td></tr></table></figure></p>
<p>// xnu-3789.41.3/osfmk/x86_64/idt64.s<br>/*</p>
<ul>
<li>System call handlers.</li>
<li>These are entered via a syscall interrupt. The system call number in %rax</li>
<li>is saved to the error code slot in the stack frame. We then branch to the</li>
<li>common state saving code.<br>*/</li>
</ul>
<p>#ifndef UNIX_INT</p>
<p>#error NO UNIX INT!!!</p>
<p>#endif<br>Entry(idt64_unix_scall)<br>    swapgs                /<em> switch to kernel gs (cpu_data) </em>/<br>    pushq    %rax            /<em> save system call number </em>/<br>    PUSH_FUNCTION(HNDL_UNIX_SCALL)<br>    pushq    $(UNIX_INT)<br>    jmp    L_32bit_entry_check<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>// xnu-3789.41.3/bsd/dev/i386/systemcalls.c<br><strong>attribute</strong>((noreturn))<br>void<br>unix_syscall64(x86_saved_state_t <em>state)<br>{<br>    thread_t    thread;<br>    void            </em>vt;<br>    unsigned int    code;<br>    struct sysent    <em>callp;<br>    int        args_in_regs;<br>    boolean_t    args_start_at_rdi;<br>    int        error;<br>    struct proc    </em>p;<br>    struct uthread    <em>uthread;<br>    x86_saved_state64_t </em>regs;<br>    pid_t        pid;</p>
<pre><code>assert(is_saved_state64(state));
regs = saved_state64(state);
</code></pre><p>#if    DEBUG<br>    if (regs-&gt;rax == 0x2000800)<br>        thread_exception_return();</p>
<p>#endif<br>    thread = current_thread();<br>    uthread = get_bsdthread_info(thread);</p>
<p>#if PROC_REF_DEBUG<br>    uthread_reset_proc_refcount(uthread);</p>
<p>#endif</p>
<pre><code>/* Get the approriate proc; may be different from task&apos;s for vfork() */
if (__probable(!(uthread-&gt;uu_flag &amp; UT_VFORK)))
    p = (struct proc *)get_bsdtask_info(current_task());
else 
    p = current_proc();

/* Verify that we are not being called from a task without a proc */
if (__improbable(p == NULL)) {
    regs-&gt;rax = EPERM;
    regs-&gt;isf.rflags |= EFL_CF;
    task_terminate_internal(current_task());
    thread_exception_return();
    /* NOTREACHED */
}

code = regs-&gt;rax &amp; SYSCALL_NUMBER_MASK;
DEBUG_KPRINT_SYSCALL_UNIX(
    &quot;unix_syscall64: code=%d(%s) rip=%llx\n&quot;,
    code, syscallnames[code &gt;= nsysent ? SYS_invalid : code], regs-&gt;isf.rip);
callp = (code &gt;= nsysent) ? &amp;sysent[SYS_invalid] : &amp;sysent[code];
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">系统调用表</div></pre></td></tr></table></figure>
<p>xnu-3789.41.3/bsd/kern/syscall.h</p>
<p>#define    SYS_setuid         23</p>
<p>#define    SYS_getuid         24</p>
<p>#define    SYS_geteuid        25</p>
<p>#define    SYS_ptrace         26</p>
<p>#define    SYS_recvmsg        27</p>
<p>#define    SYS_sendmsg        28<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 反调试检测</div><div class="line"></div><div class="line">这里主要是调试器的检测手段, 很多检测到调试器后使用 `exit(-1)` 退出程序. 这里很容易让 cracker 断点到 `exit` 函数上. 其实有一个 trick 就是利用利用系统异常造成 crash. 比如: 操作无效内存地址. 或者覆盖/重写 `__TEXT` 内容(debugmode 模式下可以对 `rx-` 内存进行操作)</div><div class="line"></div><div class="line">#### 使用 sysctl 检测</div></pre></td></tr></table></figure></p>
<p>#include <sys sysctl.h=""></sys></p>
<p>#include <unistd.h><br>static int DetectDebug_sysctl() <strong>attribute</strong>((always_inline));<br>int DetectDebug_sysctl() {<br>  size_t size = sizeof(struct kinfo_proc);<br>  struct kinfo_proc info;<br>  int ret, name[4];</unistd.h></p>
<p>  memset(&amp;info, 0, sizeof(struct kinfo_proc));</p>
<p>  name[0] = CTL_KERN;<br>  name[1] = KERN_PROC;<br>  name[2] = KERN_PROC_PID;<br>  name[3] = getpid();</p>
<p>  if ((ret = (sysctl(name, 4, &amp;info, &amp;size, NULL, 0)))) {<br>    return ret; // sysctl() failed for some reason<br>  }<br>  return (info.kp_proc.p_flag &amp; P_TRACED) ? 1 : 0;<br>}</p>
<p>void AntiDebug_sysctl() {<br>  if (DetectDebug_sysctl()) {<br>    exit(1);<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 使用 isatty 检测</div></pre></td></tr></table></figure></p>
<p>#include <unistd.h><br>void AntiDebug_isatty() {<br>  if (isatty(1)) {<br>    exit(1);<br>  } else {<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 使用 ioctl 检测</div></pre></td></tr></table></figure></unistd.h></p>
<p>#include <sys ioctl.h=""><br>void AntiDebug_ioctl() {<br>  if (!ioctl(1, TIOCGWINSZ)) {<br>    exit(1);<br>  } else {<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 绕过</div><div class="line"></div><div class="line">对于使用函数进行反调试可以使用 hook 轻松绕过, 具体的实现, 直接看代码.</div><div class="line"></div><div class="line">#### syscall 反调试绕过</div><div class="line"></div><div class="line">因为 `syscall` 反调试有些特殊, 这里需要介绍下如何绕过 `syscall` 反调试, 使用的是 `va_list` 进行传递参数. `http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf` 参考阅读 `va_list` 相关.</div><div class="line"></div><div class="line">借助 [HookZz](https://github.com/jmpews/HookZz) 有两种方法可以进行绕过</div><div class="line"></div><div class="line">**1. 使用 `replace_call` 绕过**</div><div class="line"></div><div class="line">这里的 `syscall` 使用的是 `va_list` 传递参数. 所以这里问题在于如何 hook 不定参数函数. 因为在 hook 之后不确定原函数的参数个数. 所以没有办法调用原函数.</div><div class="line"></div><div class="line">所以这里有一个 trick, 在 `orig_syscall(number, stack[0], stack[1], stack[2], stack[3], stack[4], stack[5], stack[6], stack[7]);` 时伪造了一个栈, 这个栈的内容和原栈相同(应该是大于等于原栈的参数内容). 虽然传递了很多参数, 如果理解 `function call` 的原理的话, 即使传递了很多参数, 但是只要栈的内容不变, 准确的说的是从低地址到高地址的栈里的内容不变(这里可能多压了很多无用的内容到栈里), 函数调用就不会变.</div><div class="line"></div><div class="line">这里不要使用 `large structure`, gcc 会使用 `memcopy` 最终传入的其实是地址. 大部分注释请参考下文.</div><div class="line"></div><div class="line">![WX20170810-003735@2x.png](/images/WX20170810-003735@2x.png)</div></pre></td></tr></table></figure></sys></p>
<p>// ptrace(int request, pid_t pid, caddr_t addr, int data);<br>int (*orig_syscall)(int number, …);<br>int fake_syscall(int number, …) {<br>  int request;<br>  pid_t pid;<br>  caddr_t addr;<br>  int data;</p>
<p>  // fake stack, why use <code>char *</code> ? hah<br>  char *stack[8];</p>
<p>  va_list args;<br>  va_start(args, number);</p>
<p>  // get the origin stack args copy.(must &gt;= origin stack args)<br>  memcpy(stack, args, 8 * 8);</p>
<p>  if (number == SYS_ptrace) {<br>    request = va_arg(args, int);<br>    pid = va_arg(args, pid_t);<br>    addr = va_arg(args, caddr_t);<br>    data = va_arg(args, int);<br>    va_end(args);<br>    if (request == PT_DENY_ATTACH) {<br>      NSLog(@”[AntiDebugBypass] catch ‘syscall(SYS_ptrace, PT_DENY_ATTACH, 0, “<br>            @”0, 0)’ and bypass.”);<br>      return 0;<br>    }<br>  } else {<br>    va_end(args);<br>  }</p>
<p>  // must understand the principle of <code>function call</code>. <code>parameter pass</code> is before <code>switch to target</code><br>  // so, pass the whole <code>stack</code>, it just actually faked an original stack.<br>  // Not pass a large structure,  will be replace with a <code>hidden memcpy</code>.<br>  int x = orig_syscall(number, stack[0], stack[1], stack[2], stack[3], stack[4], stack[5], stack[6], stack[7]);<br>  return x;<br>}</p>
<p><strong>attribute</strong>((constructor)) void patch_ptrace_sysctl_syscall() {</p>
<p>  …</p>
<p>  zpointer syscall_ptr = (void <em>)syscall;<br>  ZZBuildHook((void </em>)syscall_ptr, (void <em>)fake_syscall, (void<br>  **)&amp;orig_syscall,<br>              NULL, NULL);<br>  ZZEnableHook((void </em>)syscall_ptr);<br>}<br>// — end –<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**2. 使用 `pre_call` 绕过**</div><div class="line"></div><div class="line">这种方法需要查看 `syscall` 的汇编实现, 来确定 `PT_DENY_ATTACH` 放在哪一个寄存器.</div></pre></td></tr></table></figure></p>
<p>libsystem_kernel.dylib`__syscall:<br>    0x1815c0900 &lt;+0&gt;:  ldp    x1, x2, [sp]<br>    0x1815c0904 &lt;+4&gt;:  ldp    x3, x4, [sp, #0x10]<br>    0x1815c0908 &lt;+8&gt;:  ldp    x5, x6, [sp, #0x20]<br>    0x1815c090c &lt;+12&gt;: ldr    x7, [sp, #0x30]<br>    0x1815c0910 &lt;+16&gt;: mov    x16, #0x0<br>    0x1815c0914 &lt;+20&gt;: svc    #0x80<br>    0x1815c0918 &lt;+24&gt;: b.lo   0x1815c0930               ; &lt;+48&gt;<br>    0x1815c091c &lt;+28&gt;: stp    x29, x30, [sp, #-0x10]!<br>    0x1815c0920 &lt;+32&gt;: mov    x29, sp<br>    0x1815c0924 &lt;+36&gt;: bl     0x1815a6dc0               ; cerror<br>    0x1815c0928 &lt;+40&gt;: mov    sp, x29<br>    0x1815c092c &lt;+44&gt;: ldp    x29, x30, [sp], #0x10<br>    0x1815c0930 &lt;+48&gt;: ret<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">可以看到调用如果 `x0` 是 `SYS_ptrace`, 那么 `PT_DENY_ATTACH` 存放在 `[sp]`.</div></pre></td></tr></table></figure></p>
<p>// — syscall bypass use <code>pre_call</code><br>void syscall_pre<em>call(struct RegState</em> <em>rs) {<br>  int num_syscall;<br>  int request;<br>  zpointer sp;<br>  num_syscall = (int)(uint64_t)(rs-&gt;general.regs.x0);<br>  if (num_syscall == SYS_ptrace) {<br>    sp = (zpointer)(rs-&gt;sp);<br>    request = </em>(int <em>)sp;<br>    if (request == PT_DENY_ATTACH) {
      </em>(long <em>)sp = 10;<br>      NSLog(@”[AntiDebugBypass] catch ‘syscall(SYS_ptrace, PT_DENY_ATTACH, 0, “<br>            @”0, 0)’ and bypass.”);<br>    }<br>  }<br>}<br><strong>attribute</strong>((constructor)) void patch_syscall_by_pre_call() {<br>  zpointer syscall_ptr = (void </em>)syscall;<br>  ZZBuildHook((void <em>)syscall_ptr, NULL, NULL, (void </em>)syscall_pre_call, NULL);<br>  ZZEnableHook((void *)syscall_ptr);<br>}</p>
<p>// — end —<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### `svc #0x80` 反调试绕过</div><div class="line"></div><div class="line">这里介绍关键是介绍如何对 svc 反调试的绕过.</div><div class="line"></div><div class="line">上面已经对 svc 进行了简单的介绍. 所以理所当然想到的是希望通过 `syscall hook`, 劫持 `system call table(sysent)` . 这里相当于实现 `syscall hook`. 但是难点之一是需要找到 `system call table(sysent)`, 这一步可以通过 [joker](http://newosxbook.com/tools/joker.html), 对于 IOS 10.x 可以参考 `http://ioshackerwiki.com/syscalls/`, 难点之二是作为 kext 加载. 可以参考 **附录**, 对于具体的 `kernel patch` 没有做过深入研究, 应该可以参考 [comex 的 datautils0](https://github.com/comex/datautils0)</div><div class="line"></div><div class="line">ok, 接下来使用另一种思路对绕过, 其实也就是 `code patch` + `inlinehook`. 对 `__TEXT` 扫描 `svc #0x80` 指令, 对于 cracker 来说, 在 `__TEXT` 段使用 `svc #0x80` 具有一定的反调试可能, 所以需要对 `svc #0x80` 进行 `inlinehook`, 这里并不直接对 `svc #0x80` 进行覆盖操作, 可能有正常系统调用.</div><div class="line"></div><div class="line">以下代码依赖于 [HookZz](https://github.com/jmpews/HookZz), [MachoParser](https://github.com/jmpews/MachoParser)</div><div class="line"></div><div class="line">大致原理就是先搜索到 `svc #0x80` 指令后, 对该指令地址进行 hook, 之后使用 `pre_call` 修改寄存器的值.</div></pre></td></tr></table></figure></p>
<p>// — svc #0x80 bypass —</p>
<p>#include “MachoMem.h”<br>void patch_svc_pre<em>call(struct RegState</em> *rs) {<br>  int num_syscall;<br>  int request;<br>  num_syscall = (int)(uint64_t)(rs-&gt;general.regs.x16);<br>  request = (int)(uint64_t)(rs-&gt;general.regs.x0);</p>
<p>  if (num_syscall == SYS_syscall) {<br>    int arg1 = (int)(uint64_t)(rs-&gt;general.regs.x1);<br>    if (request == SYS_ptrace &amp;&amp; arg1 == PT_DENY_ATTACH) {<br>      <em>(unsigned long </em>)(&amp;rs-&gt;general.regs.x1) = 10;<br>      NSLog(@”[AntiDebugBypass] catch ‘SVC #0x80; syscall(ptrace)’ and bypass”);<br>    }<br>  } else if (num_syscall == SYS_ptrace) {<br>    request = (int)(uint64_t)(rs-&gt;general.regs.x0);<br>    if (request == PT_DENY_ATTACH) {<br>      <em>(unsigned long </em>)(&amp;rs-&gt;general.regs.x1) = 10;<br>      NSLog(@”[AntiDebugBypass] catch ‘SVC-0x80; ptrace’ and bypass”);<br>    }<br>  }<br>}<br><strong>attribute</strong>((constructor)) void patch_svc_x80() {<br>  const section_64_info_t <em>sect64;<br>  zaddr svc_x80_addr;<br>  zaddr curr_addr, end_addr;<br>  uint32_t svc_x80_byte = 0xd4001001;<br>  MachoMem </em>mem = new MachoMem();<br>  mem-&gt;parse_macho();<br>  // mem-&gt;parse_dyld();<br>  sect64 = mem-&gt;get_sect_by_name(“__text”);<br>  curr_addr = sect64-&gt;sect_addr;<br>  end_addr = curr_addr + sect64-&gt;sect_64-&gt;size;</p>
<p>  ZZInitialize();<br>  while (curr_addr &lt; end_addr) {<br>    svc_x80_addr = mem-&gt;macho_search_data(<br>        sect64-&gt;sect_addr, sect64-&gt;sect_addr + sect64-&gt;sect_64-&gt;size,<br>        (const zbyte <em>)&amp;svc_x80_byte, 4);<br>    if (svc_x80_addr) {<br>      NSLog(@”find svc #0x80 at %p with aslr (%p without aslr)”,<br>            (void </em>)svc_x80_addr, (void <em>)(svc_x80_addr - mem-&gt;m_aslr_slide));<br>      ZZBuildHook((void </em>)svc_x80_addr, NULL, NULL,<br>                  (zpointer)patch_svc_pre_call, NULL);<br>      ZZEnableHook((void *)svc_x80_addr);<br>      curr_addr = svc_x80_addr + 4;<br>    } else {<br>      break;<br>    }<br>  }<br>}<br>// — end —<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 总结</div><div class="line"></div><div class="line">上文对很多的反调试原理做了总结, 也有一些没有讲到原理. 读者可以自行研究.</div><div class="line"></div><div class="line">## 附录</div></pre></td></tr></table></figure></p>
<p>// syscall hook<br><a href="http://siliconblade.blogspot.jp/2013/07/offensive-volatility-messing-with-os-x.html" target="_blank" rel="external">http://siliconblade.blogspot.jp/2013/07/offensive-volatility-messing-with-os-x.html</a><br><a href="https://www.defcon.org/images/defcon-17/dc-17-presentations/defcon-17-bosse_eriksson-kernel_patching_on_osx.pdf" target="_blank" rel="external">https://www.defcon.org/images/defcon-17/dc-17-presentations/defcon-17-bosse_eriksson-kernel_patching_on_osx.pdf</a><br><a href="http://d.hatena.ne.jp/hon53/20100926/1285476759" target="_blank" rel="external">http://d.hatena.ne.jp/hon53/20100926/1285476759</a><br><a href="https://papers.put.as/papers/ios/2011/SysScan-Singapore-Targeting_The_IOS_Kernel.pdf" target="_blank" rel="external">https://papers.put.as/papers/ios/2011/SysScan-Singapore-Targeting_The_IOS_Kernel.pdf</a><br><a href="https://www.blackhat.com/docs/us-15/materials/us-15-Diquet-TrustKit-Code-Injection-On-iOS-8-For-The-Greater-Good.pdf" target="_blank" rel="external">https://www.blackhat.com/docs/us-15/materials/us-15-Diquet-TrustKit-Code-Injection-On-iOS-8-For-The-Greater-Good.pdf</a><br>```</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-08-09</span><i class="fa fa-tag"></i><a href="/categories/darwin/" title="darwin" class="tag">darwin </a><a href="/tags/darwin/" title="darwin" class="tag">darwin </a><a href="/tags/darwin逆向/" title="darwin逆向" class="tag">darwin逆向 </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://jmpews.github.com/2017/08/09/darwin/反调试及绕过/,jmpews,反调试及绕过,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2017/08/09/darwin/反注入及绕过/" title="反注入及绕过" class="btn">上一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>