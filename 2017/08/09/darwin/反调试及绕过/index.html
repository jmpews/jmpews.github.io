<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="jmpews,jmpews@gmail.com"><title>反调试及绕过 · jmpews</title><meta name="description" content="任何带特征的检测都是不安全的 &amp;amp; 隐而不发
Move to AntiDebugBypass on github
代码依赖于 HookZz
HookZz, 是一个 hook 框架.
前言对于应用安全甲方一般会在这三个方面做防御. 
按逻辑分类的话应该应该分为这三类, 但如果从实现原理的话, 应"><meta name="keywords" content="py,go,pwn,reverse"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">jmpews</a></h3><div class="description"><p>py &amp; go &amp; pwn &amp; reverse</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/jmpews"><i class="fa fa-twitter"></i></a></li><li><a href="http://weibo.com/winter1ife"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/jmpews"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>反调试及绕过</a></h3></div><div class="post-content"><p><strong>任何带特征的检测都是不安全的 &amp; 隐而不发</strong></p>
<p><strong><a href="https://github.com/jmpews/HookZzModules/tree/master/AntiDebugBypass" target="_blank" rel="external">Move to AntiDebugBypass on github</a></strong></p>
<p><strong>代码依赖于 <a href="https://github.com/jmpews/HookZz" target="_blank" rel="external">HookZz</a></strong></p>
<p>HookZz, 是一个 hook 框架.</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于应用安全甲方一般会在这三个方面做防御. </p>
<p>按逻辑分类的话应该应该分为这三类, 但如果从实现原理的话, 应该分为两类, <code>用API实现的</code> 和 <code>不用API实现的</code>(这说的不用 API 实现, 不是指换成 inine 函数就行) . 首先使用 API 实现基本统统沦陷. 直接通过指令实现的机制还有一丝存活的可能.</p>
<p>本文所有相关仅仅针对 aarch64.</p>
<p>假设读者对下知识有了解</p>
<ol>
<li>arm64 相关知识</li>
<li>macho 文件结构以及加载相关知识</li>
<li>dyld 链接 dylib 相关函数等知识</li>
</ol>
<p>如何 hook 不定参数函数? </p>
<p>技巧在于伪造原栈的副本. 具体参考下文.</p>
<p>通常来说必备手册</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 指令格式等细节</div><div class="line">ARM Architecture Reference Manual(ARMv8, for ARMv8-A architecture profile)</div><div class="line">https://static.docs.arm.com/ddi0487/b/DDI0487B_a_armv8_arm.pdf</div><div class="line"></div><div class="line">ARM Cortex -A Series Programmer’s Guide for ARMv8-A</div><div class="line">http://infocenter.arm.com/help/topic/com.arm.doc.den0024a/DEN0024A_v8_architecture_PG.pdf</div><div class="line"></div><div class="line">Calling conventions for different C++ compilers and operating systems</div><div class="line">http://www.agner.org/optimize/calling_conventions.pdf</div><div class="line"></div><div class="line">Procedure Call Standard for the ARM 64-bit Architecture (AArch64)</div><div class="line">http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf</div></pre></td></tr></table></figure>
<p>通常来说必备源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// dyld</div><div class="line">https://opensource.apple.com/tarballs/dyld/</div><div class="line"></div><div class="line">// xnu</div><div class="line">https://opensource.apple.com/tarballs/xnu/</div><div class="line"></div><div class="line">// objc</div><div class="line">https://opensource.apple.com/tarballs/objc4/</div><div class="line">https://github.com/RetVal/objc-runtime (可编译)</div></pre></td></tr></table></figure>
<h2 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h2><p>反调试从逻辑上分大概分为, 一种是直接屏蔽调试器挂载, 另一种就是根据特征手动检测调试器挂载. 当然也分为使用函数实现 和 直接使用内联 asm 实现.</p>
<h4 id="ptrace-反调试"><a href="#ptrace-反调试" class="headerlink" title="ptrace 反调试"></a>ptrace 反调试</h4><p>ptrace 反调试可以使用四种方法实现.</p>
<p><strong>1. 直接使用 ptrace 函数</strong></p>
<p>这里使用的是 <code>dlopen</code> + <code>dysym</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef int (*PTRACE_T)(int request, pid_t pid, caddr_t addr, int data);</div><div class="line">static void AntiDebug_001() &#123;</div><div class="line">    void *handle = dlopen(NULL, RTLD_GLOBAL | RTLD_NOW);</div><div class="line">    PTRACE_T ptrace_ptr = dlsym(handle, &quot;ptrace&quot;);</div><div class="line">    ptrace_ptr(PT_DENY_ATTACH, 0, 0, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然也可以基于 runtime 符号查找.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// runtime to get symbol address, but must link with `</div><div class="line">// -Wl,-undefined,dynamic_lookup` or you can use `dlopen` and `dlsym`</div><div class="line">extern int ptrace(int request, pid_t pid, caddr_t addr, int data);</div><div class="line">static void AntiDebug_002() &#123; ptrace(PT_DENY_ATTACH, 0, 0, 0); &#125;</div></pre></td></tr></table></figure>
<p><strong>2. 使用 syscall 实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void AntiDebug_005() &#123; syscall(SYS_ptrace, PT_DENY_ATTACH, 0, 0, 0); &#125;</div></pre></td></tr></table></figure>
<p><strong>3. 内联 svc + ptrace 实现</strong></p>
<p>其实这种方法等同于直接使用 ptrace, 此时系统调用号是 <code>SYS_ptrace</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">static __attribute__((always_inline)) void AntiDebug_003() &#123;</div><div class="line">#ifdef __arm64__</div><div class="line">    __asm__(&quot;mov X0, #31\n&quot;</div><div class="line">            &quot;mov X1, #0\n&quot;</div><div class="line">            &quot;mov X2, #0\n&quot;</div><div class="line">            &quot;mov X3, #0\n&quot;</div><div class="line">            &quot;mov w16, #26\n&quot;</div><div class="line">            &quot;svc #0x80&quot;);</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>4. 内联 svc + syscall + ptrace 实现</strong></p>
<p>其实这种方法等同于使用 <code>syscall(SYS_ptrace, PT_DENY_ATTACH, 0, 0, 0)</code>, 这里需要注意, 此时的系统调用号是 0, 也就是 <code>SYS_syscall</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static __attribute__((always_inline)) void AntiDebug_004() &#123;</div><div class="line">#ifdef __arm64__</div><div class="line">    __asm__(&quot;mov X0, #26\n&quot;</div><div class="line">            &quot;mov X1, #31\n&quot;</div><div class="line">            &quot;mov X2, #0\n&quot;</div><div class="line">            &quot;mov X3, #0\n&quot;</div><div class="line">            &quot;mov X4, #0\n&quot;</div><div class="line">            &quot;mov w16, #0\n&quot;</div><div class="line">            &quot;svc #0x80&quot;);</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单整理下系统调用流程, 只能以 <code>xnu-3789.41.3</code> 源码举例.</p>
<p>Supervisor Call causes a Supervisor Call exception. svc 切换 <code>Exception Levels</code> 从 <code>EL0(Unprivileged)</code> 到 <code>EL1(Privileged)</code></p>
<p><img src="/images/C06F60DB066D85C69DC318113539A69C.jpg" alt="C06F60DB066D85C69DC318113539A69C.jpg"></p>
<p>上面说的是指令层相关, 再说系统层相关, 使用 svc 进行系统中断调用需要明确 3 个点: 中断号, 系统调用号, 以及参数. 下面以 x86-64 举例.</p>
<p>中断向量表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// xnu-3789.41.3/osfmk/x86_64/idt_table.h</div><div class="line">USER_TRAP_SPC(0x80,idt64_unix_scall)</div><div class="line">USER_TRAP_SPC(0x81,idt64_mach_scall)</div><div class="line">USER_TRAP_SPC(0x82,idt64_mdep_scall)</div></pre></td></tr></table></figure>
<p>中断处理函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// xnu-3789.41.3/osfmk/x86_64/idt64.s</div><div class="line">/*</div><div class="line"> * System call handlers.</div><div class="line"> * These are entered via a syscall interrupt. The system call number in %rax</div><div class="line"> * is saved to the error code slot in the stack frame. We then branch to the</div><div class="line"> * common state saving code.</div><div class="line"> */</div><div class="line">		</div><div class="line">#ifndef UNIX_INT</div><div class="line">#error NO UNIX INT!!!</div><div class="line">#endif</div><div class="line">Entry(idt64_unix_scall)</div><div class="line">	swapgs				/* switch to kernel gs (cpu_data) */</div><div class="line">	pushq	%rax			/* save system call number */</div><div class="line">	PUSH_FUNCTION(HNDL_UNIX_SCALL)</div><div class="line">	pushq	$(UNIX_INT)</div><div class="line">	jmp	L_32bit_entry_check</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">// xnu-3789.41.3/bsd/dev/i386/systemcalls.c</div><div class="line">__attribute__((noreturn))</div><div class="line">void</div><div class="line">unix_syscall64(x86_saved_state_t *state)</div><div class="line">&#123;</div><div class="line">	thread_t	thread;</div><div class="line">	void			*vt;</div><div class="line">	unsigned int	code;</div><div class="line">	struct sysent	*callp;</div><div class="line">	int		args_in_regs;</div><div class="line">	boolean_t	args_start_at_rdi;</div><div class="line">	int		error;</div><div class="line">	struct proc	*p;</div><div class="line">	struct uthread	*uthread;</div><div class="line">	x86_saved_state64_t *regs;</div><div class="line">	pid_t		pid;</div><div class="line"></div><div class="line">	assert(is_saved_state64(state));</div><div class="line">	regs = saved_state64(state);</div><div class="line">#if	DEBUG</div><div class="line">	if (regs-&gt;rax == 0x2000800)</div><div class="line">		thread_exception_return();</div><div class="line">#endif</div><div class="line">	thread = current_thread();</div><div class="line">	uthread = get_bsdthread_info(thread);</div><div class="line"></div><div class="line">#if PROC_REF_DEBUG</div><div class="line">	uthread_reset_proc_refcount(uthread);</div><div class="line">#endif</div><div class="line"></div><div class="line">	/* Get the approriate proc; may be different from task&apos;s for vfork() */</div><div class="line">	if (__probable(!(uthread-&gt;uu_flag &amp; UT_VFORK)))</div><div class="line">		p = (struct proc *)get_bsdtask_info(current_task());</div><div class="line">	else </div><div class="line">		p = current_proc();</div><div class="line"></div><div class="line">	/* Verify that we are not being called from a task without a proc */</div><div class="line">	if (__improbable(p == NULL)) &#123;</div><div class="line">		regs-&gt;rax = EPERM;</div><div class="line">		regs-&gt;isf.rflags |= EFL_CF;</div><div class="line">		task_terminate_internal(current_task());</div><div class="line">		thread_exception_return();</div><div class="line">		/* NOTREACHED */</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	code = regs-&gt;rax &amp; SYSCALL_NUMBER_MASK;</div><div class="line">	DEBUG_KPRINT_SYSCALL_UNIX(</div><div class="line">		&quot;unix_syscall64: code=%d(%s) rip=%llx\n&quot;,</div><div class="line">		code, syscallnames[code &gt;= nsysent ? SYS_invalid : code], regs-&gt;isf.rip);</div><div class="line">	callp = (code &gt;= nsysent) ? &amp;sysent[SYS_invalid] : &amp;sysent[code];</div></pre></td></tr></table></figure>
<p>系统调用表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">xnu-3789.41.3/bsd/kern/syscall.h</div><div class="line">#define	SYS_setuid         23</div><div class="line">#define	SYS_getuid         24</div><div class="line">#define	SYS_geteuid        25</div><div class="line">#define	SYS_ptrace         26</div><div class="line">#define	SYS_recvmsg        27</div><div class="line">#define	SYS_sendmsg        28</div></pre></td></tr></table></figure>
<h2 id="反调试检测"><a href="#反调试检测" class="headerlink" title="反调试检测"></a>反调试检测</h2><p>这里主要是调试器的检测手段, 很多检测到调试器后使用 <code>exit(-1)</code> 退出程序. 这里很容易让 cracker 断点到 <code>exit</code> 函数上. 其实有一个 trick 就是利用利用系统异常造成 crash. 比如: 覆盖/重写 <code>__TEXT</code> 内容(debugmode 模式下可以对 <code>rx-</code> 内存进行操作).</p>
<p>或者利用内联汇编实现退出, 并清除堆栈(防止暴力 <code>svc patch with nop</code>).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static __attribute__((always_inline)) void asm_exit() &#123;</div><div class="line">#ifdef __arm64__</div><div class="line">    __asm__(&quot;mov X0, #0\n&quot;</div><div class="line">            &quot;mov w16, #1\n&quot;</div><div class="line">            &quot;svc #0x80\n&quot;</div><div class="line"></div><div class="line">            &quot;mov x1, #0\n&quot;</div><div class="line">            &quot;mov sp, x1\n&quot;</div><div class="line">            &quot;mov x29, x1\n&quot;</div><div class="line">            &quot;mov x30, x1\n&quot;</div><div class="line">            &quot;ret&quot;);</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="1-使用-sysctl-检测"><a href="#1-使用-sysctl-检测" class="headerlink" title="1. 使用 sysctl 检测"></a>1. 使用 sysctl 检测</h4><p>这里在检测时也可以通过 svc 实现.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">static int DetectDebug_sysctl() __attribute__((always_inline));</div><div class="line">int DetectDebug_sysctl() &#123;</div><div class="line">    size_t size = sizeof(struct kinfo_proc);</div><div class="line">    struct kinfo_proc info;</div><div class="line">    int ret, name[4];</div><div class="line">    </div><div class="line">    memset(&amp;info, 0, sizeof(struct kinfo_proc));</div><div class="line">    </div><div class="line">    name[0] = CTL_KERN;</div><div class="line">    name[1] = KERN_PROC;</div><div class="line">    name[2] = KERN_PROC_PID;</div><div class="line">    name[3] = getpid();</div><div class="line">    </div><div class="line">#if 0</div><div class="line">    if ((ret = (sysctl(name, 4, &amp;info, &amp;size, NULL, 0)))) &#123;</div><div class="line">        return ret; // sysctl() failed for some reason</div><div class="line">    &#125;</div><div class="line">#else</div><div class="line">    // or change as `AntiDebug_003` and `AntiDebug_004`</div><div class="line">    // https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html</div><div class="line">    __asm__ volatile(&quot;mov x0, %[name_ptr]\n&quot;</div><div class="line">                     &quot;mov x1, #4\n&quot;</div><div class="line">                     &quot;mov x2, %[info_ptr]\n&quot;</div><div class="line">                     &quot;mov x3, %[size_ptr]\n&quot;</div><div class="line">                     &quot;mov x4, #0\n&quot;</div><div class="line">                     &quot;mov x5, #0\n&quot;</div><div class="line">                     &quot;mov w16, #202\n&quot;</div><div class="line">                     &quot;svc #0x80&quot;</div><div class="line">                     :</div><div class="line">                     : [name_ptr] &quot;r&quot;(name), [info_ptr] &quot;r&quot;(&amp;info),</div><div class="line">                     [size_ptr] &quot;r&quot;(&amp;size));</div><div class="line">#endif</div><div class="line">    </div><div class="line">    return (info.kp_proc.p_flag &amp; P_TRACED) ? 1 : 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void AntiDebug_006() &#123;</div><div class="line">    if (DetectDebug_sysctl()) &#123;</div><div class="line">        asm_exit();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-使用-isatty-检测"><a href="#2-使用-isatty-检测" class="headerlink" title="2. 使用 isatty 检测"></a>2. 使用 isatty 检测</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line">void AntiDebug_isatty() &#123;</div><div class="line">  if (isatty(1)) &#123;</div><div class="line">    exit(1);</div><div class="line">  &#125; else &#123;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-使用-ioctl-检测"><a href="#3-使用-ioctl-检测" class="headerlink" title="3. 使用 ioctl 检测"></a>3. 使用 ioctl 检测</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/ioctl.h&gt;</div><div class="line">void AntiDebug_ioctl() &#123;</div><div class="line">  if (!ioctl(1, TIOCGWINSZ)) &#123;</div><div class="line">    exit(1);</div><div class="line">  &#125; else &#123;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="svc-完整性检测"><a href="#svc-完整性检测" class="headerlink" title="svc 完整性检测"></a>svc 完整性检测</h2><p>上述的 svc 反调试手段, 可以通过 patch <code>svc #0x80</code> with <code>nop</code> 轻松绕过. 所以需要校验 <code>svc #0x80</code> 是否被 patch, 一个想当然的方法是在正常的代码中使用 svc 进行 coding, 仔细想想并不合适.</p>
<p>所以另一个想法就是, 使用 svc 实现一个小功能, 之后检测 <code>x0</code> 返回值. 这里使用的是 <code>getpid()</code>.</p>
<p>tips: <code>longjmp</code> 本来是用在异常时恢复状态, 这里由于未保存状态. 所以可以让攻击者不能对退出进行断点. </p>
<p>这里使用, 下面一小段内联汇编可以达到相同的目的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&quot;mov x1, #0\n&quot;</div><div class="line">&quot;mov sp, x1\n&quot;</div><div class="line">&quot;mov x29, x1\n&quot;</div><div class="line">&quot;mov x30, x1\n&quot;</div><div class="line">&quot;ret\n&quot;</div></pre></td></tr></table></figure>
<p>整体的 svc 完整检测原型如下, 仅做抛砖引玉.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">static __attribute__((always_inline)) void check_svc_integrity() &#123;</div><div class="line">    int pid;</div><div class="line">    static jmp_buf protectionJMP;</div><div class="line">#ifdef __arm64__</div><div class="line">    __asm__(&quot;mov x0, #0\n&quot;</div><div class="line">            &quot;mov w16, #20\n&quot;</div><div class="line">            &quot;svc #0x80\n&quot;</div><div class="line">            &quot;cmp x0, #0\n&quot;</div><div class="line">            &quot;b.ne #24\n&quot;</div><div class="line">            </div><div class="line">            &quot;mov x1, #0\n&quot;</div><div class="line">            &quot;mov sp, x1\n&quot;</div><div class="line">            &quot;mov x29, x1\n&quot;</div><div class="line">            &quot;mov x30, x1\n&quot;</div><div class="line">            &quot;ret\n&quot;</div><div class="line">            </div><div class="line">            &quot;mov %[result], x0\n&quot;</div><div class="line">            : [result] &quot;=r&quot; (pid)</div><div class="line">            :</div><div class="line">            :</div><div class="line">            );</div><div class="line">    </div><div class="line">    if(pid == 0) &#123;</div><div class="line">        longjmp(protectionJMP, 1);</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><p>对于使用函数进行反调试可以使用 hook 轻松绕过, 具体的实现, 直接看代码.</p>
<h4 id="syscall-反调试绕过"><a href="#syscall-反调试绕过" class="headerlink" title="syscall 反调试绕过"></a>syscall 反调试绕过</h4><p>因为 <code>syscall</code> 反调试有些特殊, 这里需要介绍下如何绕过 <code>syscall</code> 反调试, 使用的是 <code>va_list</code> 进行传递参数. <code>http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf</code> 参考阅读 <code>va_list</code> 相关.</p>
<p>借助 <a href="https://github.com/jmpews/HookZz" target="_blank" rel="external">HookZz</a> 有两种方法可以进行绕过</p>
<p><strong>1. 使用 <code>replace_call</code> 绕过</strong></p>
<p>这里的 <code>syscall</code> 使用的是 <code>va_list</code> 传递参数. 所以这里问题在于如何 hook 不定参数函数. 因为在 hook 之后不确定原函数的参数个数. 所以没有办法调用原函数.</p>
<p>所以这里有一个 trick, 在 <code>orig_syscall(number, stack[0], stack[1], stack[2], stack[3], stack[4], stack[5], stack[6], stack[7]);</code> 时伪造了一个栈, 这个栈的内容和原栈相同(应该是大于等于原栈的参数内容). 虽然传递了很多参数, 如果理解 <code>function call</code> 的原理的话, 即使传递了很多参数, 但是只要栈的内容不变, 准确的说的是从低地址到高地址的栈里的内容不变(这里可能多压了很多无用的内容到栈里), 函数调用就不会变.</p>
<p>这里不要使用 <code>large structure</code>, 编译时会使用隐含的 <code>memcpy</code> 最终传入的其实是地址. 大部分注释请参考下文.</p>
<p><img src="/images/WX20170810-003735@2x.png" alt="WX20170810-003735@2x.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">int (*orig_syscall)(int number, ...);</div><div class="line">int fake_syscall(int number, ...) &#123;</div><div class="line">    int request;</div><div class="line">    pid_t pid;</div><div class="line">    caddr_t addr;</div><div class="line">    int data;</div><div class="line">    </div><div class="line">    // fake stack, why use `char *` ? hah</div><div class="line">    char *stack[8];</div><div class="line">    </div><div class="line">    va_list args;</div><div class="line">    va_start(args, number);</div><div class="line">    </div><div class="line">    // get the origin stack args copy.(must &gt;= origin stack args)</div><div class="line">    memcpy(stack, args, 8 * 8);</div><div class="line">    </div><div class="line">    if (number == SYS_ptrace) &#123;</div><div class="line">        request = va_arg(args, int);</div><div class="line">        pid = va_arg(args, pid_t);</div><div class="line">        addr = va_arg(args, caddr_t);</div><div class="line">        data = va_arg(args, int);</div><div class="line">        va_end(args);</div><div class="line">        if (request == PT_DENY_ATTACH) &#123;</div><div class="line">            NSLog(@&quot;[AntiDebugBypass] catch &apos;syscall(SYS_ptrace, PT_DENY_ATTACH, 0, &quot;</div><div class="line">                  @&quot;0, 0)&apos; and bypass.&quot;);</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        va_end(args);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // must understand the principle of `function call`. `parameter pass` is</div><div class="line">    // before `switch to target` so, pass the whole `stack`, it just actually</div><div class="line">    // faked an original stack. Do not pass a large structure,  will be replace with</div><div class="line">    // a `hidden memcpy`.</div><div class="line">    int x = orig_syscall(number, stack[0], stack[1], stack[2], stack[3], stack[4],</div><div class="line">                         stack[5], stack[6], stack[7]);</div><div class="line">    return x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>2. 使用 <code>pre_call</code> 绕过</strong></p>
<p>这种方法需要查看 <code>syscall</code> 的汇编实现, 来确定 <code>PT_DENY_ATTACH</code> 放在哪一个寄存器.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">libsystem_kernel.dylib`__syscall:</div><div class="line">    0x1815c0900 &lt;+0&gt;:  ldp    x1, x2, [sp]</div><div class="line">    0x1815c0904 &lt;+4&gt;:  ldp    x3, x4, [sp, #0x10]</div><div class="line">    0x1815c0908 &lt;+8&gt;:  ldp    x5, x6, [sp, #0x20]</div><div class="line">    0x1815c090c &lt;+12&gt;: ldr    x7, [sp, #0x30]</div><div class="line">    0x1815c0910 &lt;+16&gt;: mov    x16, #0x0</div><div class="line">    0x1815c0914 &lt;+20&gt;: svc    #0x80</div><div class="line">    0x1815c0918 &lt;+24&gt;: b.lo   0x1815c0930               ; &lt;+48&gt;</div><div class="line">    0x1815c091c &lt;+28&gt;: stp    x29, x30, [sp, #-0x10]!</div><div class="line">    0x1815c0920 &lt;+32&gt;: mov    x29, sp</div><div class="line">    0x1815c0924 &lt;+36&gt;: bl     0x1815a6dc0               ; cerror</div><div class="line">    0x1815c0928 &lt;+40&gt;: mov    sp, x29</div><div class="line">    0x1815c092c &lt;+44&gt;: ldp    x29, x30, [sp], #0x10</div><div class="line">    0x1815c0930 &lt;+48&gt;: ret</div></pre></td></tr></table></figure>
<p>可以看到调用如果 <code>x0</code> 是 <code>SYS_ptrace</code>, 那么 <code>PT_DENY_ATTACH</code> 存放在 <code>[sp]</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">void syscall_pre_call(RegState *rs, ThreadStack *threadstack, CallStack *callstack) &#123;</div><div class="line">    int num_syscall;</div><div class="line">    int request;</div><div class="line">    zpointer sp;</div><div class="line">    num_syscall = (int)(uint64_t)(rs-&gt;general.regs.x0);</div><div class="line">    if (num_syscall == SYS_ptrace) &#123;</div><div class="line">        sp = (zpointer)(rs-&gt;sp);</div><div class="line">        request = *(int *)sp;</div><div class="line">        if (request == PT_DENY_ATTACH) &#123;</div><div class="line">            *(long *)sp = 10;</div><div class="line">            NSLog(@&quot;[AntiDebugBypass] catch &apos;syscall(SYS_ptrace, PT_DENY_ATTACH, 0, &quot;</div><div class="line">                  @&quot;0, 0)&apos; and bypass.&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">__attribute__((constructor)) void patch_syscall_by_pre_call() &#123;</div><div class="line">    zpointer syscall_ptr = (void *)syscall;</div><div class="line">    #if 0</div><div class="line">    ZzBuildHook((void *)syscall_ptr, NULL, NULL, syscall_pre_call, NULL);</div><div class="line">    ZzEnableHook((void *)syscall_ptr);</div><div class="line">    #endif</div><div class="line">&#125;</div><div class="line">// --- end ---</div></pre></td></tr></table></figure>
<h4 id="svc-0x80-反调试绕过"><a href="#svc-0x80-反调试绕过" class="headerlink" title="svc #0x80 反调试绕过"></a><code>svc #0x80</code> 反调试绕过</h4><p>这里介绍关键是介绍如何对 svc 反调试的绕过.</p>
<p>上面已经对 svc 进行了简单的介绍. 所以理所当然想到的是希望通过 <code>syscall hook</code>, 劫持 <code>system call table(sysent)</code> . 这里相当于实现 <code>syscall hook</code>. 但是难点之一是需要找到 <code>system call table(sysent)</code>, 这一步可以通过 <a href="http://newosxbook.com/tools/joker.html" target="_blank" rel="external">joker</a>, 对于 IOS 10.x 可以参考 <code>http://ioshackerwiki.com/syscalls/</code>, 难点之二是作为 kext 加载. 可以参考 <strong>附录</strong>, 对于具体的 <code>kernel patch</code> 没有做过深入研究, 应该可以参考 <a href="https://github.com/comex/datautils0" target="_blank" rel="external">comex 的 datautils0</a></p>
<p>ok, 接下来使用另一种思路对绕过, 其实也就是 <code>code patch</code> + <code>hook address</code>. 对 <code>__TEXT</code> 扫描 <code>svc #0x80</code> 指令, 对于 cracker 来说, 在 <code>__TEXT</code> 段使用 <code>svc #0x80</code> 具有一定的反调试可能, 所以需要对 <code>svc #0x80</code> 进行 <code>hook addres</code>, 这里并不直接对 <code>svc #0x80</code> 进行覆盖操作.</p>
<p>以下代码依赖于 <a href="https://github.com/jmpews/HookZz" target="_blank" rel="external">HookZz</a>).</p>
<p>大致原理就是先搜索到 <code>svc #0x80</code> 指令后, 对该指令地址进行 hook, 之后使用 <code>pre_call</code> 修改寄存器的值.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">void hook_svc_pre_call(RegState *rs, ThreadStack *threadstack, CallStack *callstack) &#123;</div><div class="line">    int num_syscall;</div><div class="line">    int request;</div><div class="line">    num_syscall = (int)(uint64_t)(rs-&gt;general.regs.x16);</div><div class="line">    request = (int)(uint64_t)(rs-&gt;general.regs.x0);</div><div class="line">    </div><div class="line">    if (num_syscall == SYS_syscall) &#123;</div><div class="line">        int arg1 = (int)(uint64_t)(rs-&gt;general.regs.x1);</div><div class="line">        if (request == SYS_ptrace &amp;&amp; arg1 == PT_DENY_ATTACH) &#123;</div><div class="line">            *(unsigned long *)(&amp;rs-&gt;general.regs.x1) = 10;</div><div class="line">            NSLog(@&quot;[AntiDebugBypass] catch &apos;SVC #0x80; syscall(ptrace)&apos; and bypass&quot;);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125; else if (num_syscall == SYS_ptrace) &#123;</div><div class="line">        request = (int)(uint64_t)(rs-&gt;general.regs.x0);</div><div class="line">        if (request == PT_DENY_ATTACH) &#123;</div><div class="line">            *(unsigned long *)(&amp;rs-&gt;general.regs.x0) = 10;</div><div class="line">            NSLog(@&quot;[AntiDebugBypass] catch &apos;SVC-0x80; ptrace&apos; and bypass&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125; else if(num_syscall == SYS_sysctl) &#123;</div><div class="line">        STACK_SET(callstack, (char *)&quot;num_syscall&quot;, num_syscall, int);</div><div class="line">        STACK_SET(callstack, (char *)&quot;info_ptr&quot;, rs-&gt;general.regs.x2, zpointer);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void hook_svc_half_call(RegState *rs, ThreadStack *threadstack, CallStack *callstack) &#123;</div><div class="line">    // emmm... little long...</div><div class="line">    if(STACK_CHECK_KEY(callstack, (char *)&quot;num_syscall&quot;)) &#123;</div><div class="line">        int num_syscall = STACK_GET(callstack, (char *)&quot;num_syscall&quot;, int);</div><div class="line">        struct kinfo_proc *info = STACK_GET(callstack, (char *)&quot;info_ptr&quot;, struct kinfo_proc *);</div><div class="line">        if (num_syscall == SYS_sysctl)</div><div class="line">        &#123;</div><div class="line">            NSLog(@&quot;[AntiDebugBypass] catch &apos;SVC-0x80; sysctl&apos; and bypass&quot;);</div><div class="line">            info-&gt;kp_proc.p_flag &amp;= ~(P_TRACED);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">__attribute__((constructor)) void hook_svc_x80() &#123;</div><div class="line">    zaddr svc_x80_addr;</div><div class="line">    zaddr curr_addr, text_start_addr, text_end_addr;</div><div class="line">    uint32_t svc_x80_byte = 0xd4001001;</div><div class="line">    </div><div class="line">    const struct mach_header *header = _dyld_get_image_header(0);</div><div class="line">    struct segment_command_64 *seg_cmd_64 = zz_macho_get_segment_64_via_name((struct mach_header_64 *)header, (char *)&quot;__TEXT&quot;);</div><div class="line">    zsize slide = (zaddr)header - (zaddr)seg_cmd_64-&gt;vmaddr;</div><div class="line">    </div><div class="line">    struct section_64 *sect_64 = zz_macho_get_section_64_via_name((struct mach_header_64 *)header, (char *)&quot;__text&quot;);</div><div class="line">    </div><div class="line">    text_start_addr = slide + (zaddr)sect_64-&gt;addr;</div><div class="line">    text_end_addr = text_start_addr + sect_64-&gt;size;</div><div class="line">    curr_addr = text_start_addr;</div><div class="line">    </div><div class="line">    while (curr_addr &lt; text_end_addr) &#123;</div><div class="line">        svc_x80_addr = (zaddr)zz_vm_search_data((zpointer)curr_addr, (zpointer)text_end_addr, (zbyte *)&amp;svc_x80_byte, 4);</div><div class="line">        if (svc_x80_addr) &#123;</div><div class="line">            NSLog(@&quot;hook svc #0x80 at %p with aslr (%p without aslr)&quot;,</div><div class="line">                  (void *)svc_x80_addr, (void *)(svc_x80_addr - slide));</div><div class="line">            ZzBuildHookAddress((void *)svc_x80_addr, (void *)(svc_x80_addr + 4),</div><div class="line">                               hook_svc_pre_call, hook_svc_half_call);</div><div class="line">            ZzEnableHook((void *)svc_x80_addr);</div><div class="line">            curr_addr = svc_x80_addr + 4;</div><div class="line">        &#125; else &#123;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><a href="https://github.com/jmpews/HookZzModules/tree/master/AntiDebugBypass" target="_blank" rel="external">Move to AntiDebugBypass Detail</a></strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上文对很多的反调试原理做了总结, 也有一些没有讲到原理. 读者可以自行研究.</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// syscall hook</div><div class="line">http://siliconblade.blogspot.jp/2013/07/offensive-volatility-messing-with-os-x.html</div><div class="line">https://www.defcon.org/images/defcon-17/dc-17-presentations/defcon-17-bosse_eriksson-kernel_patching_on_osx.pdf</div><div class="line">http://d.hatena.ne.jp/hon53/20100926/1285476759</div><div class="line">https://papers.put.as/papers/ios/2011/SysScan-Singapore-Targeting_The_IOS_Kernel.pdf</div><div class="line">https://www.blackhat.com/docs/us-15/materials/us-15-Diquet-TrustKit-Code-Injection-On-iOS-8-For-The-Greater-Good.pdf</div></pre></td></tr></table></figure></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-08-09</span><i class="fa fa-tag"></i><a href="/categories/darwin/" title="darwin" class="tag">darwin </a><a href="/tags/darwin/" title="darwin" class="tag">darwin </a><a href="/tags/darwin逆向/" title="darwin逆向" class="tag">darwin逆向 </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://jmpews.github.com/2017/08/09/darwin/反调试及绕过/,jmpews,反调试及绕过,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2017/08/01/pwn/HookZz框架/" title="HookZz框架" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2017/08/09/darwin/反注入及绕过/" title="反注入及绕过[doing]" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>