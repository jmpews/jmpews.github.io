<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="jmpews,jmpews@gmail.com"><title>反调试及绕过 · jmpews</title><meta name="description" content="AntiDebugBypass on github
代码依赖于 HookZz, MachoParser
前言对于应用安全甲方一般会在这三个方面做防御. 
按逻辑分类的话应该应该分为这三类, 但如果从实现原理的话, 应该分为两类, 用API实现的 和 不用API实现的(这说的不用 API 实现, 不是"><meta name="keywords" content="py,go,pwn,reverse"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">jmpews</a></h3><div class="description"><p>py &amp; go &amp; pwn &amp; reverse</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/jmpews"><i class="fa fa-twitter"></i></a></li><li><a href="http://weibo.com/winter1ife"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/jmpews"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>反调试及绕过</a></h3></div><div class="post-content"><p><strong><a href="https://github.com/jmpews/HookZzModules/tree/master/AntiDebugBypass" target="_blank" rel="external">AntiDebugBypass on github</a></strong></p>
<p><strong>代码依赖于 <a href="https://github.com/jmpews/HookZz" target="_blank" rel="external">HookZz</a>, <a href="https://github.com/jmpews/MachoParser" target="_blank" rel="external">MachoParser</a></strong></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于应用安全甲方一般会在这三个方面做防御. </p>
<p>按逻辑分类的话应该应该分为这三类, 但如果从实现原理的话, 应该分为两类, <code>用API实现的</code> 和 <code>不用API实现的</code>(这说的不用 API 实现, 不是指换成 inine 函数就行) . 首先使用 API 实现基本统统沦陷. 直接通过指令实现的机制还有一丝存活的可能.</p>
<p>本文所有相关仅仅针对 aarch64.</p>
<p>假设读者对下知识有了解</p>
<ol>
<li>arm64 相关知识</li>
<li>macho 文件结构以及加载相关知识</li>
<li>dyld 链接 dylib 相关函数等知识</li>
</ol>
<p>如何 hook 不定参数函数? </p>
<p>技巧在于伪造原栈的副本. 具体参考下文.</p>
<p>通常来说必备手册</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 指令格式等细节</div><div class="line">ARM Architecture Reference Manual(ARMv8, for ARMv8-A architecture profile)</div><div class="line">https://static.docs.arm.com/ddi0487/b/DDI0487B_a_armv8_arm.pdf</div><div class="line"></div><div class="line">ARM Cortex -A Series Programmer’s Guide for ARMv8-A</div><div class="line">http://infocenter.arm.com/help/topic/com.arm.doc.den0024a/DEN0024A_v8_architecture_PG.pdf</div><div class="line"></div><div class="line">Calling conventions for different C++ compilers and operating systems</div><div class="line">http://www.agner.org/optimize/calling_conventions.pdf</div><div class="line"></div><div class="line">Procedure Call Standard for the ARM 64-bit Architecture (AArch64)</div><div class="line">http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf</div></pre></td></tr></table></figure>
<p>通常来说必备源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// dyld</div><div class="line">https://opensource.apple.com/tarballs/dyld/</div><div class="line"></div><div class="line">// xnu</div><div class="line">https://opensource.apple.com/tarballs/xnu/</div><div class="line"></div><div class="line">// objc</div><div class="line">https://opensource.apple.com/tarballs/objc4/</div><div class="line">https://github.com/RetVal/objc-runtime (可编译)</div></pre></td></tr></table></figure>
<h2 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h2><p>反调试从逻辑上分大概分为, 一种是直接屏蔽调试器挂载, 另一种就是根据特征手动检测调试器挂载. 当然也分为使用函数实现 和 直接使用内联 asm 实现.</p>
<h4 id="ptrace-反调试"><a href="#ptrace-反调试" class="headerlink" title="ptrace 反调试"></a>ptrace 反调试</h4><p>ptrace 反调试可以使用四种方法实现.</p>
<p><strong>1. 直接使用 ptrace 函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#if !defined(PT_DENY_ATTACH)</div><div class="line">#define PT_DENY_ATTACH 31</div><div class="line">#endif</div><div class="line">typedef int (*PTRACE_T)(int request, pid_t pid, caddr_t addr, int data);</div><div class="line"></div><div class="line">// ------------------------------------------------------------------</div><div class="line"></div><div class="line">static void AntiDebug_ptrace() &#123;</div><div class="line">    void *handle = dlopen(NULL, RTLD_GLOBAL | RTLD_NOW);</div><div class="line">    PTRACE_T ptrace_ptr = dlsym(handle, &quot;ptrace&quot;);</div><div class="line">    ptrace_ptr(PT_DENY_ATTACH, 0, 0, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>2. 使用 syscall 实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/syscall.h&gt;</div><div class="line">#if !defined(SYS_ptrace)</div><div class="line">#define SYS_ptrace 26</div><div class="line">#endif</div><div class="line">void AntiDebug_syscall() &#123; syscall(SYS_ptrace, PT_DENY_ATTACH, 0, 0, 0); &#125;</div></pre></td></tr></table></figure>
<p><strong>3. 内联 svc + ptrace 实现</strong></p>
<p>其实这种方法等同于直接使用 ptrace, 此时系统调用号是 <code>SYS_ptrace</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">static __attribute__((always_inline)) void AntiDebug_svc() &#123;</div><div class="line">#ifdef __arm64__</div><div class="line">    __asm__(</div><div class="line">        &quot;mov X0, #31\n&quot;</div><div class="line">        &quot;mov X1, #0\n&quot;</div><div class="line">        &quot;mov X2, #0\n&quot;</div><div class="line">        &quot;mov X3, #0\n&quot;</div><div class="line">        &quot;mov w16, #26\n&quot;</div><div class="line">        &quot;svc #0x80&quot;);</div><div class="line">#endif</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>4. 内联 svc + syscall + ptrace 实现</strong></p>
<p>其实这种方法等同于使用 <code>syscall(SYS_ptrace, PT_DENY_ATTACH, 0, 0, 0)</code>, 这里需要注意, 此时的系统调用号是 0, 也就是 <code>SYS_syscall</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static __attribute__((always_inline)) void AntiDebug_svc_syscall_syscall() &#123;</div><div class="line">#ifdef __arm64__</div><div class="line">    __asm__(</div><div class="line">        &quot;mov X0, #26\n&quot;</div><div class="line">        &quot;mov X1, #31\n&quot;</div><div class="line">        &quot;mov X2, #0\n&quot;</div><div class="line">        &quot;mov X3, #0\n&quot;</div><div class="line">        &quot;mov X4, #0\n&quot;</div><div class="line">        &quot;mov w16, #0\n&quot;</div><div class="line">        &quot;svc #0x80&quot;);</div><div class="line">#endif</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单整理下系统调用流程, 只能以 <code>xnu-3789.41.3</code> 源码举例.</p>
<p>Supervisor Call causes a Supervisor Call exception. svc 切换 <code>Exception Levels</code> 从 <code>EL0(Unprivileged)</code> 到 <code>EL1(Privileged)</code></p>
<p><img src="/images/C06F60DB066D85C69DC318113539A69C.jpg" alt="C06F60DB066D85C69DC318113539A69C.jpg"></p>
<p>上面说的是指令层相关, 再说系统层相关, 使用 svc 进行系统中断调用需要明确 3 个点: 中断号, 系统调用号, 以及参数. 下面以 x86-64 举例.</p>
<p>中断向量表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// xnu-3789.41.3/osfmk/x86_64/idt_table.h</div><div class="line">USER_TRAP_SPC(0x80,idt64_unix_scall)</div><div class="line">USER_TRAP_SPC(0x81,idt64_mach_scall)</div><div class="line">USER_TRAP_SPC(0x82,idt64_mdep_scall)</div></pre></td></tr></table></figure>
<p>中断处理函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// xnu-3789.41.3/osfmk/x86_64/idt64.s</div><div class="line">/*</div><div class="line"> * System call handlers.</div><div class="line"> * These are entered via a syscall interrupt. The system call number in %rax</div><div class="line"> * is saved to the error code slot in the stack frame. We then branch to the</div><div class="line"> * common state saving code.</div><div class="line"> */</div><div class="line">		</div><div class="line">#ifndef UNIX_INT</div><div class="line">#error NO UNIX INT!!!</div><div class="line">#endif</div><div class="line">Entry(idt64_unix_scall)</div><div class="line">	swapgs				/* switch to kernel gs (cpu_data) */</div><div class="line">	pushq	%rax			/* save system call number */</div><div class="line">	PUSH_FUNCTION(HNDL_UNIX_SCALL)</div><div class="line">	pushq	$(UNIX_INT)</div><div class="line">	jmp	L_32bit_entry_check</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">// xnu-3789.41.3/bsd/dev/i386/systemcalls.c</div><div class="line">__attribute__((noreturn))</div><div class="line">void</div><div class="line">unix_syscall64(x86_saved_state_t *state)</div><div class="line">&#123;</div><div class="line">	thread_t	thread;</div><div class="line">	void			*vt;</div><div class="line">	unsigned int	code;</div><div class="line">	struct sysent	*callp;</div><div class="line">	int		args_in_regs;</div><div class="line">	boolean_t	args_start_at_rdi;</div><div class="line">	int		error;</div><div class="line">	struct proc	*p;</div><div class="line">	struct uthread	*uthread;</div><div class="line">	x86_saved_state64_t *regs;</div><div class="line">	pid_t		pid;</div><div class="line"></div><div class="line">	assert(is_saved_state64(state));</div><div class="line">	regs = saved_state64(state);</div><div class="line">#if	DEBUG</div><div class="line">	if (regs-&gt;rax == 0x2000800)</div><div class="line">		thread_exception_return();</div><div class="line">#endif</div><div class="line">	thread = current_thread();</div><div class="line">	uthread = get_bsdthread_info(thread);</div><div class="line"></div><div class="line">#if PROC_REF_DEBUG</div><div class="line">	uthread_reset_proc_refcount(uthread);</div><div class="line">#endif</div><div class="line"></div><div class="line">	/* Get the approriate proc; may be different from task&apos;s for vfork() */</div><div class="line">	if (__probable(!(uthread-&gt;uu_flag &amp; UT_VFORK)))</div><div class="line">		p = (struct proc *)get_bsdtask_info(current_task());</div><div class="line">	else </div><div class="line">		p = current_proc();</div><div class="line"></div><div class="line">	/* Verify that we are not being called from a task without a proc */</div><div class="line">	if (__improbable(p == NULL)) &#123;</div><div class="line">		regs-&gt;rax = EPERM;</div><div class="line">		regs-&gt;isf.rflags |= EFL_CF;</div><div class="line">		task_terminate_internal(current_task());</div><div class="line">		thread_exception_return();</div><div class="line">		/* NOTREACHED */</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	code = regs-&gt;rax &amp; SYSCALL_NUMBER_MASK;</div><div class="line">	DEBUG_KPRINT_SYSCALL_UNIX(</div><div class="line">		&quot;unix_syscall64: code=%d(%s) rip=%llx\n&quot;,</div><div class="line">		code, syscallnames[code &gt;= nsysent ? SYS_invalid : code], regs-&gt;isf.rip);</div><div class="line">	callp = (code &gt;= nsysent) ? &amp;sysent[SYS_invalid] : &amp;sysent[code];</div></pre></td></tr></table></figure>
<p>系统调用表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">xnu-3789.41.3/bsd/kern/syscall.h</div><div class="line">#define	SYS_setuid         23</div><div class="line">#define	SYS_getuid         24</div><div class="line">#define	SYS_geteuid        25</div><div class="line">#define	SYS_ptrace         26</div><div class="line">#define	SYS_recvmsg        27</div><div class="line">#define	SYS_sendmsg        28</div></pre></td></tr></table></figure>
<h2 id="反调试检测"><a href="#反调试检测" class="headerlink" title="反调试检测"></a>反调试检测</h2><p>这里主要是调试器的检测手段, 很多检测到调试器后使用 <code>exit(-1)</code> 退出程序. 这里很容易让 cracker 断点到 <code>exit</code> 函数上. 其实有一个 trick 就是利用利用系统异常造成 crash. 比如: 操作无效内存地址. 或者覆盖/重写 <code>__TEXT</code> 内容(debugmode 模式下可以对 <code>rx-</code> 内存进行操作)</p>
<h4 id="使用-sysctl-检测"><a href="#使用-sysctl-检测" class="headerlink" title="使用 sysctl 检测"></a>使用 sysctl 检测</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/sysctl.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">static int DetectDebug_sysctl() __attribute__((always_inline));</div><div class="line">int DetectDebug_sysctl() &#123;</div><div class="line">  size_t size = sizeof(struct kinfo_proc);</div><div class="line">  struct kinfo_proc info;</div><div class="line">  int ret, name[4];</div><div class="line"></div><div class="line">  memset(&amp;info, 0, sizeof(struct kinfo_proc));</div><div class="line"></div><div class="line">  name[0] = CTL_KERN;</div><div class="line">  name[1] = KERN_PROC;</div><div class="line">  name[2] = KERN_PROC_PID;</div><div class="line">  name[3] = getpid();</div><div class="line"></div><div class="line">  if ((ret = (sysctl(name, 4, &amp;info, &amp;size, NULL, 0)))) &#123;</div><div class="line">    return ret; // sysctl() failed for some reason</div><div class="line">  &#125;</div><div class="line">  return (info.kp_proc.p_flag &amp; P_TRACED) ? 1 : 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void AntiDebug_sysctl() &#123;</div><div class="line">  if (DetectDebug_sysctl()) &#123;</div><div class="line">    exit(1);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用-isatty-检测"><a href="#使用-isatty-检测" class="headerlink" title="使用 isatty 检测"></a>使用 isatty 检测</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">void AntiDebug_isatty() &#123;</div><div class="line">  if (isatty(1)) &#123;</div><div class="line">    exit(1);</div><div class="line">  &#125; else &#123;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用-ioctl-检测"><a href="#使用-ioctl-检测" class="headerlink" title="使用 ioctl 检测"></a>使用 ioctl 检测</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/ioctl.h&gt;</div><div class="line">void AntiDebug_ioctl() &#123;</div><div class="line">  if (!ioctl(1, TIOCGWINSZ)) &#123;</div><div class="line">    exit(1);</div><div class="line">  &#125; else &#123;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><p>对于使用函数进行反调试可以使用 hook 轻松绕过, 具体的实现, 直接看代码.</p>
<h4 id="syscall-反调试绕过"><a href="#syscall-反调试绕过" class="headerlink" title="syscall 反调试绕过"></a>syscall 反调试绕过</h4><p>因为 <code>syscall</code> 反调试有些特殊, 这里需要介绍下如何绕过 <code>syscall</code> 反调试, 使用的是 <code>va_list</code> 进行传递参数. <code>http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf</code> 参考阅读 <code>va_list</code> 相关.</p>
<p>借助 <a href="https://github.com/jmpews/HookZz" target="_blank" rel="external">HookZz</a> 有两种方法可以进行绕过</p>
<p><strong>1. 使用 <code>replace_call</code> 绕过</strong></p>
<p>这里的 <code>syscall</code> 使用的是 <code>va_list</code> 传递参数. 所以这里问题在于如何 hook 不定参数函数. 因为在 hook 之后不确定原函数的参数个数. 所以没有办法调用原函数.</p>
<p>所以这里有一个 trick, 在 <code>orig_syscall(number, stack[0], stack[1], stack[2], stack[3], stack[4], stack[5], stack[6], stack[7]);</code> 时伪造了一个栈, 这个栈的内容和原栈相同(应该是大于等于原栈的参数内容). 虽然传递了很多参数, 如果理解 <code>function call</code> 的原理的话, 即使传递了很多参数, 但是只要栈的内容不变, 准确的说的是从低地址到高地址的栈里的内容不变(这里可能多压了很多无用的内容到栈里), 函数调用就不会变.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">// ptrace(int request, pid_t pid, caddr_t addr, int data);</div><div class="line">int (*orig_syscall)(int number, ...);</div><div class="line">int fake_syscall(int number, ...) &#123;</div><div class="line">  int request;</div><div class="line">  pid_t pid;</div><div class="line">  caddr_t addr;</div><div class="line">  int data;</div><div class="line"></div><div class="line">  // fake stack, why use `char *` ? hah</div><div class="line">  char *stack[8];</div><div class="line"></div><div class="line">  va_list args;</div><div class="line">  va_start(args, number);</div><div class="line"></div><div class="line">  // get the origin stack args copy.(must &gt;= origin stack args)</div><div class="line">  memcpy(stack, args, 8 * 8);</div><div class="line"></div><div class="line">  if (number == SYS_ptrace) &#123;</div><div class="line">    request = va_arg(args, int);</div><div class="line">    pid = va_arg(args, pid_t);</div><div class="line">    addr = va_arg(args, caddr_t);</div><div class="line">    data = va_arg(args, int);</div><div class="line">    va_end(args);</div><div class="line">    if (request == PT_DENY_ATTACH) &#123;</div><div class="line">      NSLog(@&quot;[AntiDebugBypass] catch &apos;syscall(SYS_ptrace, PT_DENY_ATTACH, 0, &quot;</div><div class="line">            @&quot;0, 0)&apos; and bypass.&quot;);</div><div class="line">      return 0;</div><div class="line">    &#125;</div><div class="line">  &#125; else &#123;</div><div class="line">    va_end(args);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // must understand the principle of `function call`. `parameter pass` is before `switch to target`</div><div class="line">  // so, pass the whole `stack`, it just actually faked an original stack.</div><div class="line">  // Not pass a large structure,  will be replace with a `hidden memcpy`.</div><div class="line">  int x = orig_syscall(number, stack[0], stack[1], stack[2], stack[3], stack[4], stack[5], stack[6], stack[7]);</div><div class="line">  return x;</div><div class="line">&#125;</div><div class="line"></div><div class="line">__attribute__((constructor)) void patch_ptrace_sysctl_syscall() &#123;</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">  zpointer syscall_ptr = (void *)syscall;</div><div class="line">  ZZBuildHook((void *)syscall_ptr, (void *)fake_syscall, (void</div><div class="line">  **)&amp;orig_syscall,</div><div class="line">              NULL, NULL);</div><div class="line">  ZZEnableHook((void *)syscall_ptr);</div><div class="line">&#125;</div><div class="line">// --- end --</div></pre></td></tr></table></figure>
<p><strong>2. 使用 <code>pre_call</code> 绕过</strong></p>
<p>这种方法需要查看 <code>syscall</code> 的汇编实现, 来确定 <code>PT_DENY_ATTACH</code> 放在哪一个寄存器.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">libsystem_kernel.dylib`__syscall:</div><div class="line">    0x1815c0900 &lt;+0&gt;:  ldp    x1, x2, [sp]</div><div class="line">    0x1815c0904 &lt;+4&gt;:  ldp    x3, x4, [sp, #0x10]</div><div class="line">    0x1815c0908 &lt;+8&gt;:  ldp    x5, x6, [sp, #0x20]</div><div class="line">    0x1815c090c &lt;+12&gt;: ldr    x7, [sp, #0x30]</div><div class="line">    0x1815c0910 &lt;+16&gt;: mov    x16, #0x0</div><div class="line">    0x1815c0914 &lt;+20&gt;: svc    #0x80</div><div class="line">    0x1815c0918 &lt;+24&gt;: b.lo   0x1815c0930               ; &lt;+48&gt;</div><div class="line">    0x1815c091c &lt;+28&gt;: stp    x29, x30, [sp, #-0x10]!</div><div class="line">    0x1815c0920 &lt;+32&gt;: mov    x29, sp</div><div class="line">    0x1815c0924 &lt;+36&gt;: bl     0x1815a6dc0               ; cerror</div><div class="line">    0x1815c0928 &lt;+40&gt;: mov    sp, x29</div><div class="line">    0x1815c092c &lt;+44&gt;: ldp    x29, x30, [sp], #0x10</div><div class="line">    0x1815c0930 &lt;+48&gt;: ret</div></pre></td></tr></table></figure>
<p>可以看到调用如果 <code>x0</code> 是 <code>SYS_ptrace</code>, 那么 <code>PT_DENY_ATTACH</code> 存放在 <code>[sp]</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// --- syscall bypass use `pre_call`</div><div class="line">void syscall_pre_call(struct RegState_ *rs) &#123;</div><div class="line">  int num_syscall;</div><div class="line">  int request;</div><div class="line">  zpointer sp;</div><div class="line">  num_syscall = (int)(uint64_t)(rs-&gt;general.regs.x0);</div><div class="line">  if (num_syscall == SYS_ptrace) &#123;</div><div class="line">    sp = (zpointer)(rs-&gt;sp);</div><div class="line">    request = *(int *)sp;</div><div class="line">    if (request == PT_DENY_ATTACH) &#123;</div><div class="line">      *(long *)sp = 10;</div><div class="line">      NSLog(@&quot;[AntiDebugBypass] catch &apos;syscall(SYS_ptrace, PT_DENY_ATTACH, 0, &quot;</div><div class="line">            @&quot;0, 0)&apos; and bypass.&quot;);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">__attribute__((constructor)) void patch_syscall_by_pre_call() &#123;</div><div class="line">  zpointer syscall_ptr = (void *)syscall;</div><div class="line">  ZZBuildHook((void *)syscall_ptr, NULL, NULL, (void *)syscall_pre_call, NULL);</div><div class="line">  ZZEnableHook((void *)syscall_ptr);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// --- end ---</div></pre></td></tr></table></figure>
<p>这里介绍关键是介绍如何对 svc 反调试的绕过.</p>
<p>上面已经对 svc 进行了简单的介绍. 所以理所当然想到的是希望通过 <code>syscall hook</code>, 劫持 <code>system call table(sysent)</code> . 这里相当于实现 <code>syscall hook</code>. 但是难点之一是需要找到 <code>system call table(sysent)</code>, 这一步可以通过 <a href="http://newosxbook.com/tools/joker.html" target="_blank" rel="external">joker</a>, 对于 IOS 10.x 可以参考 <code>http://ioshackerwiki.com/syscalls/</code>, 难点之二是作为 kext 加载. 可以参考 <strong>附录</strong>.</p>
<p>ok, 接下来使用另一种思路对绕过, 其实也就是 <code>code patch</code> + <code>inlinehook</code>. 对 <code>__TEXT</code> 扫描 <code>svc #0x80</code> 指令, 对于 cracker 来说, 在 <code>__TEXT</code> 段使用 <code>svc #0x80</code> 具有一定的反调试可能, 所以需要对 <code>svc #0x80</code> 进行 <code>inlinehook</code>, 这里并不直接对 <code>svc $0x80</code> 进行覆盖操作, 可能有正常系统调用.</p>
<p>以下代码依赖于 <a href="https://github.com/jmpews/HookZz" target="_blank" rel="external">HookZz</a>, <a href="https://github.com/jmpews/MachoParser" target="_blank" rel="external">MachoParser</a></p>
<p>大致原理就是先搜索到 <code>svc #0x80</code> 指令后, 对该指令地址进行 hook, 之后使用 <code>pre_call</code> 修改寄存器的值.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">// --- svc #0x80 bypass ---</div><div class="line"></div><div class="line">#include &quot;MachoMem.h&quot;</div><div class="line">void patch_svc_pre_call(struct RegState_ *rs) &#123;</div><div class="line">  int num_syscall;</div><div class="line">  int request;</div><div class="line">  num_syscall = (int)(uint64_t)(rs-&gt;general.regs.x16);</div><div class="line">  request = (int)(uint64_t)(rs-&gt;general.regs.x0);</div><div class="line"></div><div class="line">  if (num_syscall == SYS_syscall) &#123;</div><div class="line">    int arg1 = (int)(uint64_t)(rs-&gt;general.regs.x1);</div><div class="line">    if (request == SYS_ptrace &amp;&amp; arg1 == PT_DENY_ATTACH) &#123;</div><div class="line">      *(unsigned long *)(&amp;rs-&gt;general.regs.x1) = 10;</div><div class="line">      NSLog(@&quot;[AntiDebugBypass] catch &apos;SVC #0x80; syscall(ptrace)&apos; and bypass&quot;);</div><div class="line">    &#125;</div><div class="line">  &#125; else if (num_syscall == SYS_ptrace) &#123;</div><div class="line">    request = (int)(uint64_t)(rs-&gt;general.regs.x0);</div><div class="line">    if (request == PT_DENY_ATTACH) &#123;</div><div class="line">      *(unsigned long *)(&amp;rs-&gt;general.regs.x1) = 10;</div><div class="line">      NSLog(@&quot;[AntiDebugBypass] catch &apos;SVC-0x80; ptrace&apos; and bypass&quot;);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">__attribute__((constructor)) void patch_svc_x80() &#123;</div><div class="line">  const section_64_info_t *sect64;</div><div class="line">  zaddr svc_x80_addr;</div><div class="line">  zaddr curr_addr, end_addr;</div><div class="line">  uint32_t svc_x80_byte = 0xd4001001;</div><div class="line">  MachoMem *mem = new MachoMem();</div><div class="line">  mem-&gt;parse_macho();</div><div class="line">  // mem-&gt;parse_dyld();</div><div class="line">  sect64 = mem-&gt;get_sect_by_name(&quot;__text&quot;);</div><div class="line">  curr_addr = sect64-&gt;sect_addr;</div><div class="line">  end_addr = curr_addr + sect64-&gt;sect_64-&gt;size;</div><div class="line"></div><div class="line">  ZZInitialize();</div><div class="line">  while (curr_addr &lt; end_addr) &#123;</div><div class="line">    svc_x80_addr = mem-&gt;macho_search_data(</div><div class="line">        sect64-&gt;sect_addr, sect64-&gt;sect_addr + sect64-&gt;sect_64-&gt;size,</div><div class="line">        (const zbyte *)&amp;svc_x80_byte, 4);</div><div class="line">    if (svc_x80_addr) &#123;</div><div class="line">      NSLog(@&quot;find svc #0x80 at %p with aslr (%p without aslr)&quot;,</div><div class="line">            (void *)svc_x80_addr, (void *)(svc_x80_addr - mem-&gt;m_aslr_slide));</div><div class="line">      ZZBuildHook((void *)svc_x80_addr, NULL, NULL,</div><div class="line">                  (zpointer)patch_svc_pre_call, NULL);</div><div class="line">      ZZEnableHook((void *)svc_x80_addr);</div><div class="line">      curr_addr = svc_x80_addr + 4;</div><div class="line">    &#125; else &#123;</div><div class="line">      break;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">// --- end ---</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上文对很多的反调试原理做了总结, 也有一些没有讲到原理. 读者可以自行研究.</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// syscall hook</div><div class="line">http://siliconblade.blogspot.jp/2013/07/offensive-volatility-messing-with-os-x.html</div><div class="line">https://www.defcon.org/images/defcon-17/dc-17-presentations/defcon-17-bosse_eriksson-kernel_patching_on_osx.pdf</div><div class="line">http://d.hatena.ne.jp/hon53/20100926/1285476759</div><div class="line">https://papers.put.as/papers/ios/2011/SysScan-Singapore-Targeting_The_IOS_Kernel.pdf</div></pre></td></tr></table></figure></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-08-09</span><i class="fa fa-tag"></i><a href="/categories/darwin/" title="darwin" class="tag">darwin </a><a href="/tags/darwin/" title="darwin" class="tag">darwin </a><a href="/tags/darwin逆向/" title="darwin逆向" class="tag">darwin逆向 </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://jmpews.github.com/2017/08/09/darwin/反调试及绕过/,jmpews,反调试及绕过,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2017/08/01/pwn/HookZz框架/" title="HookZz框架" class="btn">上一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>