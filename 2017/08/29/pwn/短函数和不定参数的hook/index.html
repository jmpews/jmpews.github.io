<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="jmpews,jmpews@gmail.com"><title>短函数和不定参数函数的hook · jmpews</title><meta name="description" content="前言短函数的 inlinehook, 由于 hook 目标地址, 需要进行跳转, 如果分配不到可以 near jump 内存, 就只能进行 abs jump, 这就会导致被覆盖(修复)多条指令.
对于不定参数的 hook, 通常使用 MSHookFunction 进行 hook 但是由于不知道原参数"><meta name="keywords" content="py,go,pwn,reverse"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">jmpews</a></h3><div class="description"><p>py &amp; go &amp; pwn &amp; reverse</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/jmpews"><i class="fa fa-twitter"></i></a></li><li><a href="http://weibo.com/winter1ife"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/jmpews"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>短函数和不定参数函数的hook</a></h3></div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>短函数的 inlinehook, 由于 hook 目标地址, 需要进行跳转, 如果分配不到可以 <code>near jump</code> 内存, 就只能进行 <code>abs jump</code>, 这就会导致被覆盖(修复)多条指令.</p>
<p>对于不定参数的 hook, 通常使用 <code>MSHookFunction</code> 进行 hook 但是由于不知道原参数个数, 进而无法调用 <code>orig_function</code>.</p>
<h2 id="短函数-单指令-hook"><a href="#短函数-单指令-hook" class="headerlink" title="短函数(单指令) hook"></a>短函数(单指令) hook</h2><p>这里不对单指令 hook 的原理进行讲解, 如果需要了解原理 <a href="https://github.com/jmpews/HookZz/blob/master/docs/HookFrameworkDesign.md" target="_blank" rel="external">Move to HookZz FrameworkDesign</a></p>
<p>使用 <a href="https://github.com/jmpews/HookZz" target="_blank" rel="external">HookZz</a> 进行 hook.</p>
<p>下面以 hook <code>MGCopyAnswer</code> 为例子.</p>
<p>hook 之前.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(lldb) disass -s 0x0000000183114294</div><div class="line">libMobileGestalt.dylib`MGCopyAnswer:</div><div class="line">    0x183114294 &lt;+0&gt;:  mov    x1, #0x0</div><div class="line">    0x183114298 &lt;+4&gt;:  b      0x18311429c               ; ___lldb_unnamed_symbol64$$libMobileGestalt.dylib</div><div class="line"></div><div class="line">libMobileGestalt.dylib`___lldb_unnamed_symbol64$$libMobileGestalt.dylib:</div><div class="line">    0x18311429c &lt;+0&gt;:  stp    x24, x23, [sp, #-0x40]!</div><div class="line">    0x1831142a0 &lt;+4&gt;:  stp    x22, x21, [sp, #0x10]</div><div class="line">    0x1831142a4 &lt;+8&gt;:  stp    x20, x19, [sp, #0x20]</div><div class="line">    0x1831142a8 &lt;+12&gt;: stp    x29, x30, [sp, #0x30]</div><div class="line">    0x1831142ac &lt;+16&gt;: add    x29, sp, #0x30            ; =0x30 </div><div class="line">    0x1831142b0 &lt;+20&gt;: sub    sp, sp, #0x30             ; =0x30</div></pre></td></tr></table></figure>
<p>hook 之后.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(lldb) disass -s 0x0000000183114294</div><div class="line">libMobileGestalt.dylib`MGCopyAnswer:</div><div class="line">    0x183114294 &lt;+0&gt;:  b      0x17b114294</div><div class="line">    0x183114298 &lt;+4&gt;:  b      0x18311429c               ; ___lldb_unnamed_symbol64$$libMobileGestalt.dylib</div><div class="line"></div><div class="line">libMobileGestalt.dylib`___lldb_unnamed_symbol64$$libMobileGestalt.dylib:</div><div class="line">    0x18311429c &lt;+0&gt;:  stp    x24, x23, [sp, #-0x40]!</div><div class="line">    0x1831142a0 &lt;+4&gt;:  stp    x22, x21, [sp, #0x10]</div><div class="line">    0x1831142a4 &lt;+8&gt;:  stp    x20, x19, [sp, #0x20]</div><div class="line">    0x1831142a8 &lt;+12&gt;: stp    x29, x30, [sp, #0x30]</div><div class="line">    0x1831142ac &lt;+16&gt;: add    x29, sp, #0x30            ; =0x30 </div><div class="line">    0x1831142b0 &lt;+20&gt;: sub    sp, sp, #0x30             ; =0x30</div></pre></td></tr></table></figure>
<p>并且你可以通过两种方式进行 hack.</p>
<h4 id="1-hack-with-pre-call-amp-post-call"><a href="#1-hack-with-pre-call-amp-post-call" class="headerlink" title="1. hack with pre_call &amp; post_call"></a>1. hack with <code>pre_call</code> &amp; <code>post_call</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MGCopyAnswer_pre_call</span><span class="params">(RegState *rs, ThreadStack *threadstack, CallStack *callstack)</span> </span>&#123;</div><div class="line">    CFStringRef request = (CFStringRef)rs-&gt;general.regs.x0;</div><div class="line">    STACK_SET(callstack, <span class="string">"request"</span>, request, CFStringRef);</div><div class="line">    NSLog(@<span class="string">"request is: %@"</span>, request);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MGCopyAnswer_post_call</span><span class="params">(RegState *rs, ThreadStack *threadstack, CallStack *callstack)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(STACK_CHECK_KEY(callstack, <span class="string">"request"</span>)) &#123;</div><div class="line">        CFStringRef request = STACK_GET(callstack, <span class="string">"request"</span>, CFStringRef);</div><div class="line">        CFPropertyListRef result = (CFPropertyListRef)rs-&gt;general.regs.x0;</div><div class="line">        <span class="keyword">if</span>( [(__bridge NSString *) request isEqualToString:@<span class="string">"CPUArchitecture"</span>] &amp;&amp; [(__bridge NSString *) result isEqualToString:@<span class="string">"123456"</span>]) &#123;</div><div class="line">            CFStringRef zzarch = CFSTR(<span class="string">"654321"</span>);</div><div class="line">            CFStringRef *tmp = (CFStringRef *)&amp;rs-&gt;general.regs.x0;</div><div class="line">            *tmp = zzarch;</div><div class="line">            <span class="comment">// rs-&gt;general.regs.x0 = (void *)zzarch;</span></div><div class="line">        &#125;</div><div class="line">            </div><div class="line">        NSLog(@<span class="string">"result is: %@"</span>, result);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-hack-with-replace-call"><a href="#2-hack-with-replace-call" class="headerlink" title="2. hack with replace_call"></a>2. hack with <code>replace_call</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">CFPropertyListRef</span> <span class="params">(*orig_MGCopyAnswer)</span><span class="params">(CFStringRef prop)</span></span>;</div><div class="line"><span class="function">CFPropertyListRef <span class="title">new_MGCopyAnswer</span><span class="params">(CFStringRef prop)</span> </span>&#123;</div><div class="line">    CFPropertyListRef value = nil;</div><div class="line">    NSString *answerKey = (__bridge NSString *)prop;</div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(CFStringGetCStringPtr(prop, kCFStringEncodingMacRoman), <span class="string">"UniqueDeviceID"</span>)) &#123;</div><div class="line">        <span class="keyword">return</span> @<span class="string">"123456"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(CFStringGetCStringPtr(prop, kCFStringEncodingMacRoman), <span class="string">"CPUArchitecture"</span>)) &#123;</div><div class="line">        <span class="keyword">return</span> @<span class="string">"123456"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> orig_MGCopyAnswer(prop);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="不定参数函数的-hook"><a href="#不定参数函数的-hook" class="headerlink" title="不定参数函数的 hook"></a>不定参数函数的 hook</h2><p>举两个两个例子讲解下, 第一个使用 hook syscall, 第二个 hook printf.</p>
<h4 id="hack-syscall"><a href="#hack-syscall" class="headerlink" title="hack syscall"></a>hack <code>syscall</code></h4><p>先讲最简单的, 利用 <a href="https://github.com/jmpews/HookZz" target="_blank" rel="external">HookZz</a> 进行 <code>pre_call</code> &amp; <code>post_call</code> 的 hook, 此时维持原来的堆栈.</p>
<p><strong>1. hack with <code>pre_call</code> &amp; <code>post_call</code></strong></p>
<p>对 <code>syscall</code> 进行 <code>pre_call</code> 的 hook, 绕过反调试.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">void syscall_pre_call(RegState *rs, ThreadStack *threadstack, CallStack *callstack) &#123;</div><div class="line">    int num_syscall;</div><div class="line">    int request;</div><div class="line">    zpointer sp;</div><div class="line">    num_syscall = (int)(uint64_t)(rs-&gt;general.regs.x0);</div><div class="line">    if (num_syscall == SYS_ptrace) &#123;</div><div class="line">        sp = (zpointer)(rs-&gt;sp);</div><div class="line">        request = *(int *)sp;</div><div class="line">        if (request == PT_DENY_ATTACH) &#123;</div><div class="line">            *(long *)sp = 10;</div><div class="line">            NSLog(@&quot;[AntiDebugBypass] catch &apos;syscall(SYS_ptrace, PT_DENY_ATTACH, 0, &quot;</div><div class="line">                  @&quot;0, 0)&apos; and bypass.&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">__attribute__((constructor)) void patch_syscall_by_pre_call() &#123;</div><div class="line">    zpointer syscall_ptr = (void *)syscall;</div><div class="line">    #if 0</div><div class="line">    ZzBuildHook((void *)syscall_ptr, NULL, NULL, syscall_pre_call, NULL);</div><div class="line">    ZzEnableHook((void *)syscall_ptr);</div><div class="line">    #endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再讲使用 <code>relace_call</code> 进行 hook, 这种 hook 的难点在于如何调用原函数. 但其实仔细想想, 其实传参数, 本质是在构造参数栈, 所以只要可以与之前相同的参数栈即可. 其实整个技巧点在于构造一个原栈的复制栈.</p>
<p>注意: 此方法针对 valist 类型的函数有效, 对于 <code>objc_msgSend</code> 无效, 为何无效, 请逆向不同的 <code>objc_msgSend</code> 调用前的参数的构造.</p>
<p><strong>2. hack with <code>pre_call</code> &amp; <code>post_call</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">int (*orig_syscall)(int number, ...);</div><div class="line">int fake_syscall(int number, ...) &#123;</div><div class="line">    int request;</div><div class="line">    pid_t pid;</div><div class="line">    caddr_t addr;</div><div class="line">    int data;</div><div class="line">    </div><div class="line">    // 复制栈, 为什么是 char * 类型呢?</div><div class="line">    char *stack[8];</div><div class="line">    </div><div class="line">    va_list args;</div><div class="line">    va_start(args, number);</div><div class="line">    </div><div class="line">    // 获得 valist 参数内容的拷贝. 这里不一定是 8, 按理说应该越大越好</div><div class="line">    memcpy(stack, args, 8 * 8);</div><div class="line">    </div><div class="line">    if (number == SYS_ptrace) &#123;</div><div class="line">        request = va_arg(args, int);</div><div class="line">        pid = va_arg(args, pid_t);</div><div class="line">        addr = va_arg(args, caddr_t);</div><div class="line">        data = va_arg(args, int);</div><div class="line">        va_end(args);</div><div class="line">        if (request == PT_DENY_ATTACH) &#123;</div><div class="line">            NSLog(@&quot;[AntiDebugBypass] catch &apos;syscall(SYS_ptrace, PT_DENY_ATTACH, 0, &quot;</div><div class="line">                  @&quot;0, 0)&apos; and bypass.&quot;);</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        va_end(args);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 伪造原参数栈  </div><div class="line">    int x = orig_syscall(number, stack[0], stack[1], stack[2], stack[3], stack[4], tack[5], stack[6], stack[7]);</div><div class="line">    return x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="hack-printf"><a href="#hack-printf" class="headerlink" title="hack printf"></a>hack <code>printf</code></h4><p><strong>请仔细阅读该例子, 以及为何会产生如此 Output.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &quot;hookzz.h&quot;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;stdarg.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">int (*orig_printf)(const char * restrict format, ...);</div><div class="line">int fake_printf(const char * restrict format, ...) &#123;</div><div class="line">    puts(&quot;call printf&quot;);</div><div class="line"></div><div class="line">    char *stack[16];</div><div class="line">    va_list args;</div><div class="line">    va_start(args, format);</div><div class="line">    memcpy(stack, args, 8 * 16);</div><div class="line">    va_end(args);</div><div class="line"></div><div class="line">    // how to hook variadic function? fake a original copy stack.</div><div class="line">    // [move to detail-1](http://jmpews.github.io/2017/08/29/pwn/%E7%9F%AD%E5%87%BD%E6%95%B0%E5%92%8C%E4%B8%8D%E5%AE%9A%E5%8F%82%E6%95%B0%E7%9A%84hook/)</div><div class="line">    // [move to detail-2](https://github.com/jmpews/HookZzModules/tree/master/AntiDebugBypass)</div><div class="line">    int x = orig_printf(format, stack[0], stack[1], stack[2], stack[3], stack[4], stack[5], stack[6], stack[7], stack[8], stack[9], stack[10], stack[11], stack[12], stack[13], stack[14], stack[15]);</div><div class="line">    return x;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void printf_pre_call(RegState *rs, ThreadStack *threadstack, CallStack *callstack) &#123;</div><div class="line">    puts((char *)rs-&gt;general.regs.x0);</div><div class="line">    STACK_SET(callstack, &quot;format&quot;, rs-&gt;general.regs.x0, char *);</div><div class="line">    puts(&quot;printf-pre-call&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void printf_post_call(RegState *rs, ThreadStack *threadstack, CallStack *callstack) &#123;</div><div class="line">    if(STACK_CHECK_KEY(callstack, &quot;format&quot;)) &#123;</div><div class="line">        char *format = STACK_GET(callstack, &quot;format&quot;, char *);</div><div class="line">        puts(format);</div><div class="line">    &#125;</div><div class="line">    puts(&quot;printf-post-call&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">__attribute__((constructor)) void test_hook_printf()</div><div class="line">&#123;</div><div class="line">    void *printf_ptr = (void *)printf;</div><div class="line"></div><div class="line">    ZzBuildHook((void *)printf_ptr, (void *)fake_printf, (void **)&amp;orig_printf, printf_pre_call, printf_post_call);</div><div class="line">    ZzEnableHook((void *)printf_ptr);</div><div class="line">    printf(&quot;HookZzzzzzz, %d, %p, %d, %d, %d, %d, %d, %d, %d\n&quot;,1, (void *)2, 3, (char)4, (char)5, (char)6 , 7, 8 , 9);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">HookZzzzzzz, %d, %p, %d, %d, %d, %d, %d, %d, %d</div><div class="line"></div><div class="line">printf-pre-call</div><div class="line">call printf</div><div class="line">HookZzzzzzz, 1, 0x2, 3, 4, 5, 6, 7, 8, 9</div><div class="line">HookZzzzzzz, %d, %p, %d, %d, %d, %d, %d, %d, %d</div><div class="line"></div><div class="line">printf-post-call</div></pre></td></tr></table></figure></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-08-29</span><i class="fa fa-tag"></i><a href="/categories/pwn/" title="pwn" class="tag">pwn </a><a href="/tags/hook/" title="hook" class="tag">hook </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://jmpews.github.com/2017/08/29/pwn/短函数和不定参数的hook/,jmpews,短函数和不定参数函数的hook,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2017/08/23/notes/设计模式技巧笔记/" title="设计模式技巧笔记" class="btn">上一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>