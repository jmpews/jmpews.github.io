<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="jmpews,jmpews@gmail.com"><title>ptmalloc堆内存管理 · jmpews</title><meta name="description" content="前言参考资料12345678910111213141516171819202122232425262728大部分参考资料都在 `refs` 下#libc源码, 本文的核心http://www.eglibc.org/cgi-bin/viewvc.cgi/branches/eglibc-2_19/#非常"><meta name="keywords" content="py,go,pwn,reverse"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">jmpews</a></h3><div class="description"><p>py &amp; go &amp; pwn &amp; reverse</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/jmpews"><i class="fa fa-twitter"></i></a></li><li><a href="http://weibo.com/winter1ife"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/jmpews"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>ptmalloc堆内存管理</a></h3></div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">大部分参考资料都在 `refs` 下</div><div class="line"></div><div class="line">#libc源码, 本文的核心</div><div class="line">http://www.eglibc.org/cgi-bin/viewvc.cgi/branches/eglibc-2_19/</div><div class="line"></div><div class="line">#非常详细, 本文的核心</div><div class="line">&lt;refs/glibc内存管理ptmalloc源代码分析.pdf&gt;</div><div class="line"></div><div class="line">#这篇文章也不错, 很全面  </div><div class="line">http://tyrande000.how/2016/02/20/linux%E4%B8%8B%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86/</div><div class="line"></div><div class="line">#阿里聚安全, 只讲了及基本的数据结构, 对于具体的分配, 回收算法没有涉及到</div><div class="line">https://jaq.alibaba.com/community/art/show?spm=a313e.7916648.0.0.ZP7WcS&amp;articleid=315</div><div class="line"></div><div class="line">#很多人引用了这篇文章, 关于堆布局的图都是采用这篇文章里的</div><div class="line">https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/?spm=a313e.7916648.0.0.H9xzd9</div><div class="line"></div><div class="line">#Phrack</div><div class="line">#这篇文章很值的读, 虽然里面的一些技术不再适用, 但是其中的一些理念很不错, 比如其中关于如何利用爆破的方法绕过ASLR, 如何跟踪内存分配, 如何打印堆布局, 如何利用堆泄露关键信息.</div><div class="line">&lt;Advanced Doug Lea&apos;s malloc exploits&gt;</div><div class="line"></div><div class="line">#这篇文章主要讲 malloc 原理, 与现在的 glibc 版本有较大差异, 后一部分不建议看, 但是前面一部分举了一个例子, 如何利用 off-by NUL 的 bug, 总的来说应该算是 chunk corruption, 去完成 a carefully crafted fake chunk, 最终实现 aa4bmo.</div><div class="line">&lt;[Phrack]Vudo malloc tricks.pdf&gt;</div><div class="line"></div><div class="line">#glibc的调试相关</div><div class="line">http://blog.chinaunix.net/uid-24774106-id-3526766.html</div><div class="line">http://blog.chinaunix.net/uid-24774106-id-3642925.html</div><div class="line">http://stackoverflow.com/questions/10000335/how-to-use-debug-version-of-libc</div></pre></td></tr></table></figure>
<p>关于堆的分配原理我觉的这篇文章 <code>&lt;refs/glibc内存管理ptmalloc源代码分析.pdf&gt;</code> 已经说得很详细. 但是我尽力用 glibc 源码和自己的理解总结去概述, 本文章在说明时尽可能引用 <code>glibc-2.19</code> 中具体的代码和介绍, 用一些实例代码作为验证, 以及自己对 ptmalloc 的理解</p>
<h4 id="分析堆的相关工具"><a href="#分析堆的相关工具" class="headerlink" title="分析堆的相关工具"></a>分析堆的相关工具</h4><p>在 Phrack 的一篇文章中 <code>&lt;Advanced Doug Lea&#39;s malloc exploits&gt;</code>, 有一小节讲到 <code>Heap layout analysis</code> 作者利用了 <code>main_arena</code> 这个静态全局变量, 进行 heap dump 工作, 这里需要注意的是, 需要安装 <code>libc6-dbg</code> 以获取 <code>debugging symbols</code>, 此细节部分请查看 <code>参考资料/glibc的调试相关</code>.</p>
<p>这里介绍几个工具, 用于堆空间分配的分析.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">下面几个工具都是解析堆空间分配的</div><div class="line"></div><div class="line">#下面几个工具大同小异, 简单介绍下原理, 都是采用 python 的 gdb 的 API, 关于 API 有一篇文章</div><div class="line">https://sourceware.org/gdb/onlinedocs/gdb/Breakpoints-In-Python.html#Breakpoints-In-Python</div><div class="line">#之后通过 cat /proc/PID/maps 获取 heap base, 通过 gdb 的 `x/` 查看内存, 通过 `debugging symbols` 获取 `main_arena` 地址</div><div class="line">https://github.com/cloudburst/libheap</div><div class="line">https://github.com/Mipu94/peda-heap</div><div class="line">https://github.com/hugsy/gef</div><div class="line">https://github.com/pwndbg/pwndbg</div><div class="line"></div><div class="line">#ltrace</div><div class="line">#通过 ltrace 函数跟踪库函数调用.</div><div class="line">#关于 ltrace 的内部实现有一篇介绍文章, `refs/ltrace_internals.pdf`, 这里说一下大致原理, 起一个进程执行命令后, 根据 PID 拿到可执行文件, 之后按照 ELF 解析可执行文件, 拿到符号列表, 之后使用 ptrace attach 到 PID 上, 并在所有函数符号上插入断点.</div><div class="line"></div><div class="line">#通过 LD_PRELOAD 的 hook 方式跟踪内存分配函数, 这也是 Phrack 中 `&lt;Advanced Doug Lea&apos;s malloc exploits&gt;` 利用的方法, 缺点就是需要重新执行程序</div><div class="line">https://github.com/nihilus/HeapTracer/blob/master/linux-native</div></pre></td></tr></table></figure>
<h2 id="堆内存分配-ptmalloc设计-的思考"><a href="#堆内存分配-ptmalloc设计-的思考" class="headerlink" title="堆内存分配(ptmalloc设计)的思考"></a>堆内存分配(ptmalloc设计)的思考</h2><p>下面仅仅是个人在阅读完 ptmalloc 的分配和释放算法之后的一些关于 ptmalloc 设计上的一些想法, 毕竟之前是做开发的, </p>
<h4 id="0-为什么需要-ptmalloc"><a href="#0-为什么需要-ptmalloc" class="headerlink" title="0. 为什么需要 ptmalloc"></a>0. 为什么需要 ptmalloc</h4><p>首先<strong>内存的分配和回收很频繁的</strong>, 这也就是其他语言希望实现高效的 GC, 针对频繁的操作, 第一个想到的解决方法就是<strong>缓存</strong>, 这也就是为什么 ptmalloc 存在各种各样的缓冲区. 假如不存在缓冲区, 每次分配都需要触发系统调用贼慢. 接下来就要引出 ptmalloc 涉及到的几种缓存, 这里只是概念性的解释几种缓存, 具体会在下文详细介绍.</p>
<h4 id="1-Bins"><a href="#1-Bins" class="headerlink" title="1. Bins"></a>1. Bins</h4><p>为了避免每次触发系统调用, 首先想到的解决方法就是释放的内存暂时不归还给系统, 标记为空闲, 等下一次再需要相同大小时, 直接使用这块空闲内存即可. （存储结构是双向环链表, 类似 hash 表, hash 算法就是 chunk 的长度, 用双向环链表解决 hash 冲突)</p>
<p>这就涉及到, 刚刚释放的内存什么时候加到 Bins ? 相邻的两个空闲 chunk 什么时候合并? 怎么合并?</p>
<h4 id="2-Top"><a href="#2-Top" class="headerlink" title="2. Top"></a>2. Top</h4><p>另一个应该想到的就是, 可以先利用系统调用 <code>brk()</code> 分配一块比较大的内存作为缓存, 之后即使没有在 Bins 中也找不到, 也不需要每次触发系统调用, 直接切割这块大的内存即可.</p>
<p>这就涉及到 ‘这块大内存’ 什么时候重新补充大小(不断切割会导致 top 变小)? 什么时候需要缩小(归还给系统)?</p>
<h4 id="3-Fastbins"><a href="#3-Fastbins" class="headerlink" title="3. Fastbins"></a>3. Fastbins</h4><p>Bins 和 Top 缓存是最基本的, 如果想要做进一步的优化, 其实就是更细分的缓存, 也就是更准确的命中缓存, 这里 Fastbins 存在的更具体的原因是 <strong>避免 chunk 重复切割合并</strong>.</p>
<p> 如果了解过 Python 源码的同学可能会更理解, 这里的 Fastbins 类似于 Python 中整数对象 PyIntObject 的小整数 <code>small_ints</code>, 这里也只是理念类似, small_ints 准确的说是预先初始化, 可以一直重复使用而不被释放. </p>
<p>Ok, 再回到 Fastbins 的讨论, 对于长度很小的 chunk 在释放后不会放到 Bins, 也不会标记为空闲, 这就避免了<strong>合并</strong>, 下次分配内存时首先查找 Fastbins, 这就避免了<strong>切割</strong>. </p>
<h4 id="4-Unsorted-bin"><a href="#4-Unsorted-bin" class="headerlink" title="4. Unsorted bin"></a>4. Unsorted bin</h4><p>Unsorted 是更细粒度的缓存, 属于 <strong>‘刚刚释放的内存’与 Bins 之间的缓存</strong>.</p>
<p>在 <strong>1. Bins</strong> 中提到一个问题, 刚刚释放的内存什么时候加到 Bins ?  这其实就与 Unsorted 有关, 刚刚释放的内存会先放到 Unsorted 缓存, 在下一次内存分配时, 会优先于 Bins 查找, 如果能命中 Unsorted 缓冲最好, 否则就把 Unsorted 中的 chunk 统一整理到对应 Bins.</p>
<h4 id="5-last-remainder"><a href="#5-last-remainder" class="headerlink" title="5. last_remainder"></a>5. last_remainder</h4><p>这其实也是一个缓存, 是针对于切割时使用的, 大致就是希望一直切割同一个 chunk. 在遍历 Unsorted 时使用, 但是它的使用是有条件的.</p>
<p>以上就是在阅读完 ptmalloc 分配内存那一部分代码后对 ptmalloc 的缓存设计上的一些想法. 下面会具体介绍 ptmalloc 在进行堆内存用到的各种具体的数据结构. </p>
<h2 id="chunk-结构"><a href="#chunk-结构" class="headerlink" title="chunk 结构"></a>chunk 结构</h2><h4 id="chunk-结构-1"><a href="#chunk-结构-1" class="headerlink" title="chunk 结构"></a>chunk 结构</h4><p>这里先贴出一段 <code>glibc-2.19/malloc/malloc.c</code> 中关于 chunk 的解释. 不再详细解释.</p>
<p><code>boundary tag</code> 边界标记, 关于它下文会进行介绍</p>
<p><code>INTERNAL_SIZE_T</code> 头部损耗, 参考 <code>eglibc-2.19/malloc/malloc.c:299</code>, 其实也就是 <code>size_t</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line">eglibc<span class="number">-2.19</span>/<span class="built_in">malloc</span>/<span class="built_in">malloc</span>.c:<span class="number">1094</span></div><div class="line"><span class="comment">/*</span></div><div class="line">  -----------------------  Chunk representations -----------------------</div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">  This struct declaration is misleading (but accurate and necessary).</div><div class="line">  It declares a "view" into memory allowing access to necessary</div><div class="line">  fields at known offsets from a given base. See explanation below.</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="comment">// 一个 chunk 的完整结构体</span></div><div class="line"><span class="keyword">struct</span> malloc_chunk &#123;</div><div class="line"></div><div class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></div><div class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></div><div class="line"></div><div class="line">  <span class="keyword">struct</span> malloc_chunk* fd;         <span class="comment">/* double links -- used only if free. */</span></div><div class="line">  <span class="keyword">struct</span> malloc_chunk* bk;</div><div class="line"></div><div class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></div><div class="line">  <span class="keyword">struct</span> malloc_chunk* fd_nextsize; <span class="comment">/* double links -- used only if free. */</span></div><div class="line">  <span class="keyword">struct</span> malloc_chunk* bk_nextsize;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">   malloc_chunk details:</div><div class="line"></div><div class="line">    (The following includes lightly edited explanations by Colin Plumb.)</div><div class="line">	</div><div class="line">	// chunk 的内存管理采用边界标识的方法, 空闲 chunk 的 size 在该 chunk 的 size 字段和下一个 chunk 的 pre_size 字段都有记录</div><div class="line">    Chunks of memory are maintained using a `boundary tag' method as</div><div class="line">    described in e.g., Knuth or Standish.  (See the paper by Paul</div><div class="line">    Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a</div><div class="line">    survey of such techniques.)  Sizes of free chunks are stored both</div><div class="line">    in the front of each chunk and at the end.  This makes</div><div class="line">    consolidating fragmented chunks into bigger chunks very fast.  The</div><div class="line">    size fields also hold bits representing whether chunks are free or</div><div class="line">    in use.</div><div class="line"></div><div class="line">    An allocated chunk looks like this:</div><div class="line"></div><div class="line">	// 正在使用的 chunk 布局</div><div class="line">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">      |             Size of previous chunk, if allocated            | |</div><div class="line">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">      |             Size of chunk, in bytes                       |M|P|</div><div class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">      |             User data starts here...                          .</div><div class="line">      .                                                               .</div><div class="line">      .             (malloc_usable_size() bytes)                      .</div><div class="line">      .                                                               |</div><div class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">      |             Size of chunk                                     |</div><div class="line">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">	</div><div class="line">	// 几个术语规定, 'chunk' 就是整个 chunk 开头, 'mem' 就是用户数据的开始, 'Nextchunk' 就是下一个 chunk 的开头</div><div class="line">    Where "chunk" is the front of the chunk for the purpose of most of</div><div class="line">    the malloc code, but "mem" is the pointer that is returned to the</div><div class="line">    user.  "Nextchunk" is the beginning of the next contiguous chunk.</div><div class="line">	</div><div class="line">	// chunk 是双字长对齐</div><div class="line">    Chunks always begin on even word boundaries, so the mem portion</div><div class="line">    (which is returned to the user) is also on an even word boundary, and</div><div class="line">    thus at least double-word aligned.</div><div class="line">	</div><div class="line">	// 空闲 chunk 被存放在双向环链表</div><div class="line">    Free chunks are stored in circular doubly-linked lists, and look like this:</div><div class="line"></div><div class="line">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">      |             Size of previous chunk                            |</div><div class="line">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">    `head:' |             Size of chunk, in bytes                         |P|</div><div class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">      |             Forward pointer to next chunk in list             |</div><div class="line">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">      |             Back pointer to previous chunk in list            |</div><div class="line">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">      |             Unused space (may be 0 bytes long)                .</div><div class="line">      .                                                               .</div><div class="line">      .                                                               |</div><div class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">    `foot:' |             Size of chunk, in bytes                           |</div><div class="line">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line"></div><div class="line">	// P 标志位不能放在 size 字段的低位字节, 用于表示前一个 chunk 是否在被使用, 如果为 0, 表示前一个 chunk 空闲, 同时 pre_size 也表示前一个空闲 chunk 的大小, 可以用于找到前一个 chunk 的地址, 方便合并空闲 chunk, 但 chunk 刚一开始分配时默认 P 为 1. 如果 P 标志位被设置, 也就无法获取到前一个 chunk 的 size, 也就拿不到前一个 chunk 地址, 也就无法修改正在使用的 chunk, 但是这是无法修改前一个 chunk, 但是可以通过本 chunk 的 size 获得下一个 chunk 的地址. </div><div class="line">    The P (PREV_INUSE) bit, stored in the unused low-order bit of the</div><div class="line">    chunk size (which is always a multiple of two words), is an in-use</div><div class="line">    bit for the *previous* chunk.  If that bit is *clear*, then the</div><div class="line">    word before the current chunk size contains the previous chunk</div><div class="line">    size, and can be used to find the front of the previous chunk.</div><div class="line">    The very first chunk allocated always has this bit set,</div><div class="line">    preventing access to non-existent (or non-owned) memory. If</div><div class="line">    prev_inuse is set for any given chunk, then you CANNOT determine</div><div class="line">    the size of the previous chunk, and might even get a memory</div><div class="line">    addressing fault when trying to do so.</div><div class="line"></div><div class="line">    Note that the `foot' of the current chunk is actually represented</div><div class="line">    as the prev_size of the NEXT chunk. This makes it easier to</div><div class="line">    deal with alignments etc but can be very confusing when trying</div><div class="line">    to extend or adapt this code.</div><div class="line"></div><div class="line">    The two exceptions to all this are</div><div class="line">	</div><div class="line">	// 这里的 the trailing size 是指下一个 chunk 的 pre_size, 因为 top 位于最高地址, 不存在相邻的下一个 chunk, 同时这里也解答了上面关于 top 什么时候重新填满</div><div class="line">     1. The special chunk `top' doesn't bother using the</div><div class="line">  trailing size field since there is no next contiguous chunk</div><div class="line">  that would have to index off it. After initialization, `top'</div><div class="line">  is forced to always exist.  If it would become less than</div><div class="line">  MINSIZE bytes long, it is replenished.</div><div class="line"></div><div class="line">     2. Chunks allocated via mmap, which have the second-lowest-order</div><div class="line">  bit M (IS_MMAPPED) set in their size fields.  Because they are</div><div class="line">  allocated one-by-one, each must contain its own trailing size field.</div><div class="line"></div><div class="line">*/</div></pre></td></tr></table></figure>
<p>阅读文档, 是理解的最快的方式之一.</p>
<p><code>P (PREV_INUSE)</code> 标志位表示前一个 chunk 是否在使用, 0 为没有在使用.</p>
<p><code>prev_size</code> 表示前一个 chunk 的大小, 仅在 <code>P (PREV_INUSE)</code> 为 0 时有效, 也就是前一个 chunk 为空闲状态.</p>
<p><code>size</code> 表示该整个 chunk 大小, 并非 malloc 返回值.</p>
<p><code>fd</code>, <code>bk</code>, <code>fd_nextsize</code>, <code>fd_nextsize</code> 是对于空闲 chunk 而言, 对于正在使用的 chunk, 从当前位置开始就是 malloc 返回给用户可用的空间.</p>
<p><code>fd</code>, <code>bk</code> 组成了 Bins 的双向环链表</p>
<p>对于空闲的 chunk 空间布局, 见上, 是环形双向链表. 存放在空闲 chunk 容器中.</p>
<p>关于 chunk 有一些操作, 判断前一个是否在使用, 判断下一个 chunk 是否正在使用, 是不是 <code>mmap</code> 分配的, 以及对标志位 <code>P</code> 等的操作, 可以参考 <code>glibc-2.19/malloc/malloc.c:1206</code> 中 <code>Physical chunk operations</code> 一小节(直接搜素该关键字即可).</p>
<h4 id="边界标示"><a href="#边界标示" class="headerlink" title="边界标示"></a>边界标示</h4><p>对于 chunk 的空间布局组织采用边界标示的方法, chunk 的存储是一段连续的内存, 其实就是 chunk 头部保存长度信息, 可以在适当的时候获取到前一个和后一个 chunk.</p>
<p>这里涉及到 chunk 到用户请求 mem 的想换转化操作, 以及对齐操作等. 请参考 <code>glibc-2.19/malloc/malloc.c:1258</code></p>
<h4 id="空间复用"><a href="#空间复用" class="headerlink" title="空间复用"></a>空间复用</h4><p>对于正在使用 chunk, <strong>它的下一个 chunk 的 <code>prev_size</code></strong> 是无效的, 所以这块内存被当前 chunk 给借用了, 因此对于请求分配 chunk 大小分配公式是 <code>chunk_size = (用户请求大小 + (2 - 1) * sizeof(INTERNAL_SIZE_T)) align to 2 * sizeof(size_t)</code></p>
<p>最后请参考 <code>eglibc-2.19/malloc/malloc.c:44</code>, 会指出一些默认参数值, 以及关于 chunk 的最小 size 和 对齐的相关说明. 这里列出来了一小部分.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">Supported pointer representation:       4 or 8 bytes</div><div class="line">Supported size_t  representation:       4 or 8 bytes</div><div class="line">     Note that size_t is allowed to be 4 bytes even if pointers are 8.</div><div class="line">     You can adjust this by defining INTERNAL_SIZE_T</div><div class="line"></div><div class="line">Alignment:                              2 * sizeof(size_t) (default)</div><div class="line">     (i.e., 8 byte alignment with 4byte size_t). This suffices for</div><div class="line">     nearly all current machines and C compilers. However, you can</div><div class="line">     define MALLOC_ALIGNMENT to be wider than this if necessary.</div><div class="line"></div><div class="line">Minimum overhead per allocated chunk:   4 or 8 bytes</div><div class="line">     Each malloced chunk has a hidden word of overhead holding size</div><div class="line">     and status information.</div><div class="line"></div><div class="line">Minimum allocated size: 4-byte ptrs:  16 bytes    (including 4 overhead)</div><div class="line">	  8-byte ptrs:  24/32 bytes (including, 4/8 overhead)</div><div class="line"></div><div class="line">     When a chunk is freed, 12 (for 4byte ptrs) or 20 (for 8 byte</div><div class="line">     ptrs but 4 byte size) or 24 (for 8/8) additional bytes are</div><div class="line">     needed; 4 (8) for a trailing size field and 8 (16) bytes for</div><div class="line">     free list pointers. Thus, the minimum allocatable size is</div><div class="line">     16/24/32 bytes.</div><div class="line"></div><div class="line">     Even a request for zero bytes (i.e., malloc(0)) returns a</div><div class="line">     pointer to something of the minimum allocatable size.</div><div class="line"></div><div class="line">     The maximum overhead wastage (i.e., number of extra bytes</div><div class="line">     allocated than were requested in malloc) is less than or equal</div><div class="line">     to the minimum size, except for requests &gt;= mmap_threshold that</div><div class="line">     are serviced via mmap(), where the worst case wastage is 2 *</div><div class="line">     sizeof(size_t) bytes plus the remainder from a system page (the</div><div class="line">     minimal mmap unit); typically 4096 or 8192 bytes.</div></pre></td></tr></table></figure>
<p>翻译几个关键的点, chunk 的大小需要按照 Alignment 进行对齐, 每一个被分配的 chunk 都有一个字的头部消耗, 包含该 chunk 的大小以及状态信息, 具体会在 chunk 结构和边界标示说明.</p>
<h2 id="空闲容器-缓存"><a href="#空闲容器-缓存" class="headerlink" title="空闲容器(缓存)"></a>空闲容器(缓存)</h2><p>下面会介绍 ptmalloc 中存在的各种空闲容器</p>
<h4 id="Bins"><a href="#Bins" class="headerlink" title="Bins"></a>Bins</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">eglibc<span class="number">-2.19</span>/<span class="built_in">malloc</span>/<span class="built_in">malloc</span>.c:<span class="number">1341</span></div><div class="line"><span class="comment">/*</span></div><div class="line">   -------------------- Internal data structures --------------------</div><div class="line"></div><div class="line">   All internal state is held in an instance of malloc_state defined</div><div class="line">   below. There are no other static variables, except in two optional</div><div class="line">   cases:</div><div class="line"> * If USE_MALLOC_LOCK is defined, the mALLOC_MUTEx declared above.</div><div class="line"> * If mmap doesn't support MAP_ANONYMOUS, a dummy file descriptor</div><div class="line">     for mmap.</div><div class="line"></div><div class="line">   Beware of lots of tricks that minimize the total bookkeeping space</div><div class="line">   requirements. The result is a little over 1K bytes (for 4byte</div><div class="line">   pointers and size_t.)</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">   Bins</div><div class="line">	// Bins 就是由空闲 chunk - bin 组成数组, 每一个 bin 都是双向链表. Bin 存放是整理过的 chunks, 并且 bin 中合并过的空闲 chunk 是不存在相邻的, 所以 bin 中的每一个 chunk 都是可以被使用, 并且都是紧挨着正在使用的 chunk 或者 heap  内存末尾.</div><div class="line">    An array of bin headers for free chunks. Each bin is doubly</div><div class="line">    linked.  The bins are approximately proportionally (log) spaced.</div><div class="line">    There are a lot of these bins (128). This may look excessive, but</div><div class="line">    works very well in practice.  Most bins hold sizes that are</div><div class="line">    unusual as malloc request sizes, but are more usual for fragments</div><div class="line">    and consolidated sets of chunks, which is what these bins hold, so</div><div class="line">    they can be found quickly.  All procedures maintain the invariant</div><div class="line">    that no consolidated chunk physically borders another one, so each</div><div class="line">    chunk in a list is known to be preceeded and followed by either</div><div class="line">    inuse chunks or the ends of memory.</div><div class="line">	</div><div class="line">	// bins 中的 chunk 是按照大小排序的. FIFO, small bins 是不存在按大小排序的, 因为每一个 small bin 都是相同 size 的. 但是对于 large bin 是需要按照顺序插入的. 这样可以在内存分配时很快查找到合适内存.</div><div class="line">    Chunks in bins are kept in size order, with ties going to the</div><div class="line">    approximately least recently used chunk. Ordering isn't needed</div><div class="line">    for the small bins, which all contain the same-sized chunks, but</div><div class="line">    facilitates best-fit allocation for larger chunks. These lists</div><div class="line">    are just sequential. Keeping them in order almost never requires</div><div class="line">    enough traversal to warrant using fancier ordered data</div><div class="line">    structures.</div><div class="line">	</div><div class="line">	// FIFO, 从头部插入节点, 尾部取节点. 这样有个特定就是更容易内存的合并.</div><div class="line">    Chunks of the same size are linked with the most</div><div class="line">    recently freed at the front, and allocations are taken from the</div><div class="line">    back.  This results in LRU (FIFO) allocation order, which tends</div><div class="line">    to give each chunk an equal opportunity to be consolidated with</div><div class="line">    adjacent freed chunks, resulting in larger free chunks and less</div><div class="line">    fragmentation.</div><div class="line"></div><div class="line">    To simplify use in double-linked lists, each bin header acts</div><div class="line">    as a malloc_chunk. This avoids special-casing for headers.</div><div class="line">    But to conserve space and improve locality, we allocate</div><div class="line">    only the fd/bk pointers of bins, and then use repositioning tricks</div><div class="line">    to treat these as the fields of a malloc_chunk*.</div><div class="line"> */</div></pre></td></tr></table></figure>
<p>ptmalloc 采用分箱式管理空闲 chunk, 也就是 Bins. Bins 本身就是一个数组, 每一个存放的是一个对应长度的 chunk 双向环链表的头结点和尾节点. 相同 Size 的 chunk 才能组成一个环,Bins 是按大小依次进行存放.</p>
<p>关于 Bins 为什么定义为 <code>mchunkptr bins[NBINS * 2 - 2]</code> 而不是 <code>mchunkptr bins[NBINS * 4 - 2]</code>, 是如何少一倍的空间实现的双向链表, 可以参考 <code>&lt;refs/glibc内存管理ptmalloc源代码分析.pdf&gt;</code>, 这里大致说一下, 对于双向环的的标志头节点, 它的 <code>prev_size</code> 和 <code>size</code> 是无用的, 所以直接省略, 但是还要把它当成正确的 chunk 结构. 这里的 trick 就在于 <code>bin_at</code> 宏, 返回了伪造的 fake chunk 的地址, 这里和 <code>Double Free</code> 以及 <code>unlink绕过</code>的利用手法类似, 之后会在 <code>Double Free</code> 漏洞详细说明.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/* addressing -- note that bin_at(0) does not exist */</div><div class="line">#define bin_at(m, i) \</div><div class="line">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))			      \</div><div class="line">             - offsetof (struct malloc_chunk, fd))</div></pre></td></tr></table></figure>
<p>这里举一个例子, 只摘取一部分, 完整的例子, 在下方的 ptmalloc 利用部分.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># 查看 unsorted bin 的地址, 其实也就是 bin[<span class="number">1</span>] 的地址</div><div class="line">(gdb) heap -b</div><div class="line">===================================Heap Dump===================================</div><div class="line"></div><div class="line">unsorted bin @ <span class="number">0x7ffff7dd1b88</span></div><div class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x602160</span> - size <span class="number">0x90</span></div><div class="line"></div><div class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x6020b0</span> - size <span class="number">0x90</span></div><div class="line"></div><div class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x602000</span> - size <span class="number">0x90</span></div><div class="line"># 这里的 <span class="number">0x7ffff7dd1B78</span> 也就是 bin_at 返回的地址, 返回了一个伪造的 chunk 的地址</div><div class="line"># 其实这里的 fd 和 bk 才真正属于 bin[<span class="number">1</span>] 的内容.</div><div class="line">(gdb) p *(mfastbinptr)<span class="number">0x7ffff7dd1B78</span></div><div class="line">$<span class="number">17</span> = &#123;prev_size = <span class="number">6300176</span>, size = <span class="number">0</span>, fd = <span class="number">0x602160</span>, bk = <span class="number">0x602000</span>, fd_nextsize = <span class="number">0x7ffff7dd1b88</span> &lt;main_arena+<span class="number">104</span>&gt;, bk_nextsize = <span class="number">0x7ffff7dd1b88</span> &lt;main_arena+<span class="number">104</span>&gt;&#125;</div></pre></td></tr></table></figure>
<h4 id="small-bins-large-bins"><a href="#small-bins-large-bins" class="headerlink" title="small bins, large bins"></a>small bins, large bins</h4><p>对于 chunk  <code>size &lt; 512</code>, 是存放在 small bins, 有 64 个, 每个 bin 是以 8 bytes 作为分割边界, 也就相当于等差序列, 举个例子: small bins 中存放的第一个 <code>chunk 双向环链表</code> 全部都是由 size 为 16 bytes 大小的 chunk 组成的, 第二个 <code>chunk 双向环链表</code> 都是由 size 为 16+8 bytes 大小的 chunk 组成的. 但是对于 large bins, 分割边界是递增的, 举个简单例子: 前 32 个 large bins 的分割边界都是 64 bytes, 之后 16 个 large bins 的分割边界是 512 bytes. 以上仅为字长为 32 位的情况下, 具体请参考如下.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">eglibc-2.19/malloc/malloc.c:1436</div><div class="line">/*</div><div class="line">   Indexing</div><div class="line"></div><div class="line">    Bins for sizes &lt; 512 bytes contain chunks of all the same size, spaced</div><div class="line">    8 bytes apart. Larger bins are approximately logarithmically spaced:</div><div class="line"></div><div class="line">    64 bins of size       8</div><div class="line">    32 bins of size      64</div><div class="line">    16 bins of size     512</div><div class="line">     8 bins of size    4096</div><div class="line">     4 bins of size   32768</div><div class="line">     2 bins of size  262144</div><div class="line">     1 bin  of size what&apos;s left</div><div class="line"></div><div class="line">    There is actually a little bit of slop in the numbers in bin_index</div><div class="line">    for the sake of speed. This makes no difference elsewhere.</div><div class="line"></div><div class="line">    The bins top out around 1MB because we expect to service large</div><div class="line">    requests via mmap.</div><div class="line"></div><div class="line">    Bin 0 does not exist.  Bin 1 is the unordered list; if that would be</div><div class="line">    a valid chunk size the small bins are bumped up one.</div><div class="line"> */</div></pre></td></tr></table></figure>
<p>这涉及到如何根据 Size 在 Bins 中查到对应的 bin, 可以参考 <code>eglibc-2.19/malloc/malloc.c:1460</code></p>
<p>large bin 有些特殊, 空闲 chunk 的存放需要排序, <code>large_bin-&gt;bk</code> 为最小 size 的 chunk, <code>large_bin-&gt;fd</code> 为最大  size 的 chunk.</p>
<h4 id="Fastbins"><a href="#Fastbins" class="headerlink" title="Fastbins"></a>Fastbins</h4><p>关于 Fastbins 的介绍, 可以参考 <code>eglibc-2.19/malloc/malloc.c:1570</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">   Fastbins</div><div class="line">	// 单向链表, LIFO 规则</div><div class="line">    An array of lists holding recently freed small chunks.  Fastbins</div><div class="line">    are not doubly linked.  It is faster to single-link them, and</div><div class="line">    since chunks are never removed from the middles of these lists,</div><div class="line">    double linking is not necessary. Also, unlike regular bins, they</div><div class="line">    are not even processed in FIFO order (they use faster LIFO) since</div><div class="line">    ordering doesn&apos;t much matter in the transient contexts in which</div><div class="line">    fastbins are normally used.</div><div class="line">	// Fastbin即使被释放但仍然标记在使用</div><div class="line">    Chunks in fastbins keep their inuse bit set, so they cannot</div><div class="line">    be consolidated with other free chunks. malloc_consolidate</div><div class="line">    releases all chunks in fastbins and consolidates them with</div><div class="line">    other free chunks.</div><div class="line"> */</div></pre></td></tr></table></figure>
<p>当进行内存分配时先从 Fastbins 中进行查找, 之后才在 Bins 进行查找; 释放内存时, 当chunk <code>size &lt; max_fast</code> 会先存放到 Fastbins.</p>
<p>另一个需要注意的点就是 Fastbins 的合并(清空), 也就是 <code>malloc_consolidate</code> 这个函数的工作.</p>
<ul>
<li>何时会触发 <code>malloc_consolidate</code>(仅对 <code>_int_malloc</code> 函数而言) ? </li>
</ul>
<ol>
<li>small bins 尚未初始化</li>
<li>需要 size 大于 small bins</li>
</ol>
<ul>
<li><code>malloc_consolidate</code> 如何进行合并 ?</li>
</ul>
<p>遍历 Fastbins 中的 chunk, 设置每个 chunk 的空闲标志位为 0, 并合并相邻的空闲 chunk, 之后把该 chunk 存放到 unsorted bin 中.</p>
<p>Fastbins 是单向链表, 可以通过  <code>fastbin-&gt;fd</code> 遍历 Fastbins.</p>
<h4 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h4><p>只有一个 unsorted bin, 进行内存分配查找时先在 Fastbins, small bins 中查找, 之后会在 unsorted bin 中进行查找, 并整理 unsorted bin 中所有的 chunk 到 Bins 中对应的 Bin. unsorted bin 位于 <code>bin[1]</code>.</p>
<p><code>unsorted_bin-&gt;fd</code> 指向双向环链表的头结点, <code>unsorted_bin-&gt;bk</code> 指向双向环链表的尾节点, 在头部插入新的节点. </p>
<h4 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h4><p>top chunk 位于最高地址, 它的作用已经在上面提到过.</p>
<p>以下引用来自 <code>glibc内存管理ptmalloc源代码分析.pdf</code>.</p>
<blockquote>
<p>对于非主分配区会预先从 mmap 区域分配一块较大的空闲内存模拟 sub-heap,通过管 理 sub-heap 来响应用户的需求,因为内存是按地址从低向高进行分配的,在空闲内存的最 高处,必然存在着一块空闲 chunk,叫做 top chunk.当 bins 和 fast bins 都不能满足分配需 要的时候,ptmalloc 会设法在 top chunk 中分出一块内存给用户,如果 top chunk 本身不够大, 分配程序会重新分配一个 sub-heap,并将 top chunk 迁移到新的 sub-heap 上, 新的 sub-heap 与已有的 sub-heap 用单向链表连接起来,然后在新的 top chunk 上分配所需的内存以满足分配的需要,实际上,top chunk 在分配时总是在 fast bins 和 bins 之后被考虑,所以,不论 top chunk 有多大,它都不会被放到 fast bins 或者是 bins 中. top chunk 的大小是随着分配和回 收不停变换的,如果从 top chunk 分配内存会导致 top chunk 减小,如果回收的 chunk 恰好 与 top chunk 相邻,那么这两个 chunk 就会合并成新的 top chunk,从而使 top chunk 变大. 如果在 free 时回收的内存大于某个阈值,并且 top chunk 的大小也超过了收缩阈值,ptmalloc 会收缩 sub-heap,如果 top-chunk 包含了整个 sub-heap,ptmalloc 会调用 munmap 把整个 sub-heap 的内存返回给操作系统.</p>
<p>由于主分配区是唯一能够映射进程 heap 区域的分配区,它可以通过 sbrk()来增大或是 收缩进程 heap 的大小,ptmalloc 在开始时会预先分配一块较大的空闲内存 (也就是所谓的 heap), 主分配区的 top chunk 在第一次调用 mallocd 时会分配一块(chunk_size + 128KB) align 4KB 大小的空间作为初始的 heap,用户从 top chunk 分配内存时,可以直接取出一块内 存给用户.在回收内存时,回收的内存恰好与 top chunk 相邻则合并成新的 top chunk,当该次回收的空闲内存大小达到某个阈值,并且 top chunk 的大小也超过了收缩阈值,会执行内 存收缩,减小 top chunk 的大小,但至少要保留一个页大小的空闲内存,从而把内存归还给 操作系统.如果向主分配区的 top chunk 申请内存,而 top chunk 中没有空闲内存, ptmalloc 会调用 sbrk()将的进程 heap 的边界 brk 上移, 然后修改 top chunk 的大小.</p>
</blockquote>
<h4 id="mmaped-chunk"><a href="#mmaped-chunk" class="headerlink" title="mmaped chunk"></a>mmaped chunk</h4><blockquote>
<p>当需要分配的 chunk 足够大,而且 fast bins 和 bins 都不能满足要求,甚至 top chunk 本 身也不能满足分配需求时,ptmalloc 会使用 mmap 来直接使用内存映射来将页映射到进程空 间.这样分配的 chunk 在被 free 时将直接解除映射,于是就将内存归还给了操作系统,再 次对这样的内存区的引用将导致 segmentation fault 错误.这样的 chunk 也不会包含在任何 bin 中.</p>
</blockquote>
<h4 id="Last-remainder"><a href="#Last-remainder" class="headerlink" title="Last remainder"></a>Last remainder</h4><blockquote>
<p>Last remainder 是另外一种特殊的 chunk,就像 top chunk 和 mmaped chunk 一样,不会 在任何 bins 中找到这种 chunk.当需要分配一个 small chunk, 但在 small bins 中找不到合适 的 chunk, 如果 last remainder chunk 的大小大于所需的 small chunk 大小,last remainder chunk 被分裂成两个 chunk, 其中一个 chunk 返回给用户, 另一个 chunk 变成新的 last remainder chuk.</p>
</blockquote>
<p>需要注意的是, 仅在请求 small chunk 才使用.  具体可以参考 <code>eglibc-2.19/malloc/malloc.c:3459</code></p>
<h4 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h4><p>只存在一个主分区, 但是允许多个非主分区, 主分配区域可以访问 heap 区域 和 mmap 区域, 非主分区只能访问 mmap 区域, 每次用 mmap 分配一块大小的内存当做 sub-heap, 用于模拟 heap. 具体细节可以参考 <code>&lt;glibc内存管理ptmalloc源代码分析.pdf&gt;</code>, 每次进行内存分配必须加锁请求一个分配区.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">eglibc<span class="number">-2.19</span>/<span class="built_in">malloc</span>/<span class="built_in">malloc</span>.c:<span class="number">1663</span></div><div class="line"><span class="comment">/*</span></div><div class="line">   ----------- Internal state representation and initialization -----------</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">struct</span> malloc_state</div><div class="line">&#123;</div><div class="line">  <span class="comment">/* Serialize access.  */</span></div><div class="line">  <span class="keyword">mutex_t</span> mutex;</div><div class="line"></div><div class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></div><div class="line">  <span class="keyword">int</span> flags;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> THREAD_STATS</span></div><div class="line">  <span class="comment">/* Statistics for locking.  Only used if THREAD_STATS is defined.  */</span></div><div class="line">  <span class="keyword">long</span> stat_lock_direct, stat_lock_loop, stat_lock_wait;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">  <span class="comment">/* Fastbins */</span></div><div class="line">  mfastbinptr fastbinsY[NFASTBINS];</div><div class="line"></div><div class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></div><div class="line">  mchunkptr top;</div><div class="line"></div><div class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></div><div class="line">  mchunkptr last_remainder;</div><div class="line"></div><div class="line">  <span class="comment">/* Normal bins packed as described above */</span></div><div class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</div><div class="line"></div><div class="line">  <span class="comment">/* Bitmap of bins */</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</div><div class="line"></div><div class="line">  <span class="comment">/* Linked list */</span></div><div class="line">  <span class="keyword">struct</span> malloc_state *next;</div><div class="line"></div><div class="line">  <span class="comment">/* Linked list for free arenas.  */</span></div><div class="line">  <span class="keyword">struct</span> malloc_state *next_free;</div><div class="line"></div><div class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></div><div class="line">  INTERNAL_SIZE_T system_mem;</div><div class="line">  INTERNAL_SIZE_T max_system_mem;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>关于 <code>malloc_init_state</code> 的定义在:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">eglibc<span class="number">-2.19</span>/<span class="built_in">malloc</span>/<span class="built_in">malloc</span>.c:<span class="number">1768</span></div><div class="line"><span class="comment">/*</span></div><div class="line">   Initialize a malloc_state struct.</div><div class="line"></div><div class="line">   This is called only from within malloc_consolidate, which needs</div><div class="line">   be called in the same contexts anyway.  It is never called directly</div><div class="line">   outside of malloc_consolidate because some optimizing compilers try</div><div class="line">   to inline it at all call points, which turns out not to be an</div><div class="line">   optimization at all. (Inlining it in malloc_consolidate is fine though.)</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">malloc_init_state</span> <span class="params">(mstate av)</span></div><div class="line">&#123;</div></pre></td></tr></table></figure>
<p>在 <code>eglibc-2.19/malloc/malloc.c:1741</code> 有一个已经初始化的主分配区 <code>main_arena</code>,  根据 ELF 的结构解析, 已初始化的全局变量存放在 <code>.data</code> 段, 下图作为实践.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 33 是 Section 的 Index</div><div class="line">λ : readelf -s /usr/lib/debug//lib/x86_64-linux-gnu/libc-2.23.so | grep main_arena </div><div class="line">   915: 00000000003c3b20  2192 OBJECT  LOCAL  DEFAULT   33 main_arena</div><div class="line"># 对应 33 的 Section 恰好为 .data</div><div class="line">λ : readelf -S /usr/lib/debug//lib/x86_64-linux-gnu/libc-2.23.so | grep .data</div><div class="line">  [16] .rodata           NOBITS           0000000000174720  000002b4</div><div class="line">  [23] .tdata            NOBITS           00000000003bf7c0  001bf7c0</div><div class="line">  [29] .data.rel.ro      NOBITS           00000000003bf900  001bf7c0</div><div class="line">  [33] .data             NOBITS           00000000003c3080  001bf7c0</div></pre></td></tr></table></figure>
<h2 id="int-malloc-分析"><a href="#int-malloc-分析" class="headerlink" title="_int_malloc() 分析"></a>_int_malloc() 分析</h2><p>先获取分配区指针, 这个过程设计到分配区初始化和分配区加锁, 之后使用 <code>_int_malloc</code> 进行核心的内存分配. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">eglibc<span class="number">-2.19</span>/<span class="built_in">malloc</span>/<span class="built_in">malloc</span>.c:<span class="number">3295</span></div><div class="line"><span class="comment">/*</span></div><div class="line">   ------------------------------ malloc ------------------------------</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</div><div class="line">_int_malloc (mstate av, <span class="keyword">size_t</span> bytes)</div><div class="line">&#123;</div></pre></td></tr></table></figure>
<p>本来不想阅读, 发现不读根本不了解原理, 这一段分析来自 <code>&lt;glibc内存管理ptmalloc源代码分析&gt;</code> 但是对其中很多步骤做了补充和修改, 可以对比看一下 (以下针对 32 位字长)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">ptmalloc 的响应用户内存分配要求的具体步骤为:</div><div class="line"></div><div class="line">1) 获取分配区的锁, 为了防止多个线程同时访问同一个分配区, 在进行分配之前需要取得分配区域的锁. 线程先查看线程私有实例中是否已经存在一个分配区, 如果存 在尝试对该分配区加锁, 如果加锁成功, 使用该分配区分配内存, 否则, 该线程搜 索分配区循环链表试图获得一个空闲（没有加锁）的分配区. 如果所有的分配区都 已经加锁, 那么 ptmalloc 会开辟一个新的分配区, 把该分配区加入到全局分配区循 环链表和线程的私有实例中并加锁, 然后使用该分配区进行分配操作. 开辟出来的 新分配区一定为非主分配区, 因为主分配区是从父进程那里继承来的. 开辟非主分配区时会调用 mmap()创建一个 sub-heap, 并设置好 top chunk.</div><div class="line"></div><div class="line">2) 将用户的请求大小转换为实际需要分配的 chunk 空间大小. 具体查看 request2size 宏 (malloc.c:3332)</div><div class="line"></div><div class="line">3) 判断所需分配 chunk 的大小是否满足 chunk_size &lt;= max_fast (max_fast 默认为 64B),  如果是的话, 则转下一步, 否则跳到第 5 步. (malloc.c:3340)</div><div class="line"></div><div class="line">4) 首先尝试在 Fastbins 中查找所需大小的 chunk 分配给用户. 如果可以找到, 则分配结束. 否则转到下一步. (malloc.c:3340)</div><div class="line"></div><div class="line">5) 判断所需大小是否处在 small bins 中, 即判断 chunk_size &lt; 512B 是否成立. 如果 chunk 大小处在 small bins 中, 则转下一步, 否则转到第 7 步. (malloc.c:3377)</div><div class="line"></div><div class="line">6) 根据所需分配的 chunk 的大小, 找到具体所在的某个 small bin, 从该 Bin 的尾部摘取一个恰好满足大小的 chunk. 若成功, 则分配结束, 否则, 转到 8. (malloc.c:3377)</div><div class="line"></div><div class="line">7) 到了这一步, 说明需要分配的是一块大的内存, 于是, ptmalloc 首先会遍历 Fastbins 中的 chunk, 将相邻的空闲 chunk 进行合并,  并链接到 unsorted bin 中. 对于 Fastbins 的合并是由 `malloc_consolidate` 做处理. (malloc.c:3421)</div><div class="line"></div><div class="line">8) 遍历 unsorted bin 中的 chunk, 如果请求的 chunk 是一个 small chunk, 且 unsorted bin 只有一个 chunk, 并且这个 chunk 在上次分配时被使用过(也就是 last_remainder), 并且 chunk 的大小大于 (分配的大小 + MINSIZE), 这种情况下就直接将该 chunk 进行切割, 分配结束, 否则继续遍历, 如果发现一个 unsorted bin 的 size 恰好等于需要分配的 size, 命中缓存, 分配结束, 否则将根据 chunk 的空间大小将其放入对应的 small bins 或是 large bins 中, 遍历完成后, 转入下一步. (malloc.c:3442)</div><div class="line"></div><div class="line">9) 到了这一步说明需要分配的是一块大的内存, 并且 Fastbins 和 unsorted bin 中所有的 chunk 都清除干净 了. 从 large bins 中按照 “smallest-first, best-fit”(最小&amp;合适, 也就是说大于或等于所需 size 的最小 chunk) 原则, 找一个合适的 chunk, 从中划分一块合适大小的 chunk 进行切割, 并将剩下的部分放到 unsorted bin, 若操作成功, 则分配结束, 否则转到下一步. (malloc.c:3576)</div><div class="line"></div><div class="line">10) 到了这一步说明在对应的 bin 上没有找到合适的大小, 无论是 small bin 还是 large bin, 对于 small bin, 如果没有对应大小的 small bin, 只能 idx+1. 对于 large bin,在上一步的 large bin 并不一定能找到合适的 chunk 进行切割, 因为 large bins 间隔是很大的, 假如当前的 idx 的 large bin 只有一个 chunk, 但是所需 size 大于该 chunk, 这就导致找不到合适的, 只能继续 idx+1, 最后都需要根据 bitmap 找到之后第一个非空闲的 bin.  在这两种情况下找到的 bin 中的 chunk 一定可以进行切割或者全部分配(剩余的 size &lt; MINSIZE) (malloc.c:3649)</div><div class="line"></div><div class="line">11) 如果仍然都没有找到合适的 chunk, 那么就需要操作 top chunk 来进行分配了. 判断 top chunk 大小是否满足所需 chunk 的大小, 如果是, 则从 top chunk 中分出一块来. 否则转到下一步. (malloc.c:3749)</div><div class="line"></div><div class="line">12) 到了这一步, 说明 top chunk 也不能满足分配要求, 所以, 于是就有了两个选择: 如果是主分配区, 调用 sbrk(), 增加 top chunk 大小；如果是非主分配区, 调用 mmap 来分配一个新的 sub-heap, 增加 top chunk 大小；或者使用 mmap()来直接分配. 在这里, 需要依靠 chunk 的大小来决定到底使用哪种方法. 判断所需分配的 chunk 大小是否大于等于 mmap 分配阈值, 如果是的话, 则转下一步, 调用 mmap 分配,  否则跳到第 13 步, 增加 top chunk 的大小. (malloc.c:3800)</div><div class="line"></div><div class="line">13) 使用 mmap 系统调用为程序的内存空间映射一块 chunk_size align 4kB 大小的空间. 然后将内存指针返回给用户.</div><div class="line"></div><div class="line">14) 判断是否为第一次调用 malloc, 若是主分配区, 则需要进行一次初始化工作, 分配一块大小为(chunk_size + 128KB) align 4KB 大小的空间作为初始的 heap. 若已经初始化过了, 主分配区则调用 sbrk()增加 heap 空间, 分主分配区则在 top chunk 中切割出一个 chunk, 使之满足分配需求, 并将内存指针返回给用户.</div></pre></td></tr></table></figure>
<h2 id="int-free-分析"><a href="#int-free-分析" class="headerlink" title="_int_free() 分析"></a>_int_free() 分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">eglibc-2.19/malloc/malloc.c:3808</div><div class="line">/*</div><div class="line">   ------------------------------ free ------------------------------</div><div class="line"> */</div><div class="line"></div><div class="line">static void</div><div class="line">_int_free (mstate av, mchunkptr p, int have_lock)</div><div class="line">&#123;</div></pre></td></tr></table></figure>
<p>下面分析具体过程, 同样是参考 <code>&lt;glibc内存管理ptmalloc源代码分析&gt;</code> 但是对其中很多步骤做了补充和修改, 可以对比看一下 (以下针对 32 位字长)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">1) free()函数同样首先需要获取分配区的锁, 来保证线程安全.</div><div class="line"></div><div class="line">2) 判断传入的指针是否为 0, 如果为 0, 则什么都不做, 直接 return.否则转下一步.</div><div class="line"></div><div class="line">3) 判断 chunk 的大小和所处的位置, 若 chunk_size &lt;= max_fast, 并且 chunk 并不位于 heap 的顶部, 也就是说并不与 Top chunk 相邻, 则转到下一步, 否则跳到第 5 步.（因为与 top chunk 相邻的 chunk(fastbin) ,会与 top chunk 进行合并, 所以这里不仅需要判断大小, 还需要判断相邻情况）</div><div class="line"></div><div class="line">4) 将 chunk 放到 Fastbins 中, chunk 放入到 Fastbins 中时, 并不修改该 chunk 使用状 态位 P.也不与相邻的 chunk 进行合并.只是放进去, 如此而已.这一步做完之后 释放便结束了, 程序从 free()函数中返回.</div><div class="line"></div><div class="line">5) 判断所需释放的 chunk 是否为 mmaped chunk, 如果是, 则调用 munmap()释放 mmaped chunk, 解除内存空间映射, 该该空间不再有效.如果开启了 mmap 分配 阈值的动态调整机制, 并且当前回收的 chunk 大小大于 mmap 分配阈值, 将 mmap 分配阈值设置为该 chunk 的大小, 将 mmap 收缩阈值设定为 mmap 分配阈值的 2 倍, 释放完成, 否则跳到下一步.</div><div class="line"></div><div class="line">6) 判断前一个 chunk 是否处在使用中, 如果前一个块也是空闲块, 则合并.并转下一步.</div><div class="line"></div><div class="line">7) 判断当前释放 chunk 的下一个块是否为 top chunk, 如果是, 则转第 9 步, 否则转 下一步.</div><div class="line"></div><div class="line">8) 判断下一个 chunk 是否处在使用中, 如果下一个 chunk 也是空闲的, 则合并, 并将合并后的 chunk 放到 unsorted bin 中.注意, 这里在合并的过程中, 要更新 chunk 的大小, 以反映合并后的 chunk 的大小.并转到第 10 步.</div><div class="line"></div><div class="line">9) 如果执行到这一步, 说明释放了一个与 top chunk 相邻的 chunk.则无论它有多大,  都将它与 top chunk 合并, 并更新 top chunk 的大小等信息.转下一步. (malloc.c:3950)</div><div class="line"></div><div class="line">10) 判断合并后的 chunk 的大小是否大于 FASTBIN_CONSOLIDATION_THRESHOLD（默认 64KB）, 如果是的话, 则会触发进行 Fastbins 的合并操作(malloc_consolidate), Fastbins 中的 chunk 将被遍历, 并与相邻的空闲 chunk 进行合并, 合并后的 chunk 会被放到 unsorted bin 中. Fastbins 将变为空, 操作完成之后转下一步.</div><div class="line"></div><div class="line">11) 判断 top chunk 的大小是否大于 mmap 收缩阈值（默认为 128KB）, 如果是的话, 对于主分配区, 则会试图归还 top chunk 中的一部分给操作系统.但是最先分配的 128KB 空间是不会归还的, ptmalloc 会一直管理这部分内存, 用于响应用户的分配 请求；如果为非主分配区, 会进行 sub-heap 收缩, 将 top chunk 的一部分返回给操 作系统, 如果 top chunk 为整个 sub-heap, 会把整个 sub-heap 还回给操作系统.做 完这一步之后, 释放结束, 从 free() 函数退出.可以看出, 收缩堆的条件是当前 free 的 chunk 大小加上前后能合并 chunk 的大小大于 64k, 并且要 top chunk 的大 小要达到 mmap 收缩阈值, 才有可能收缩堆.</div></pre></td></tr></table></figure>
<h2 id="特殊的分配情况举例说明"><a href="#特殊的分配情况举例说明" class="headerlink" title="特殊的分配情况举例说明"></a>特殊的分配情况举例说明</h2><p>下面几个的演示例子中没有使用到一些 heap 分析插件, 会在 ptmalloc 的利用那一步使用到 heap 分析的插件.</p>
<p>下面一段表明小于 <code>Fastbins的size</code> 在释放后不会进行合并, 如果使用 gdb 查看 chunk 信息可以看到 <code>P</code> 标志位为 1, 这里需要注意的是看下一个 chunk 的 <code>P</code> 标志位, 而不是当前 chunk 的标志位, 这里就不进行演示了.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">void</span> *m1 = <span class="built_in">malloc</span>(<span class="number">24</span>);</div><div class="line">  <span class="keyword">int</span> t = <span class="number">0</span>;</div><div class="line">  <span class="keyword">void</span> * ms[<span class="number">200</span>];</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; <span class="number">200</span>; t++)</div><div class="line">    ms[t] = <span class="built_in">malloc</span>(<span class="number">120</span>); <span class="comment">// default fastbin size</span></div><div class="line"></div><div class="line">  <span class="built_in">malloc</span>(<span class="number">24</span>);</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; <span class="number">200</span>; t++)</div><div class="line">    <span class="built_in">free</span>(ms[t]);</div><div class="line">  <span class="keyword">void</span> *m2 = <span class="built_in">malloc</span>(<span class="number">24</span>);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,m1);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,m2);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// result:</span></div><div class="line">λ : gcc -g -o test2 test2.c &amp;&amp; ./test2</div><div class="line"><span class="number">0x17c2010</span></div><div class="line"><span class="number">0x17c8450</span></div></pre></td></tr></table></figure>
<hr>
<p>下面例子表明, 当 fast bin 的相邻为空闲 chunk, 以及相邻 top chunk 的情况, 都不会进行合并, 但是对于 top chunk 的情况有些特殊.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">  TRIM_FASTBINS controls whether free() of a very small chunk can</div><div class="line">  immediately lead to trimming. Setting to true (1) can reduce memory</div><div class="line">  footprint, but will almost always slow down programs that use a lot</div><div class="line">  of small chunks.</div><div class="line"></div><div class="line">  Define this only if you are willing to give up some speed to more</div><div class="line">  aggressively reduce system-level memory footprint when releasing</div><div class="line">  memory in programs that use many small chunks.  You can get</div><div class="line">  essentially the same effect by setting MXFAST to 0, but this can</div><div class="line">  lead to even greater slowdowns in programs using many small chunks.</div><div class="line">  TRIM_FASTBINS is an in-between compile-time option, that disables</div><div class="line">  only those chunks bordering topmost memory from being placed in</div><div class="line">  fastbins.</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>当设置 <code>TRIM_FASTBINS=1</code> fast bin 会与相邻的 top chunk 进行合并</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">λ : cat test5.c</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> *m1 = <span class="built_in">malloc</span>(<span class="number">500</span>);</div><div class="line">    <span class="keyword">void</span> *m2 = <span class="built_in">malloc</span>(<span class="number">40</span>);</div><div class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);</div><div class="line">    <span class="keyword">void</span> *m3 = <span class="built_in">malloc</span>(<span class="number">80</span>);</div><div class="line">    <span class="built_in">free</span>(m1);</div><div class="line">    <span class="built_in">free</span>(m2);</div><div class="line">    <span class="keyword">void</span> *m4 = <span class="built_in">malloc</span>(<span class="number">40</span>);</div><div class="line"></div><div class="line">    <span class="built_in">free</span>(m3);</div><div class="line">    <span class="keyword">void</span> *m5 = <span class="built_in">malloc</span>(<span class="number">80</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"m1, %p\n"</span>,m1);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"m2, %p\n"</span>,m2);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"m3, %p\n"</span>,m3);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"m4, %p\n"</span>,m4);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"m5, %p\n"</span>,m5);</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">// result:</span></div><div class="line">λ : gcc -g -o test5 test5.c &amp;&amp; ./test5</div><div class="line">m1, <span class="number">0x8b1010</span></div><div class="line">m2, <span class="number">0x8b1210</span></div><div class="line">m3, <span class="number">0x8b1260</span></div><div class="line">m4, <span class="number">0x8b1210</span></div><div class="line">m5, <span class="number">0x8b1260</span></div></pre></td></tr></table></figure>
<hr>
<p>下面的例子表明 small bin 在释放后会相邻合并的例子.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">void</span> *m1 = <span class="built_in">malloc</span>(<span class="number">24</span>);</div><div class="line">  <span class="keyword">int</span> t = <span class="number">0</span>;</div><div class="line">  <span class="keyword">void</span> * ms[<span class="number">200</span>];</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; <span class="number">200</span>; t++)</div><div class="line">    ms[t] = <span class="built_in">malloc</span>(<span class="number">121</span>); <span class="comment">// small bin size</span></div><div class="line"></div><div class="line">  <span class="built_in">malloc</span>(<span class="number">24</span>);</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; <span class="number">200</span>; t++)</div><div class="line">    <span class="built_in">free</span>(ms[t]);</div><div class="line">  <span class="keyword">void</span> *m2 = <span class="built_in">malloc</span>(<span class="number">24</span>);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,m1);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,m2);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// result:</span></div><div class="line">λ : gcc -g -o test2 test2.c &amp;&amp; ./test2</div><div class="line"><span class="number">0xeab010</span></div><div class="line"><span class="number">0xeab030</span></div></pre></td></tr></table></figure>
<hr>
<p>下面举例说明 <code>malloc_consolidate</code> 的作用, 以及如何触发 <code>malloc_consolidate</code>. 请仔细理解 m6, m7 和 m8.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">void</span> *m0 = <span class="built_in">malloc</span>(<span class="number">24</span>);</div><div class="line">        <span class="keyword">void</span> *m1 = <span class="built_in">malloc</span>(<span class="number">24</span>);</div><div class="line">        <span class="keyword">void</span> *m2 = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</div><div class="line">        <span class="keyword">void</span> *m3 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</div><div class="line">        <span class="keyword">void</span> *m4 = <span class="built_in">malloc</span>(<span class="number">24</span>);</div><div class="line">        <span class="keyword">void</span> *m5 = <span class="built_in">malloc</span>(<span class="number">24</span>);</div><div class="line">        <span class="built_in">malloc</span>(<span class="number">121</span>);</div><div class="line">        <span class="built_in">free</span>(m0);</div><div class="line">        <span class="built_in">free</span>(m1);</div><div class="line">        <span class="built_in">free</span>(m2);</div><div class="line">        <span class="built_in">free</span>(m3);</div><div class="line">        <span class="built_in">free</span>(m4);</div><div class="line">        <span class="built_in">free</span>(m5);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="built_in">malloc</span>(<span class="number">0x350</span>);</div><div class="line">        <span class="keyword">void</span> *m6 = <span class="built_in">malloc</span>(<span class="number">0x360</span>);</div><div class="line">        <span class="built_in">malloc</span>(<span class="number">1210</span>); <span class="comment">// 触发 Fastbins 合并</span></div><div class="line">        <span class="keyword">void</span> *m7 = <span class="built_in">malloc</span>(<span class="number">0x360</span>);</div><div class="line">        <span class="keyword">void</span> *m8 = <span class="built_in">malloc</span>(<span class="number">24</span>);</div><div class="line"></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"m0,%p\n"</span>, m0);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"m1,%p\n"</span>, m1);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"m2,%p\n"</span>, m2);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"m3,%p\n"</span>, m3);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"m4,%p\n"</span>, m4);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"m5,%p\n"</span>, m5);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"m6,%p\n"</span>, m6);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"m7,%p\n"</span>, m7);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"m8,%p\n"</span>, m8);</div><div class="line">&#125;</div><div class="line"></div><div class="line">result:</div><div class="line">λ : gcc -g -o test3 test3.c &amp;&amp; ./test3</div><div class="line">m0,<span class="number">0x1bf7010</span></div><div class="line">m1,<span class="number">0x1bf7030</span></div><div class="line">m2,<span class="number">0x1bf7050</span></div><div class="line">m3,<span class="number">0x1bf7260</span></div><div class="line">m4,<span class="number">0x1bf7370</span></div><div class="line">m5,<span class="number">0x1bf7390</span></div><div class="line">m6,<span class="number">0x1bf77a0</span></div><div class="line">m7,<span class="number">0x1bf7010</span></div><div class="line">m8,<span class="number">0x1bf7380</span></div></pre></td></tr></table></figure>
<hr>
<p>下面举例说明, 当 small bins 和 large bins 没有找到对应合适 size 的 Bin, 需要切割的情况.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> * m1 = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</div><div class="line">    <span class="built_in">malloc</span>(<span class="number">121</span>);</div><div class="line">    <span class="keyword">void</span> * m2 = <span class="built_in">malloc</span>(<span class="number">0x401</span>);</div><div class="line">    <span class="built_in">malloc</span>(<span class="number">121</span>);</div><div class="line">    <span class="built_in">free</span>(m2);</div><div class="line">    <span class="keyword">void</span> * m3 = <span class="built_in">malloc</span>(<span class="number">24</span>);</div><div class="line">    <span class="built_in">free</span>(m1);</div><div class="line">    <span class="keyword">void</span> * m4 = <span class="built_in">malloc</span>(<span class="number">24</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"m1, %p\n"</span>, m1);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"m2, %p\n"</span>, m2);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"m3, %p\n"</span>, m3);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"m4, %p\n"</span>, m4);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof(size_t) = %ld\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line">result:</div><div class="line">λ : gcc -g -o test1 test1.c &amp;&amp; ./test1</div><div class="line">m1, <span class="number">0x1a66010</span></div><div class="line">m2, <span class="number">0x1a662b0</span></div><div class="line">m3, <span class="number">0x1a662b0</span> <span class="comment">//切割 small bins</span></div><div class="line">m4, <span class="number">0x1a66010</span> <span class="comment">//切割 large bins</span></div><div class="line"><span class="keyword">sizeof</span>(<span class="keyword">size_t</span>) = <span class="number">8</span></div></pre></td></tr></table></figure>
<h2 id="exploit-在-ptmalloc-中"><a href="#exploit-在-ptmalloc-中" class="headerlink" title="exploit 在 ptmalloc 中"></a>exploit 在 ptmalloc 中</h2><p>首先明确大部分的关注点, 是在 <strong>leak infomation</strong> 和 <strong>aa4bmo</strong>.</p>
<p>对于 leak infomation, 需要所 dump 的地址内存放关键信息, 比如: 释放后的 chunk 的 fd 和 bk.</p>
<p>对于 aa4bmo, 这一块在 <code>PWN之堆触发.md</code> 有完善的介绍和总结.</p>
<p>下面的一些分析实例会用到 heap 的分析插件, 并且会提到一些具体的实践以对应之前的理论.</p>
<h4 id="Leak-Information-泄露关键信息"><a href="#Leak-Information-泄露关键信息" class="headerlink" title="Leak Information (泄露关键信息)"></a>Leak Information (泄露关键信息)</h4><p>Q: 什么是关键信息? </p>
<p>A: libc 地址, heap 地址</p>
<p>通过 ptmalloc 获得的内存 chunk 在释放后会变成上面提到的几种缓存类型, 这里主要提一下 Fastbins, Bins 能够泄漏什么关键信息.</p>
<p>分配区 <code>main_arena</code> 是已经初始化静态全局变量存放在 <code>libc.so.6</code> 的 <code>.data</code> 位置, 可以通过 <code>main_arena</code> 泄露  libc 的基址.</p>
<p>下面是一个关于 Fastbins 的例子, Fastbins 是单向链表, 通过 <code>fd</code> 指针进行遍历, 每次插入链表头位置, 可以通过已经释放的 Fastbin chunk 的 <code>fd</code> 指针 dump 到 heap 地址.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;                                                                                                                                                                                                  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;                                                                                                                                                                                                 </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;                                                                                                                                                                                                 </span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>                                                                                                                                                                                                        </span></div><div class="line">&#123;                                                                                                                                                                                                                  </div><div class="line">    <span class="keyword">void</span> * m1 = <span class="built_in">malloc</span>(<span class="number">0x80</span><span class="number">-8</span>);                                                                                                                                                                                    </div><div class="line">    <span class="keyword">void</span> * m2 = <span class="built_in">malloc</span>(<span class="number">0x80</span><span class="number">-8</span>);                                                                                                                                                                                    </div><div class="line">    <span class="built_in">memset</span>(m1, <span class="number">65</span>, <span class="number">0x80</span><span class="number">-8</span>);                                                                                                                                                                                        </div><div class="line">    <span class="built_in">memset</span>(m2, <span class="number">65</span>, <span class="number">0x80</span><span class="number">-8</span>);                                                                                                                                                                                        </div><div class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);                                                                                                                                                                                                     </div><div class="line">    <span class="built_in">free</span>(m1);                                                                                                                                                                                                      </div><div class="line">    <span class="built_in">free</span>(m2);                                                                                                                                                                                                      </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"m1: %p\n"</span>, m1);                                                                                                                                                                                        </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"m2: %p\n"</span>, m2);                                                                                                                                                                                        </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof(size_t): %ld\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>));                                                                                                                                                               </div><div class="line">&#125;</div><div class="line"></div><div class="line"># 主分配区</div><div class="line">(gdb) P &amp;main_arena </div><div class="line">$<span class="number">3</span> = (<span class="keyword">struct</span> malloc_state *) <span class="number">0x7ffff7dd1b20</span> &lt;main_arena&gt;</div><div class="line">(gdb) p main_arena </div><div class="line">$<span class="number">2</span> = &#123;mutex = <span class="number">0</span>, flags = <span class="number">0</span>, fastbinsY = &#123;<span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x602080</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>&#125;, top = <span class="number">0x602120</span>, last_remainder = <span class="number">0x0</span>, bins = &#123;...more... &#125;, binmap = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, next = <span class="number">0x7ffff7dd1b20</span> &lt;main_arena&gt;, next_free = <span class="number">0x0</span>, attached_threads = <span class="number">1</span>, system_mem = <span class="number">135168</span>, max_system_mem = <span class="number">135168</span>&#125;</div><div class="line"># 同上</div><div class="line">(gdb) heap</div><div class="line">===================================Heap Dump===================================</div><div class="line"></div><div class="line">Arena(s) found:</div><div class="line">         arena @ <span class="number">0x7ffff7dd1b20</span></div><div class="line"># Fastbins 在释放后, P 标志位不会被清空</div><div class="line">(gdb) heap -l</div><div class="line">===================================Heap Dump===================================</div><div class="line"></div><div class="line">          ADDR             SIZE         STATUS</div><div class="line">sbrk_base <span class="number">0x602000</span></div><div class="line">chunk     <span class="number">0x602000</span>         <span class="number">0x80</span>         (inuse)</div><div class="line">chunk     <span class="number">0x602080</span>         <span class="number">0x80</span>         (inuse)</div><div class="line">chunk     <span class="number">0x602100</span>         <span class="number">0x20</span>         (inuse)</div><div class="line">chunk     <span class="number">0x602120</span>         <span class="number">0x20ee0</span>      (top)</div><div class="line">sbrk_end  <span class="number">0x602001</span></div><div class="line"># 查看 bins</div><div class="line">(gdb) heap -b</div><div class="line">===================================Heap Dump===================================</div><div class="line">fast bin <span class="number">6</span> @ <span class="number">0x602080</span></div><div class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x602080</span> - size <span class="number">0x80</span> </div><div class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x602000</span> - size <span class="number">0x80</span> </div><div class="line"># 通过观察源码和这里 Fastbins 的顺序应该可以发现 Fastbins 是头插入</div><div class="line">(gdb) heap -f</div><div class="line">====================================Fastbins====================================</div><div class="line"></div><div class="line">[ fb <span class="number">0</span> ] <span class="number">0x7ffff7dd1b28</span>  -&gt; [ <span class="number">0x0</span> ] </div><div class="line">[ fb <span class="number">1</span> ] <span class="number">0x7ffff7dd1b30</span>  -&gt; [ <span class="number">0x0</span> ] </div><div class="line">[ fb <span class="number">2</span> ] <span class="number">0x7ffff7dd1b38</span>  -&gt; [ <span class="number">0x0</span> ] </div><div class="line">[ fb <span class="number">3</span> ] <span class="number">0x7ffff7dd1b40</span>  -&gt; [ <span class="number">0x0</span> ] </div><div class="line">[ fb <span class="number">4</span> ] <span class="number">0x7ffff7dd1b48</span>  -&gt; [ <span class="number">0x0</span> ] </div><div class="line">[ fb <span class="number">5</span> ] <span class="number">0x7ffff7dd1b50</span>  -&gt; [ <span class="number">0x0</span> ] </div><div class="line">[ fb <span class="number">6</span> ] <span class="number">0x7ffff7dd1b58</span>  -&gt; [ <span class="number">0x602080</span> ] (<span class="number">128</span>)</div><div class="line">                              [ <span class="number">0x602000</span> ] (<span class="number">128</span>)</div><div class="line">[ fb <span class="number">7</span> ] <span class="number">0x7ffff7dd1b60</span>  -&gt; [ <span class="number">0x0</span> ] </div><div class="line">[ fb <span class="number">8</span> ] <span class="number">0x7ffff7dd1b68</span>  -&gt; [ <span class="number">0x0</span> ] </div><div class="line">[ fb <span class="number">9</span> ] <span class="number">0x7ffff7dd1b70</span>  -&gt; [ <span class="number">0x0</span> ]</div><div class="line"># Fastbins 是根据 fd 指针进行遍历</div><div class="line">(gdb) p *(mchunkptr)<span class="number">0x602080</span></div><div class="line">$<span class="number">4</span> = &#123;prev_size = <span class="number">4702111234474983745</span>, size = <span class="number">129</span>, fd = <span class="number">0x602000</span>, bk = <span class="number">0x4141414141414141</span>, fd_nextsize = <span class="number">0x4141414141414141</span>, bk_nextsize = <span class="number">0x4141414141414141</span>&#125;</div><div class="line"># 这里 dump 之前 chunk 的内容可以拿到 heap 的地址</div><div class="line">(gdb) x/wx <span class="number">0x602090</span></div><div class="line"><span class="number">0x602090</span>:       <span class="number">0x00602000</span></div></pre></td></tr></table></figure>
<p>下面是一个关于 Bins 的例子, Bins 是双向环链表, 头插入, 可以通过已经释放的 Bin chunk 泄漏 libc 和 heap 地址.</p>
<p>这里需要理解一下由 <code>malloc(0xB0-8);</code> 的作用, 以及 Unstored bin 转为 small bins 的过程. 这里如果不清楚可以对应 libc 源码查看上面提到的 <code>_int_malloc()</code>的过程.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line">include&lt;stdio.h&gt;                                                                                                                                                                                                  </div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;                                                                                                                                                                                                 </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;                                                                                                                                                                                                 </span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>                                                                                                                                                                                                        </span></div><div class="line">&#123;                                                                                                                                                                                                                  </div><div class="line">    <span class="keyword">void</span> * m1 = <span class="built_in">malloc</span>(<span class="number">0x90</span><span class="number">-8</span>);                                                                                                                                                                                    </div><div class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);                                                                                                                                                                                                     </div><div class="line">    <span class="keyword">void</span> * m2 = <span class="built_in">malloc</span>(<span class="number">0x90</span><span class="number">-8</span>);                                                                                                                                                                                    </div><div class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);                                                                                                                                                                                                     </div><div class="line">    <span class="keyword">void</span> * m3 = <span class="built_in">malloc</span>(<span class="number">0xA0</span><span class="number">-8</span>);                                                                                                                                                                                    </div><div class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);                                                                                                                                                                                                     </div><div class="line">    <span class="built_in">memset</span>(m1, <span class="number">65</span>, <span class="number">0x90</span><span class="number">-8</span>);                                                                                                                                                                                        </div><div class="line">    <span class="built_in">memset</span>(m2, <span class="number">65</span>, <span class="number">0x90</span><span class="number">-8</span>);                                                                                                                                                                                        </div><div class="line">    <span class="built_in">memset</span>(m3, <span class="number">65</span>, <span class="number">0xA0</span><span class="number">-8</span>);                                                                                                                                                                                        </div><div class="line">                                                                                                                                                                                                                   </div><div class="line">    <span class="built_in">free</span>(m1);                                                                                                                                                                                                      </div><div class="line">    <span class="built_in">free</span>(m2);                                                                                                                                                                                                      </div><div class="line">    <span class="built_in">free</span>(m3);                                                                                                                                                                                                      </div><div class="line">    <span class="built_in">malloc</span>(<span class="number">0xB0</span><span class="number">-8</span>);                                                                                                                                                                                                </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"m1: %p\n"</span>, m1);                                                                                                                                                                                        </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"m2: %p\n"</span>, m2);                                                                                                                                                                                        </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"m3: %p\n"</span>, m3);                                                                                                                                                                                        </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof(size_t): %ld\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>));                                                                                                                                                               </div><div class="line">&#125; </div><div class="line"></div><div class="line">λ : gdb -q test2</div><div class="line">Reading symbols from test2...done.</div><div class="line">(gdb) b <span class="number">19</span></div><div class="line">Breakpoint <span class="number">1</span> at <span class="number">0x4006ac</span>: file test2.c, line <span class="number">19.</span></div><div class="line">(gdb) r</div><div class="line">Starting program: /home/spiderzz/Desktop/pwn/<span class="built_in">malloc</span>/test2 </div><div class="line"></div><div class="line">Breakpoint <span class="number">1</span>, main () at test2.c:<span class="number">19</span></div><div class="line"><span class="number">19</span>          <span class="built_in">malloc</span>(<span class="number">0xB0</span><span class="number">-8</span>);</div><div class="line">(gdb) heap</div><div class="line">===================================Heap Dump===================================</div><div class="line"></div><div class="line">Arena(s) found:</div><div class="line">         arena @ <span class="number">0x7ffff7dd1b20</span></div><div class="line"></div><div class="line"># Unsorted bin 是双向环链表, 这里需要观察, 双向环链表的两个端点 chunk 的 FD 和 BK 的地址不同之处, 因为一个在 libc 的空间, 一个在 heap 的空间.</div><div class="line">(gdb) heap -l</div><div class="line">===================================Heap Dump===================================</div><div class="line"></div><div class="line">          ADDR             SIZE         STATUS</div><div class="line">sbrk_base <span class="number">0x602000</span></div><div class="line">chunk     <span class="number">0x602000</span>         <span class="number">0x90</span>         (F) FD <span class="number">0x7ffff7dd1b78</span> BK <span class="number">0x6020b0</span> </div><div class="line">chunk     <span class="number">0x602090</span>         <span class="number">0x20</span>         (inuse)</div><div class="line">chunk     <span class="number">0x6020b0</span>         <span class="number">0x90</span>         (F) FD <span class="number">0x602000</span> BK <span class="number">0x602160</span> </div><div class="line">chunk     <span class="number">0x602140</span>         <span class="number">0x20</span>         (inuse)</div><div class="line">chunk     <span class="number">0x602160</span>         <span class="number">0xa0</span>         (F) FD <span class="number">0x6020b0</span> BK <span class="number">0x7ffff7dd1b78</span> </div><div class="line">chunk     <span class="number">0x602200</span>         <span class="number">0x20</span>         (inuse)</div><div class="line">chunk     <span class="number">0x602220</span>         <span class="number">0x20de0</span>      (top)</div><div class="line">sbrk_end  <span class="number">0x602001</span></div><div class="line">(gdb) heap -b</div><div class="line">===================================Heap Dump===================================</div><div class="line"></div><div class="line">unsorted bin @ <span class="number">0x7ffff7dd1b88</span></div><div class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x602160</span> - size <span class="number">0xa0</span></div><div class="line"></div><div class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x6020b0</span> - size <span class="number">0x90</span></div><div class="line"></div><div class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x602000</span> - size <span class="number">0x90</span></div><div class="line"># 这个也就是返回的 fake chunk 的地址, 这地址其实就是 bin_at 的返回值</div><div class="line">(gdb) p *(mfastbinptr)<span class="number">0x7ffff7dd1B78</span></div><div class="line">$<span class="number">1</span> = &#123;prev_size = <span class="number">6300192</span>, size = <span class="number">0</span>, fd = <span class="number">0x602160</span>, bk = <span class="number">0x602000</span>, fd_nextsize = <span class="number">0x7ffff7dd1b88</span> &lt;main_arena+<span class="number">104</span>&gt;, bk_nextsize = <span class="number">0x7ffff7dd1b88</span> &lt;main_arena+<span class="number">104</span>&gt;&#125;         </div><div class="line">(gdb) n</div><div class="line"><span class="number">20</span>          <span class="built_in">printf</span>(<span class="string">"m1: %p\n"</span>, m1);</div><div class="line"># 这里需要理解 Bins 的 FD 和 BK.</div><div class="line">(gdb) heap -l</div><div class="line">===================================Heap Dump===================================</div><div class="line"></div><div class="line">          ADDR             SIZE         STATUS</div><div class="line">sbrk_base <span class="number">0x602000</span></div><div class="line">chunk     <span class="number">0x602000</span>         <span class="number">0x90</span>         (F) FD <span class="number">0x7ffff7dd1bf8</span> BK <span class="number">0x6020b0</span> </div><div class="line">chunk     <span class="number">0x602090</span>         <span class="number">0x20</span>         (inuse)</div><div class="line">chunk     <span class="number">0x6020b0</span>         <span class="number">0x90</span>         (F) FD <span class="number">0x602000</span> BK <span class="number">0x7ffff7dd1bf8</span> </div><div class="line">chunk     <span class="number">0x602140</span>         <span class="number">0x20</span>         (inuse)</div><div class="line">chunk     <span class="number">0x602160</span>         <span class="number">0xa0</span>         (F) FD <span class="number">0x7ffff7dd1c08</span> BK <span class="number">0x7ffff7dd1c08</span> (LC)</div><div class="line">chunk     <span class="number">0x602200</span>         <span class="number">0x20</span>         (inuse)</div><div class="line">chunk     <span class="number">0x602220</span>         <span class="number">0xb0</span>         (inuse)</div><div class="line">chunk     <span class="number">0x6022d0</span>         <span class="number">0x20d30</span>      (top)</div><div class="line">sbrk_end  <span class="number">0x602001</span></div><div class="line"># 这里需要理解 Unsorted bin 是如何变为 small bin</div><div class="line">(gdb) heap -b</div><div class="line">===================================Heap Dump===================================</div><div class="line"></div><div class="line">small bin <span class="number">9</span> @ <span class="number">0x7ffff7dd1c08</span></div><div class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x6020b0</span> - size <span class="number">0x90</span></div><div class="line"></div><div class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x602000</span> - size <span class="number">0x90</span></div><div class="line">small bin <span class="number">10</span> @ <span class="number">0x7ffff7dd1c18</span></div><div class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x602160</span> - size <span class="number">0xa0</span></div><div class="line"># bin_at 的返回, 需要联合上面的两条命令返回的结果一起理解</div><div class="line">(gdb) p *(mfastbinptr)<span class="number">0x7ffff7dd1BF8</span> </div><div class="line">$<span class="number">3</span> = &#123;prev_size = <span class="number">140737351850984</span>, size = <span class="number">140737351850984</span>, fd = <span class="number">0x6020b0</span>, bk = <span class="number">0x602000</span>, fd_nextsize = <span class="number">0x602160</span>, bk_nextsize = <span class="number">0x602160</span>&#125;</div><div class="line"># bin_at 的返回, 需要联合上面的两条命令返回的结果一起理解</div><div class="line">(gdb) p *(mfastbinptr)<span class="number">0x7ffff7dd1C08</span></div><div class="line">$<span class="number">2</span> = &#123;prev_size = <span class="number">6299824</span>, size = <span class="number">6299648</span>, fd = <span class="number">0x602160</span>, bk = <span class="number">0x602160</span>, fd_nextsize = <span class="number">0x7ffff7dd1c18</span> &lt;main_arena+<span class="number">248</span>&gt;, bk_nextsize = <span class="number">0x7ffff7dd1c18</span> &lt;main_arena+<span class="number">248</span>&gt;&#125;</div></pre></td></tr></table></figure>
<p>上面提到如何使用 Bins 泄露 libc 和 heap 的地址, 这一部分其实在 Phrack 的 <code>&lt;Advanced Doug Lea&#39;s malloc exploits&gt;</code> 的 <code>4.5 Abusing the leaked information</code> 一小部分有提到. 可以通过 “find a lonely chunk in the heap” 去泄露, 相当于上面例子中的 <code>m3</code>, 位于 <code>small bin 10</code>, 释放后会修改 <code>FD</code>, <code>BK</code> 为该 Bin 的地址, 进而泄露 libc 的地址. 还有一种方法就是 “find the first or last chunk of a bin”, 相当于上面例子中的 <code>m1</code>, <code>m2</code>, 释放后, 会造成 <code>FD</code> 和 <code>BK</code> 一个在 <code>ptr_2_libc&#39;s_memory</code>, 一个在 <code>ptr_2_process&#39;_heap</code>.</p>
<p>下面说明如何使用一个 <code>lonely chunk</code>, 拿到关键函数的地址, 在 <code>&lt;Advanced Doug Lea&#39;s malloc exploits&gt;</code> 中使用的是 <code>__morecore</code> 这个函数指针, 它指向 <code>__default_morecore</code>, 也就是系统用于增加内存的函数, 默认为 <code>brk()</code>, 这里简单提一下.</p>
<p>这里直接使用上面的 <code>m3</code> 作为例子举例, <code>m3</code> 在释放后变为 <code>lonely chunk</code>, 位于 <code>small bin 10</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#0.这里已知该 chunk 所在 bin 的地址 (t0 = 0x7ffff7dd1c08+0x10)(对于为什么需要加 0x10, 是因为 fake chunk, 具体参考上面)</div><div class="line">#1.根据 chunk 的 size, 取得对应 bin index, 这里其实也就是 10, 可以查看 bin_index 宏, 查看对应具体实现</div><div class="line">#2.根据 bin index, 获取到该 bin 与 main_arena 的地址差, 从而获得 main_arena 的地址.</div><div class="line">t0 = 0x7ffff7dd1c08 + 0x10</div><div class="line">t1 = (long)&amp;main_arena.bins - (long)&amp;main_arena</div><div class="line">t2 = (long)&amp;__morecore - (long)&amp;(main_arena)</div><div class="line">t3 = (10-1)*2*8 //至于为什么这么算, 请参考源码 bin_at 宏</div><div class="line">&amp;main_arena = t0 - (t3+t1) = 0x7ffff7dd1b20</div><div class="line">#3.根据 _morecore 与 main_arena 的地址差, 得到 _morecore 的地址</div><div class="line">&amp;__morecore = &amp;main_arena + t2</div></pre></td></tr></table></figure>
<p>整个过程用一句话表示 “Using the known size of the chunk, we know in which bin it was placed, so we can get main_arena’s address and, finally, __morecore.”, 具体的过程也就是上面写的.</p>
<h4 id="aa4bmo-‘almost-arbitrary-4-bytes-mirrored-overwrite’-任意-4-字节写"><a href="#aa4bmo-‘almost-arbitrary-4-bytes-mirrored-overwrite’-任意-4-字节写" class="headerlink" title="aa4bmo ‘almost arbitrary 4 bytes mirrored overwrite’  (任意 4 字节写)"></a>aa4bmo ‘almost arbitrary 4 bytes mirrored overwrite’  (任意 4 字节写)</h4><p>很多情况下 aa4bmo 是由于 chunk overlap ( chunk corruption ) 导致的.</p>
<p>对于 aa4bmo, 这一块在 <code>PWN之堆触发.md</code> 有完善的介绍和总结.</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-01-06</span><i class="fa fa-tag"></i><a href="/categories/pwn/" title="pwn" class="tag">pwn </a><a href="/tags/pwn/" title="pwn" class="tag">pwn </a><a href="/tags/malloc/" title="malloc" class="tag">malloc </a><a href="/tags/heap/" title="heap" class="tag">heap </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://jmpews.github.com/2017/01/06/pwn/PWN之堆内存管理/,jmpews,ptmalloc堆内存管理,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2017/01/06/pwn/PWN之利用方法总结/" title="PWN之利用方法总结" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2017/01/07/pwn/PWN之ELF符号动态解析过程/" title="ELF符号动态解析过程" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>