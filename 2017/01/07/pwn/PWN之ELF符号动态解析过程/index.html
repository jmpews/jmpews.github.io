<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="jmpews,jmpews@gmail.com"><title>ELF符号动态解析过程 · jmpews</title><meta name="description" content="前言下面以该源程序分析整个动态链接解释符号的过程:
123456#include &amp;lt;stdio.h&amp;gt;int main(int argc, char *argv[])&amp;#123;printf(&amp;quot;Hello, world%d\n&amp;quot;, 1);return 0;&amp;#125;
"><meta name="keywords" content="py,go,pwn,reverse"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">jmpews</a></h3><div class="description"><p>py &amp; go &amp; pwn &amp; reverse</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/jmpews"><i class="fa fa-twitter"></i></a></li><li><a href="http://weibo.com/winter1ife"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/jmpews"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>ELF符号动态解析过程</a></h3></div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>下面以该源程序分析整个动态链接解释符号的过程:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">printf(&quot;Hello, world%d\n&quot;, 1);</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先查看 <code>section</code> 表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">➜  hook readelf -S test</div><div class="line">There are 30 section headers, starting at offset 0x1154:</div><div class="line"></div><div class="line">Section Headers:</div><div class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</div><div class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</div><div class="line">  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1</div><div class="line">  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4</div><div class="line">  [ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4</div><div class="line">  [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 000020 04   A  5   0  4</div><div class="line">  [ 5] .dynsym           DYNSYM          080481cc 0001cc 000050 10   A  6   1  4</div><div class="line">  [ 6] .dynstr           STRTAB          0804821c 00021c 00004c 00   A  0   0  1</div><div class="line">  [ 7] .gnu.version      VERSYM          08048268 000268 00000a 02   A  5   0  2</div><div class="line">  [ 8] .gnu.version_r    VERNEED         08048274 000274 000020 00   A  6   1  4</div><div class="line">  [ 9] .rel.dyn          REL             08048294 000294 000008 08   A  5   0  4</div><div class="line">  [10] .rel.plt          REL             0804829c 00029c 000018 08   A  5  12  4</div><div class="line">  [11] .init             PROGBITS        080482b4 0002b4 000023 00  AX  0   0  4</div><div class="line">  [12] .plt              PROGBITS        080482e0 0002e0 000040 04  AX  0   0 16</div><div class="line">  [13] .text             PROGBITS        08048320 000320 0001a2 00  AX  0   0 16</div><div class="line">  [14] .fini             PROGBITS        080484c4 0004c4 000014 00  AX  0   0  4</div><div class="line">  [15] .rodata           PROGBITS        080484d8 0004d8 000018 00   A  0   0  4</div><div class="line">  [16] .eh_frame_hdr     PROGBITS        080484f0 0004f0 00002c 00   A  0   0  4</div><div class="line">  [17] .eh_frame         PROGBITS        0804851c 00051c 0000b0 00   A  0   0  4</div><div class="line">  [18] .init_array       INIT_ARRAY      08049f08 000f08 000004 00  WA  0   0  4</div><div class="line">  [19] .fini_array       FINI_ARRAY      08049f0c 000f0c 000004 00  WA  0   0  4</div><div class="line">  [20] .jcr              PROGBITS        08049f10 000f10 000004 00  WA  0   0  4</div><div class="line">  [21] .dynamic          DYNAMIC         08049f14 000f14 0000e8 08  WA  6   0  4</div><div class="line">  [22] .got              PROGBITS        08049ffc 000ffc 000004 04  WA  0   0  4</div><div class="line">  [23] .got.plt          PROGBITS        0804a000 001000 000018 04  WA  0   0  4</div><div class="line">  [24] .data             PROGBITS        0804a018 001018 000008 00  WA  0   0  4</div><div class="line">  [25] .bss              NOBITS          0804a020 001020 000004 00  WA  0   0  1</div><div class="line">  [26] .comment          PROGBITS        00000000 001020 00002b 01  MS  0   0  1</div><div class="line">  [27] .shstrtab         STRTAB          00000000 00104b 000106 00      0   0  1</div><div class="line">  [28] .symtab           SYMTAB          00000000 001604 000430 10     29  45  4</div><div class="line">  [29] .strtab           STRTAB          00000000 001a34 000251 00      0   0  1</div></pre></td></tr></table></figure>
<p>反汇编 <code>main</code> 函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ disassemble  main</div><div class="line">Dump of assembler code for function main:</div><div class="line">   0x0804841d &lt;+0&gt;: push   ebp</div><div class="line">   0x0804841e &lt;+1&gt;: mov    ebp,esp</div><div class="line">   0x08048420 &lt;+3&gt;: and    esp,0xfffffff0</div><div class="line">   0x08048423 &lt;+6&gt;: sub    esp,0x10</div><div class="line">   0x08048426 &lt;+9&gt;: mov    DWORD PTR [esp+0x4],0x1</div><div class="line">   0x0804842e &lt;+17&gt;:    mov    DWORD PTR [esp],0x80484e0</div><div class="line">   0x08048435 &lt;+24&gt;:    call   0x80482f0 &lt;printf@plt&gt;</div><div class="line">   0x0804843a &lt;+29&gt;:    mov    eax,0x0</div><div class="line">   0x0804843f &lt;+34&gt;:    leave</div><div class="line">   0x08048440 &lt;+35&gt;:    ret</div><div class="line">End of assembler dump.</div></pre></td></tr></table></figure>
<p>单步执行至 <code>0x80482f0 &lt;printf@plt&gt;</code>, 这里需要用到前面的 <code>.got.plt</code>, <code>.plt</code>的知识, 大概说一下, <code>0x804a00c</code> 为 <code>.got.plt</code> 对应函数引用地址, 由于未初始化, <code>0x804a00c</code> 存放的就是下一句的地址 <code>0x080482f6</code>, 之后跳到 <code>0x80482e0</code> 开始进行初始化相关操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ disassemble</div><div class="line">Dump of assembler code for function printf@plt:</div><div class="line">=&gt; 0x080482f0 &lt;+0&gt;: jmp    DWORD PTR ds:0x804a00c</div><div class="line">   0x080482f6 &lt;+6&gt;: push   0x0</div><div class="line">   0x080482fb &lt;+11&gt;:    jmp    0x80482e0</div><div class="line">End of assembler dump.</div><div class="line">gdb-peda$ x/w 0x804a00c</div><div class="line">0x804a00c &lt;printf@got.plt&gt;: 0x080482f6</div></pre></td></tr></table></figure>
<p><code>0x804a008</code> 该地址预放了 <code>_dl_runtime_resolve</code> 函数的地址(<code>.got.plt</code> 表的第三项), 因为会跳到 <code>_dl_runtime_resolve</code> 进行初始化工作. 这里通过两次 <code>push</code> 操作, 其实是向 <code>_dl_fixup</code> 传入两个参数, 一个是需要重定位符号的偏移, 一个是 <code>link_map</code> 的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ x/4i 0x80482e0</div><div class="line">   0x80482e0:   push   DWORD PTR ds:0x804a004</div><div class="line">=&gt; 0x80482e6:   jmp    DWORD PTR ds:0x804a008</div><div class="line">   0x80482ec:   add    BYTE PTR [eax],al</div><div class="line">   0x80482ee:   add    BYTE PTR [eax],al</div><div class="line">gdb-peda$ x/w 0x804a008</div><div class="line">0x804a008:  0xb7ff24b0</div><div class="line">gdb-peda$ disassemble 0xb7ff24b0</div><div class="line">Dump of assembler code for function _dl_runtime_resolve:</div><div class="line">   0xb7ff24b0 &lt;+0&gt;: push   eax</div><div class="line">   0xb7ff24b1 &lt;+1&gt;: push   ecx</div><div class="line">   0xb7ff24b2 &lt;+2&gt;: push   edx</div><div class="line">   0xb7ff24b3 &lt;+3&gt;: mov    edx,DWORD PTR [esp+0x10]</div><div class="line">   0xb7ff24b7 &lt;+7&gt;: mov    eax,DWORD PTR [esp+0xc]</div><div class="line">   0xb7ff24bb &lt;+11&gt;:    call   0xb7fec080 &lt;_dl_fixup&gt;</div><div class="line">   0xb7ff24c0 &lt;+16&gt;:    pop    edx</div><div class="line">   0xb7ff24c1 &lt;+17&gt;:    mov    ecx,DWORD PTR [esp]</div><div class="line">   0xb7ff24c4 &lt;+20&gt;:    mov    DWORD PTR [esp],eax</div><div class="line">   0xb7ff24c7 &lt;+23&gt;:    mov    eax,DWORD PTR [esp+0x4]</div><div class="line">   0xb7ff24cb &lt;+27&gt;:    ret    0xc</div><div class="line">End of assembler dump.</div></pre></td></tr></table></figure>
<p>这里暂时不管 <code>_dl_fixup</code> 细节, 可以发现初始化完毕后 <code>.got.plt</code> 中第四项变为 <code>printf</code> 真实地址, 同时 <code>ret 0xc(参数表明pop多少字节)</code> 跳转到 <code>printf</code> 继续执行.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ info registers sp</div><div class="line">sp             0xbffff66c   0xbffff66c</div><div class="line">gdb-peda$ x/4w 0xbffff66c #sp地址</div><div class="line">0xbffff66c: 0xb7e71410  0x00000001  0xb7fff938  0x00000000</div><div class="line">gdb-peda$ x/4w 0x0804a000 # .got.plt 函数引用表</div><div class="line">0x804a000:  0x08049f14  0xb7fff938  0xb7ff24b0  0xb7e71410</div><div class="line">gdb-peda$ disassemble _dl_runtime_resolve</div><div class="line">Dump of assembler code for function _dl_runtime_resolve:</div><div class="line">   0xb7ff24b0 &lt;+0&gt; :    push   eax</div><div class="line">   0xb7ff24b1 &lt;+1&gt; :    push   ecx</div><div class="line">   0xb7ff24b2 &lt;+2&gt; :    push   edx</div><div class="line">   0xb7ff24b3 &lt;+3&gt; :    mov    edx,DWORD PTR [esp+0x10]</div><div class="line">   0xb7ff24b7 &lt;+7&gt; :    mov    eax,DWORD PTR [esp+0xc]</div><div class="line">   0xb7ff24bb &lt;+11&gt;:    call   0xb7fec080 &lt;_dl_fixup&gt;</div><div class="line">   0xb7ff24c0 &lt;+16&gt;:    pop    edx</div><div class="line">   0xb7ff24c1 &lt;+17&gt;:    mov    ecx,DWORD PTR [esp]</div><div class="line">   0xb7ff24c4 &lt;+20&gt;:    mov    DWORD PTR [esp],eax</div><div class="line">   0xb7ff24c7 &lt;+23&gt;:    mov    eax,DWORD PTR [esp+0x4]</div><div class="line">=&gt; 0xb7ff24cb &lt;+27&gt;:    ret    0xc</div><div class="line">End of assembler dump.</div></pre></td></tr></table></figure>
<p>当跳到 <code>.plt</code> 进行重定位时进行了 <code>push   0x0</code>, 其中 <code>0x0</code> 相当于 <code>.rel.plt</code> 中的偏移量, 根据 <code>Elf32_Rel</code> 结构进行重定位, <code>printf_retloc.r_offset= 0x0804a00c</code> 对应 <code>.got.plt</code> 中的第四项,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ x/8x 0x0804829c # .rel.plt 重定位表</div><div class="line">0x804829c:  0x0804a00c  0x00000107  0x0804a010  0x00000207</div><div class="line">0x80482ac:  0x0804a014  0x00000307  0x08ec8353  0x000093e8</div></pre></td></tr></table></figure>
<h4 id="分析-dl-fixup-函数-eglibc-2-19-elf-dl-runtime-c"><a href="#分析-dl-fixup-函数-eglibc-2-19-elf-dl-runtime-c" class="headerlink" title="分析 _dl_fixup 函数(eglibc-2.19/elf/dl-runtime.c)"></a>分析 <code>_dl_fixup</code> 函数(<code>eglibc-2.19/elf/dl-runtime.c</code>)</h4><p>参考链接:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://blog.chinaunix.net/uid-21471835-id-441227.html</div></pre></td></tr></table></figure>
<p>先把几个宏定义列举出来 (<code>eglibc-2.19/sysdeps/i386/ldsodefs.h</code>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* All references to the value of l_info[DT_PLTGOT],</div><div class="line">  l_info[DT_STRTAB], l_info[DT_SYMTAB], l_info[DT_RELA],</div><div class="line">  l_info[DT_REL], l_info[DT_JMPREL], and l_info[VERSYMIDX (DT_VERSYM)]</div><div class="line">  have to be accessed via the D_PTR macro.  The macro is needed since for</div><div class="line">  most architectures the entry is already relocated - but for some not</div><div class="line">  and we need to relocate at access time.  */</div><div class="line">#ifdef DL_RO_DYN_SECTION</div><div class="line"># define D_PTR(map, i) ((map)-&gt;i-&gt;d_un.d_ptr + (map)-&gt;l_addr)</div><div class="line">#else</div><div class="line"># define D_PTR(map, i) (map)-&gt;i-&gt;d_un.d_ptr</div><div class="line">#endi</div><div class="line"></div><div class="line">/* Result of the lookup functions and how to retrieve the base address.  */</div><div class="line">typedef struct link_map *lookup_t;</div><div class="line">#define LOOKUP_VALUE(map) map</div><div class="line">#define LOOKUP_VALUE_ADDRESS(map) ((map) ? (map)-&gt;l_addr : 0</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div></pre></td><td class="code"><pre><div class="line">#if (!ELF_MACHINE_NO_RELA &amp;&amp; !defined ELF_MACHINE_PLT_REL) \</div><div class="line">    || ELF_MACHINE_NO_REL</div><div class="line"># define PLTREL  ElfW(Rela)</div><div class="line">#else</div><div class="line"># define PLTREL  ElfW(Rel)</div><div class="line">#endif</div><div class="line"></div><div class="line">/* The fixup functions might have need special attributes.  If none</div><div class="line">   are provided define the macro as empty.  */</div><div class="line">#ifndef ARCH_FIXUP_ATTRIBUTE</div><div class="line"># define ARCH_FIXUP_ATTRIBUTE</div><div class="line">#endif</div><div class="line"></div><div class="line">#ifndef reloc_offset</div><div class="line"># define reloc_offset reloc_arg</div><div class="line"># define reloc_index  reloc_arg / sizeof (PLTREL)</div><div class="line">#endif</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">/* This function is called through a special trampoline from the PLT the</div><div class="line">   first time each PLT entry is called.  We must perform the relocation</div><div class="line">   specified in the PLT of the given shared object, and return the resolved</div><div class="line">   function address to the trampoline, which will restart the original call</div><div class="line">   to that address.  Future calls will bounce directly from the PLT to the</div><div class="line">   function.  */</div><div class="line"></div><div class="line">DL_FIXUP_VALUE_TYPE</div><div class="line">attribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE</div><div class="line">_dl_fixup (</div><div class="line"># ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS</div><div class="line">       ELF_MACHINE_RUNTIME_FIXUP_ARGS,</div><div class="line"># endif</div><div class="line">       struct link_map *l, ElfW(Word) reloc_arg) // 两个参数, link_map 地址, 需要重定位符号的偏移</div><div class="line">&#123;</div><div class="line">  // D_PTR :访问 link_map 必须通过这个宏</div><div class="line">  // 动态链接符号表</div><div class="line">  const ElfW(Sym) *const symtab</div><div class="line">    = (const void *) D_PTR (l, l_info[DT_SYMTAB]);</div><div class="line">  // 动态链接字符串表</div><div class="line">  const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);</div><div class="line"></div><div class="line">  // reloc_offset即_dl_fixup的第二个参数, 函数符号在 `.rel.plt` 中的偏移.</div><div class="line">  // 获取对应重定位表中的结构</div><div class="line">  const PLTREL *const reloc</div><div class="line">    = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</div><div class="line">  # 获取对应符号表的结构</div><div class="line">  const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</div><div class="line">  # 获取需要重定向入口, 根据 R_386_JUMP_SLOT 计算方法, 对应 `.got.plt` 中函数引用地址</div><div class="line">  void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset);</div><div class="line">  lookup_t result;</div><div class="line">  DL_FIXUP_VALUE_TYPE value;</div><div class="line"></div><div class="line">  /* Sanity check that we&apos;re really looking at a PLT relocation.  */</div><div class="line">  /* 检查重定位方式必须是ELF_MACHINE_JMP_SLOT */</div><div class="line">  assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</div><div class="line"></div><div class="line">   /* Look up the target symbol.  If the normal lookup rules are not</div><div class="line">      used don&apos;t look in the global scope.  */</div><div class="line">  if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0)</div><div class="line">    &#123;</div><div class="line">      const struct r_found_version *version = NULL;</div><div class="line"></div><div class="line">      if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)</div><div class="line">    &#123;</div><div class="line">      const ElfW(Half) *vernum =</div><div class="line">        (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</div><div class="line">      ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;</div><div class="line">      version = &amp;l-&gt;l_versions[ndx];</div><div class="line">      if (version-&gt;hash == 0)</div><div class="line">        version = NULL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">      /* We need to keep the scope around so do some locking.  This is</div><div class="line">     not necessary for objects which cannot be unloaded or when</div><div class="line">     we are not using any threads (yet).  */</div><div class="line">      int flags = DL_LOOKUP_ADD_DEPENDENCY;</div><div class="line">      if (!RTLD_SINGLE_THREAD_P)</div><div class="line">    &#123;</div><div class="line">      THREAD_GSCOPE_SET_FLAG ();</div><div class="line">      flags |= DL_LOOKUP_GSCOPE_LOCK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">#ifdef RTLD_ENABLE_FOREIGN_CALL</div><div class="line">      RTLD_ENABLE_FOREIGN_CALL;</div><div class="line">#endif</div><div class="line">      // 查找定义该符号的模块的装载地址, result的类型为link_map, 注意这里调用后, sym 变为 libc.so.6 中的printf的符号Sym结构,sym-&gt;st_value 为printf符号在libc.so.6中段偏移</div><div class="line">      result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</div><div class="line">                    version, ELF_RTYPE_CLASS_PLT, flags, NULL);</div><div class="line"></div><div class="line">      /* We are done with the global scope.  */</div><div class="line">      if (!RTLD_SINGLE_THREAD_P)</div><div class="line">    THREAD_GSCOPE_RESET_FLAG ();</div><div class="line"></div><div class="line">#ifdef RTLD_FINALIZE_FOREIGN_CALL</div><div class="line">      RTLD_FINALIZE_FOREIGN_CALL;</div><div class="line">#endif</div><div class="line"></div><div class="line">      /* Currently result contains the base load address (or link map)</div><div class="line">     of the object that defines sym.  Now add in the symbol</div><div class="line">     offset.  */</div><div class="line">     /* 根据模块装载地址和函数符号的段偏移获得函数的实际地址 */</div><div class="line">      value = DL_FIXUP_MAKE_VALUE (result,</div><div class="line">                   sym ? (LOOKUP_VALUE_ADDRESS (result)</div><div class="line">                      + sym-&gt;st_value) : 0);</div><div class="line">    &#125;</div><div class="line">  else</div><div class="line">    &#123;</div><div class="line">      /* We already found the symbol.  The module (and therefore its load</div><div class="line">     address) is also known.  */</div><div class="line">      value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);</div><div class="line">      result = l;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  /* And now perhaps the relocation addend.  */</div><div class="line">  value = elf_machine_plt_value (l, reloc, value);</div><div class="line"></div><div class="line">  if (sym != NULL</div><div class="line">      &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, 0))</div><div class="line">    value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));</div><div class="line"></div><div class="line">  /* Finally, fix up the plt itself.  */</div><div class="line">  if (__builtin_expect (GLRO(dl_bind_not), 0))</div><div class="line">    return value;</div><div class="line"></div><div class="line">  # 修正.got.plt函数引用地址(rel_addr)的值为printf的地址</div><div class="line">  return elf_machine_fixup_plt (l, result, reloc, rel_addr, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ p reloc-&gt;r_info //重定位符号在符号表中的索引</div><div class="line">$1 = 0x107</div><div class="line">gdb-peda$ p reloc-&gt;r_offset //重定位的入口偏移</div><div class="line">$2 = 0x804a00c</div><div class="line">gdb-peda$ p sym //未执行_dl_lookup_symbol_x</div><div class="line">$3 = (const Elf32_Sym *) 0x80481dc</div><div class="line"></div><div class="line">gdb-peda$ p sym //执行_dl_lookup_symbol_x后</div><div class="line">$2 = (const Elf32_Sym *) 0xb7e2a6d4</div><div class="line">gdb-peda$ p sym-&gt;st_value //执行_dl_lookup_symbol_x后, sym指向发生改变, printf符号的在libc.so.6段偏移</div><div class="line">$9 = 0x4d410</div><div class="line">gdb-peda$ p result-&gt;l_addr //模块装载地址</div><div class="line">$10 = 0xb7e24000</div><div class="line">gdb-peda$ disassemble 0x4d410+0xb7e24000</div><div class="line">Dump of assembler code for function __printf:</div><div class="line">   0xb7e71410 &lt;+0&gt;: push   ebx</div><div class="line">   0xb7e71411 &lt;+1&gt;: sub    esp,0x18</div><div class="line">   0xb7e71414 &lt;+4&gt;: call   0xb7f4a7db &lt;__x86.get_pc_thunk.bx&gt;</div><div class="line">   0xb7e71419 &lt;+9&gt;: add    ebx,0x15dbe7</div><div class="line">   0xb7e7141f &lt;+15&gt;:    lea    eax,[esp+0x24]</div><div class="line">   0xb7e71423 &lt;+19&gt;:    mov    DWORD PTR [esp+0x8],eax</div><div class="line">   0xb7e71427 &lt;+23&gt;:    mov    eax,DWORD PTR [esp+0x20]</div><div class="line">   0xb7e7142b &lt;+27&gt;:    mov    DWORD PTR [esp+0x4],eax</div><div class="line">   0xb7e7142f &lt;+31&gt;:    mov    eax,DWORD PTR [ebx-0x70]</div><div class="line">   0xb7e71435 &lt;+37&gt;:    mov    eax,DWORD PTR [eax]</div><div class="line">   0xb7e71437 &lt;+39&gt;:    mov    DWORD PTR [esp],eax</div><div class="line">   0xb7e7143a &lt;+42&gt;:    call   0xb7e67810 &lt;_IO_vfprintf_internal&gt;</div><div class="line">   0xb7e7143f &lt;+47&gt;:    add    esp,0x18</div><div class="line">   0xb7e71442 &lt;+50&gt;:    pop    ebx</div><div class="line">   0xb7e71443 &lt;+51&gt;:    ret</div><div class="line">End of assembler dump.</div></pre></td></tr></table></figure>
<h4 id="利用场景"><a href="#利用场景" class="headerlink" title="利用场景"></a>利用场景</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TODO</div></pre></td></tr></table></figure>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;程序员自我修养&gt;</div><div class="line"></div><div class="line">http://www.longene.org/techdoc/0750005001224576724.html</div><div class="line">http://blog.chinaunix.net/uid-21471835-id-441227.html(很全)</div><div class="line"></div><div class="line">https://www.ibm.com/developerworks/cn/linux/l-elf/part1/</div></pre></td></tr></table></figure>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-01-07</span><i class="fa fa-tag"></i><a href="/categories/pwn/" title="pwn" class="tag">pwn </a><a href="/tags/pwn/" title="pwn" class="tag">pwn </a><a href="/tags/elf/" title="elf" class="tag">elf </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://jmpews.github.com/2017/01/07/pwn/PWN之ELF符号动态解析过程/,jmpews,ELF符号动态解析过程,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2017/01/06/pwn/PWN之堆内存管理/" title="ptmalloc堆内存管理" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2017/01/16/pwn/PWN之栈触发/" title="PWN漏洞之栈触发" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>