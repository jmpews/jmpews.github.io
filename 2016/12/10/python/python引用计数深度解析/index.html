<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="jmpews,jmpews@gmail.com"><title>python引用计数深度解析 · jmpews</title><meta name="description" content="前言引用计数记录指向对象引用的个数，当变为0，则被释放。总结了引用计数的注意点和如何使用。更新：weakref(弱引用)、用弱引用解决引用环问题

It counts how many different places there are that have a reference to an ob"><meta name="keywords" content="py,go,pwn,reverse"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">jmpews</a></h3><div class="description"><p>py &amp; go &amp; pwn &amp; reverse</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/jmpews"><i class="fa fa-twitter"></i></a></li><li><a href="http://weibo.com/winter1ife"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/jmpews"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>python引用计数深度解析</a></h3></div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>引用计数记录指向对象引用的个数，当变为0，则被释放。总结了引用计数的注意点和如何使用。更新：weakref(弱引用)、用弱引用解决引用环问题</p>
<blockquote>
<p>It counts how many different places there are that have a reference to an object.When an object’s reference count becomes zero, the object is deallocated</p>
<p>记录指向对象引用的个数，当变为0，则被释放</p>
</blockquote>
<h4 id="使用引用计数的实质"><a href="#使用引用计数的实质" class="headerlink" title="使用引用计数的实质"></a>使用引用计数的实质</h4><blockquote>
<p>The only real reason to use the reference count is to prevent the object from being deallocated as long as our variable is pointing to it</p>
<p>使用引用计数的唯一理由就是只要还有变量指向就应当阻止对象被释放</p>
</blockquote>
<h2 id="引用计数的实现"><a href="#引用计数的实现" class="headerlink" title="引用计数的实现"></a>引用计数的实现</h2><ul>
<li><code>PyObject*</code> 是什么?</li>
<li>引用计数变量 <code>ob_refcnt</code></li>
<li>如何操作 <code>ob_refcnt (Py_INCREF and Py_DECREF)</code></li>
</ul>
<h2 id="PyObject-是什么"><a href="#PyObject-是什么" class="headerlink" title="PyObject* 是什么?"></a><code>PyObject*</code> 是什么?</h2><blockquote>
<p>This type is a pointer to an opaque data type representing an <strong>arbitrary Python object</strong>. Since all Python object types are treated <strong>the same way</strong> by the Python language in most situations (e.g., assignments, scope rules, and argument passing), it is only fitting that they should be represented by a single C type. Almost all <strong>Python objects live on the heap</strong>: you never declare an automatic or static variable of type PyObject, only pointer variables of type <strong>PyObject* </strong>can be declared.</p>
<p>这种数据类型是可以表示任意Python对象的封装数据类型，因此Python对象类型在大多数情况下以相同方式处理。几乎全部的Python的对象存储在<strong>heap堆(由程序员分配malloc)</strong>，因此不可以声明一个PyObject的类型对象(局部变量值保存在stack)，只能是<strong>PyObject* </strong></p>
</blockquote>
<h4 id="引用计数变量-ob-refcnt"><a href="#引用计数变量-ob-refcnt" class="headerlink" title="引用计数变量 ob_refcnt"></a>引用计数变量 <code>ob_refcnt</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef struct _object &#123;</div><div class="line">    _PyObject_HEAD_EXTRA</div><div class="line">    Py_ssize_t ob_refcnt;</div><div class="line">    struct _typeobject *ob_type;</div><div class="line">&#125; PyObject;</div></pre></td></tr></table></figure>
<h4 id="如何操作-ob-refcnt-Py-INCREF-and-Py-DECREF"><a href="#如何操作-ob-refcnt-Py-INCREF-and-Py-DECREF" class="headerlink" title="如何操作 ob_refcnt (Py_INCREF and Py_DECREF)"></a>如何操作 <code>ob_refcnt (Py_INCREF and Py_DECREF)</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#define Py_INCREF(op) (                         \</div><div class="line">    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA       \</div><div class="line">    ((PyObject *)(op))-&gt;ob_refcnt++)</div><div class="line"></div><div class="line">#define Py_DECREF(op)                                   \</div><div class="line">    do &#123;                                                \</div><div class="line">        PyObject *_py_decref_tmp = (PyObject *)(op);    \</div><div class="line">        if (_Py_DEC_REFTOTAL  _Py_REF_DEBUG_COMMA       \</div><div class="line">        --(_py_decref_tmp)-&gt;ob_refcnt != 0)             \</div><div class="line">            _Py_CHECK_REFCNT(_py_decref_tmp)            \</div><div class="line">        else                                            \</div><div class="line">        _Py_Dealloc(_py_decref_tmp);                    \</div><div class="line">    &#125; while (0)</div></pre></td></tr></table></figure>
<h2 id="什么时候操作引用计数"><a href="#什么时候操作引用计数" class="headerlink" title="什么时候操作引用计数"></a>什么时候操作引用计数</h2><p><strong>仅有当你需要保护这个变量不被释放时才使用INCREF</strong></p>
<p>具体：</p>
<ul>
<li>创建一个Object* 对象</li>
<li>处理函数返回的对象</li>
<li>借用引用(borrow)</li>
<li>偷取引用(Steal)</li>
</ul>
<p>注: 不需要对每个<strong>本地变量(stack变量)</strong>的引用+1，因为当一个变量创建并且有一个指针指向时，默认INC，然而当变量失去作用范围(stack栈)又会DEC，两者抵消。</p>
<h4 id="创建一个Object-对象"><a href="#创建一个Object-对象" class="headerlink" title="创建一个Object* 对象"></a>创建一个Object* 对象</h4><h4 id="针对long类型变量分析"><a href="#针对long类型变量分析" class="headerlink" title="针对long类型变量分析"></a>针对long类型变量分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PyObject *l, *x;</div><div class="line">x = PyLong_FromLong(1L);</div></pre></td></tr></table></figure>
<p>具体请参考 <code>PyLong_FromLong() [longobject.c]</code></p>
<p>调用 <code>_PyLong_New()</code> 创建新long对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">PyObject *</div><div class="line">PyLong_FromLong(long ival)</div><div class="line">&#123;</div><div class="line">    PyLongObject *v;</div><div class="line">    ...</div><div class="line">    //something done</div><div class="line">        v = _PyLong_New(1);</div><div class="line">    ...</div><div class="line">    //something done</div><div class="line">    return (PyObject *)v;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>_PyLong_New() [longobject.c]</code> 的过程分析</p>
<p>调用 <code>PyObject_MALLOC()</code> 分配内存，调用 <code>PyObject_INIT_VAR()</code> 初始化为 <code>PyLongOject*</code> 类型，完成 <code>PyObject*</code> 相关项的初始化，比如类型项等等。</p>
<p><strong>注：</strong>关于 <code>PyObject_MALLOC()[obmalloc.c]</code>，采用内存池进行内存管理，此处不详细介绍</p>
<p><a href="http://blog.csdn.net/dbzhang800/article/details/6685269" target="_blank" rel="external">Python内存管理</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">PyLongObject *</div><div class="line">_PyLong_New(Py_ssize_t size)</div><div class="line">&#123;</div><div class="line">    PyLongObject *result;</div><div class="line">    if (size &gt; (Py_ssize_t)MAX_LONG_DIGITS) &#123;</div><div class="line">        PyErr_SetString(PyExc_OverflowError,</div><div class="line">                        &quot;too many digits in integer&quot;);</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">    result = PyObject_MALLOC(offsetof(PyLongObject, ob_digit) +</div><div class="line">                             size*sizeof(digit));</div><div class="line">    if (!result) &#123;</div><div class="line">        PyErr_NoMemory();</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">    return (PyLongObject*)PyObject_INIT_VAR(result, &amp;PyLong_Type, size);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>PyObject_INIT_VAR() [objimp.h]</code> 分析过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define PyObject_INIT(op, typeobj) \</div><div class="line">    ( Py_TYPE(op) = (typeobj), _Py_NewReference((PyObject *)(op)), (op) )</div><div class="line">#define PyObject_INIT_VAR(op, typeobj, size) \</div><div class="line">    ( Py_SIZE(op) = (size), PyObject_INIT((op), (typeobj)) )</div></pre></td></tr></table></figure>
<p>宏展开(Macro Expansion) <code>Py_TYPE() _Py_NewReference() [object.h]</code></p>
<p>最终发现调用创建 <code>PyObject*</code> 变量时, 初始化 <code>op_refcnt</code> 为 1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#define Py_TYPE(ob)             (((PyObject*)(ob))-&gt;ob_type)</div><div class="line">#define Py_REFCNT(ob)           (((PyObject*)(ob))-&gt;ob_refcnt)</div><div class="line">#define _Py_NewReference(op) (                          \</div><div class="line">    _Py_INC_TPALLOCS(op) _Py_COUNT_ALLOCS_COMMA         \</div><div class="line">    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA               \</div><div class="line">    Py_REFCNT(op) = 1)</div></pre></td></tr></table></figure>
<h4 id="处理函数返回的对象"><a href="#处理函数返回的对象" class="headerlink" title="处理函数返回的对象"></a>处理函数返回的对象</h4><p>很多函数在返回之前会调用 <code>Py_INCREF()</code>，因此该函数的 caller 需要调用 <code>Py_DECREF()</code>,以防内存泄露(memory leak)</p>
<p><code>MyCode</code> 必须处理 <code>pyo</code>，调用 <code>Py_DECREF</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void MyCode(arguments)</div><div class="line">&#123;</div><div class="line">    PyObject* pyo;</div><div class="line">    ...</div><div class="line">    pyo = Py_Something(args);</div><div class="line">    //Py_DECREF(pyo);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果 <code>MyCode</code> 传递 <code>pyo</code> 的所有权，则不能调用 <code>Py_DECREF</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">PyObject* MyCode(arguments) &#123;</div><div class="line">    PyObject* pyo;</div><div class="line">    ...</div><div class="line">    pyo = Py_Something(args);</div><div class="line">    ...</div><div class="line">    return pyo;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注: 函数返回 None 则返回之前需要 <code>Py_INCREF(Py_None)</code></p>
<p><a href="http://stackoverflow.com/questions/15287590/why-should-py-increfpy-none-be-required-before-returning-py-none-in-c" target="_blank" rel="external">Py_INCREF(Py_None) from stackoverflow</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Py_INCREF(Py_None);</div><div class="line">return Py_None;</div></pre></td></tr></table></figure>
<h4 id="借用引用-borrow"><a href="#借用引用-borrow" class="headerlink" title="借用引用(borrow)"></a>借用引用(borrow)</h4><p><strong>仅获得拷贝，引用计数不增加</strong></p>
<p>产生借用:</p>
<ul>
<li>返回借用引用对象的函数[borrow]</li>
<li>传递给函数的对象[borrow]</li>
</ul>
<p>返回借用引用对象的函数[borrow]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">PyTuple_GetItem()</div><div class="line">PyList_GetItem()</div><div class="line">PyList_GET_ITEM()</div><div class="line">PyList_SET_ITEM()</div><div class="line">PyDict_GetItem()</div><div class="line">PyDict_GetItemString()</div><div class="line">PyErr_Occurred()</div><div class="line">PyFile_Name()</div><div class="line">PyImport_GetModuleDict()</div><div class="line">PyModule_GetDict()</div><div class="line">PyImport_AddModule()</div><div class="line">PyObject_Init()</div><div class="line">Py_InitModule()</div><div class="line">Py_InitModule3()</div><div class="line">Py_InitModule4()</div><div class="line">PySequence_Fast_GET_ITEM()</div></pre></td></tr></table></figure>
<p><code>PyList_GetItem</code> 仅获得对应项目拷贝，不增加引用计数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">long sum_list(PyObject *list)</div><div class="line">&#123;</div><div class="line"> int i, n;</div><div class="line"> long total = 0;</div><div class="line"> PyObject *item;</div><div class="line"></div><div class="line"> n = PyList_Size(list);</div><div class="line"> if (n &lt; 0)</div><div class="line">     return -1; /* Not a list */</div><div class="line">     /* Caller should use PyErr_Occurred() if a -1 is returned. */</div><div class="line"> for (i = 0; i &lt; n; i++) &#123;</div><div class="line">     /* PyList_GetItem does not INCREF &quot;item&quot;.</div><div class="line">        &quot;item&quot; is unprotected and borrowed. IMPORTANT!!! */</div><div class="line">     item = PyList_GetItem(list, i); /* Can&apos;t fail */</div><div class="line">     if (PyInt_Check(item))</div><div class="line">         total += PyInt_AsLong(item);</div><div class="line"> &#125;</div><div class="line"> return total;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>PySequence_GetItem</code> 获得对象所有权，其返回对象+1，因而每次循环后需要-1.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">long sum_sequence(PyObject *sequence)</div><div class="line">&#123;</div><div class="line"> int i, n;</div><div class="line"> long total = 0;</div><div class="line"> PyObject *item;</div><div class="line"> n = PySequence_Length(sequence);</div><div class="line"> if (n &lt; 0)</div><div class="line">     return -1; /* Has no length. */</div><div class="line">     /* Caller should use PyErr_Occurred() if a -1 is returned. */</div><div class="line"> for (i = 0; i &lt; n; i++) &#123;</div><div class="line">     /* PySequence_GetItem INCREFs item.  IMPORTANT!!!*/</div><div class="line">     item = PySequence_GetItem(sequence, i);</div><div class="line">     if (item == NULL)</div><div class="line">         return -1; /* Not a sequence, or other failure */</div><div class="line">     if (PyInt_Check(item))</div><div class="line">         total += PyInt_AsLong(item);</div><div class="line">     Py_DECREF(item);</div><div class="line"> &#125;</div><div class="line"> return total;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="传递给函数的对象-borrow"><a href="#传递给函数的对象-borrow" class="headerlink" title="传递给函数的对象[borrow]"></a>传递给函数的对象[borrow]</h4><blockquote>
<p>Most functions assume that the arguments passed to them are already protected.Therefore Py_INCREF() is not called inside Function unless Function wants the argument to continue to exist after Caller exits. In the documentation, Function is said to borrow a reference:<br><strong>大多数函数假定传入函数的参数都是受保护的不需要INCREF，除非希望参数在函数exit后仍然存在。官方文档说法是函数借用引用</strong></p>
<p>When you pass an object reference into another function, in general, the function borrows the reference from you   if it needs to store it, it will use Py_INCREF() to become an independent owner.<br><strong>你传递对象给一个函数，一般情况来说是函数借用引用，如果你希望保存那么请INCREF，将其变为独立拥有者。</strong></p>
</blockquote>
<p><code>PyTuple_SetItem()</code> 和 <code>PyList_SetItem()</code> 除外，它们接管传入对象所有权(take over responsibility) or 偷取引用(steal a reference)</p>
<p>详细见下</p>
<h2 id="偷取引用-Steal"><a href="#偷取引用-Steal" class="headerlink" title="偷取引用(Steal)"></a>偷取引用(Steal)</h2><p><code>PyTuple_SetItem(tuple,i,item)</code> 和 <code>PyList_SetItem()</code> 接管所有权(take over responsibility) or 偷取引用(steal a reference) item引用，but not to the tuple or list into which the item is put，即仅仅偷取item引用.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">PyDict_SetItem()非借用，既然是store变量到dict，因此PyDict_SetItem() INCREF它的kye和value</div><div class="line"></div><div class="line">但是PyTuple_SetItem()和PyList_SetItem()比较特殊，接管所有权(take over responsibility) or 偷取引用(steal a reference)</div><div class="line"></div><div class="line">PyTuple_SetItem(tuple,i,item)实现：如果tuple[i]存在PyObject则DECREF，然后tuple[i]设置为item。并且Item并没有INCREF</div><div class="line"></div><div class="line">PyTuple_SetItem(tuple,i,item)既然是steal，那么**Item之前必须有所有权**</div><div class="line"></div><div class="line">如果PyTuple_SetItem()插入item失败，则DECREF item引用计数</div><div class="line"></div><div class="line">PyTuple_SetItem()是设置Tuple中item的唯一方法</div></pre></td></tr></table></figure>
<p>不需要调用 <code>DECREF(x)</code>，<code>PyTuple_SetItem()</code> 已经自动调用了,当 Tuple 被 DECREF 时，它的 item 也会被 DECREF</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PyObjetc *t;</div><div class="line">PyObject *x;</div><div class="line">x=PyIntFromLong(1L);</div><div class="line">PyTuple_SetItem(t,0,x);</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>许多从<strong>其他对象上提取子对象</strong>的函数，通过引用传递所有权，但有一些例外，<code>PyTuple_GetItem()</code>, <code>PyList_GetItem()</code>, <code>PyDict_GetItem()</code>，和 <code>PyDict_GetItemString()</code>，这些返回的引用是从 tuple，list 或 dict 中借用的.(借用仅获得拷贝，引用计数并不增加)</p>
<p>当你传递一个对象引用给其他函数，这个函数会从借用这个引用，如果需要保存它应该使用Py_INCREF()转换为独立拥有者。但是有例外，<code>PyTuple_SetItem()</code> 和 <code>PyList_SetItem()</code>，直接传递对象所有权</p>
<p>Python调用一个C函数的返回对象必须拥有引用所有权传递给它的调用者</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h4 id="INCREF不可马虎"><a href="#INCREF不可马虎" class="headerlink" title="INCREF不可马虎"></a>INCREF不可马虎</h4><p>常见的情况是从 list 中提取对象，一些操作符可以能会替换或者移除 list 中某个对象，并且假如这个向对象是用户自定义的 calss，包含 <code>__del__</code>，然而这个 <code>__del__</code> 可以执行任意的code，但是这些操作可能会无意的 DEC 该 list[0] 的引用计数，导致free。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">bug(PyObject *list) &#123;</div><div class="line">/*item利用PyList_GetItem借用list引用*/</div><div class="line"> PyObject *item = PyList_GetItem(list, 0);</div><div class="line"> //修改措施Py_INCREF(item); /* Protect item. */</div><div class="line"> /* This function “steals” a reference to item and discards a reference to an item already in the list at the affected position.</div><div class="line"> 可能引起list中原list[1]中__del__，导致DEClist[0]*/</div><div class="line"> PyList_SetItem(list, 1, PyInt_FromLong(0L));</div><div class="line"> PyObject_Print(item, stdout, 0); /* BUG! */</div><div class="line"> //修改措施:Py_DECREF(item);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="偷取和借用对比在-build-list-or-tuple-方面"><a href="#偷取和借用对比在-build-list-or-tuple-方面" class="headerlink" title="偷取和借用对比在 build list or tuple 方面"></a>偷取和借用对比在 <code>build list or tuple</code> 方面</h4><p>Example1: steal a referfence(take over responsibilty)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">PyObjetc *t;</div><div class="line">PyObject *x;</div><div class="line">x=PyIntFromLong(1L);</div><div class="line">PyTuple_SetItem(t,0,x);</div><div class="line">//Dont&apos;t Need Py_DECREF()</div></pre></td></tr></table></figure>
<p>Example2: borrow a reference</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/*Better way*/</div><div class="line"></div><div class="line">PyObject *l, *x;</div><div class="line">l = PyList_New(3);</div><div class="line">x = PyInt_FromLong(1L);</div><div class="line">PySequence_SetItem(l, 0, x); Py_DECREF(x);</div><div class="line">x = PyInt_FromLong(2L);</div><div class="line">PySequence_SetItem(l, 1, x); Py_DECREF(x);</div><div class="line">x = PyString_FromString(&quot;three&quot;);</div><div class="line">PySequence_SetItem(l, 2, x); Py_DECREF(x);</div></pre></td></tr></table></figure>
<p>注: 更常见的创建list和tuple的方法</p>
<p>More Common Way to Populate a tuple or list</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PyObject *t, *l;</div><div class="line">t = Py_BuildValue(&quot;(iis)&quot;, 1, 2, &quot;three&quot;);</div><div class="line">l = Py_BuildValue(&quot;[iis]&quot;, 1, 2, &quot;three&quot;);</div></pre></td></tr></table></figure>
<p>参考链接:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[Reference Counting in Python](http://edcjones.tripod.com/refcount.html)</div><div class="line"></div><div class="line">[Extending Python with C or C++](http://www.incoding.org/admin/archives/808.html)</div></pre></td></tr></table></figure>
<h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h4><p>This is a pretty standard example of C code using the Python API.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">PyObject*</div><div class="line">    MyFunction(void)</div><div class="line">    &#123;</div><div class="line">        PyObject* temporary_list=NULL;</div><div class="line">        PyObject* return_this=NULL;</div><div class="line"></div><div class="line">        temporary_list = PyList_New(1);          /* Note 1 */</div><div class="line">        if (temporary_list == NULL)</div><div class="line">            return NULL;</div><div class="line"></div><div class="line">        return_this = PyList_New(1);             /* Note 1 */</div><div class="line">        if (return_this == NULL)</div><div class="line">            Py_DECREF(temporary_list);           /* Note 2 */</div><div class="line">            return NULL;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Py_DECREF(temporary_list);               /* Note 2 */</div><div class="line">        return return_this;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Note 1: The object returned by PyList_New has a reference count of 1.</div><div class="line">Note 2: Since temporary_list should disappear when MyFunction exits, it must be DECREFed before any return from the function. If a return can be reached both before or after temporary_list is created, then initialize temporary_list to NULL and use Py_XDECREF().</div></pre></td></tr></table></figure>
<h4 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">This is the same as Example 1 except PyTuple_GetItem() is used.</div><div class="line">    PyObject*</div><div class="line">    MyFunction(void)</div><div class="line">    &#123;</div><div class="line">        PyObject* temporary=NULL;</div><div class="line">        PyObject* return_this=NULL;</div><div class="line">        PyObject* tup;</div><div class="line">        PyObject* num;</div><div class="line">        int err;</div><div class="line">        tup = PyTuple_New(2);</div><div class="line">        if (tup == NULL)</div><div class="line">            return NULL;</div><div class="line">        err = PyTuple_SetItem(tup, 0, PyInt_FromLong(222L));</div><div class="line">        /* Note 1 */</div><div class="line">        if (err) &#123;</div><div class="line">            Py_DECREF(tup);</div><div class="line">            return NULL;</div><div class="line">        &#125;</div><div class="line">        err = PyTuple_SetItem(tup, 1, PyInt_FromLong(333L));</div><div class="line">        /* Note 1 */</div><div class="line">        if (err) &#123;</div><div class="line">            Py_DECREF(tup);</div><div class="line">            return NULL;</div><div class="line">        &#125;</div><div class="line">        temporary = PyTuple_Getitem(tup, 0);</div><div class="line">        /* Note 2 */</div><div class="line">        if (temporary == NULL) &#123;</div><div class="line">            Py_DECREF(tup);</div><div class="line">            return NULL;</div><div class="line">        &#125;</div><div class="line">        return_this = PyTuple_Getitem(tup, 1);</div><div class="line">        /* Note 3 */</div><div class="line">        if (return_this == NULL) &#123;</div><div class="line">            Py_DECREF(tup);</div><div class="line">            /* Note 3 */</div><div class="line">            return NULL;</div><div class="line">        &#125;</div><div class="line">        /* Note 3 */</div><div class="line">        Py_DECREF(tup);</div><div class="line">        return return_this;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Note 1: If PyTuple_SetItem fails or if the tuple it created is DECREFed to 0, then the object returned by **PyInt_FromLong is DECREFed**.</div><div class="line"></div><div class="line">Note 2: PyTuple_Getitem does not increment the reference count for the object it returns.</div><div class="line"></div><div class="line">Note 3: You have no responsibility for DECFREFing temporary.</div></pre></td></tr></table></figure>
<h2 id="更新内容"><a href="#更新内容" class="headerlink" title="更新内容"></a>更新内容</h2><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><blockquote>
<p>弱引用与强引用相对，指不能确保其引用对象不会被垃圾回收器回收，一个对象若只被弱引用所引用，则被认为是不可访问的。 –wiki</p>
</blockquote>
<h4 id="弱引用解决引用环问题"><a href="#弱引用解决引用环问题" class="headerlink" title="弱引用解决引用环问题"></a>弱引用解决引用环问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># python2.x会出现，python3.x做了改进</div><div class="line">class LeakTest(object):</div><div class="line">   def __init__(self):</div><div class="line">     print &apos;Object with id %d born here.&apos; % id(self)</div><div class="line">   def __del__(self):</div><div class="line">     print &apos;Object with id %d dead here.&apos; % id(self)</div><div class="line"></div><div class="line">def foo():</div><div class="line">   A = LeakTest()</div><div class="line">   B = LeakTest()</div><div class="line">   A.b = B</div><div class="line">   B.a = A</div><div class="line">if __name__ = =&quot;__main__&quot;:</div><div class="line">  foo()</div><div class="line"></div><div class="line">RESULT:</div><div class="line">Object with id 10462448 born here.</div><div class="line">Object with id 10462832 born here.</div></pre></td></tr></table></figure>
<p>相互引用导致形成环，当对象只有被弱引用时，同样会被回收,因此可做如下修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import weakref</div><div class="line">class LeakTest(object):</div><div class="line">   def __init__(self):</div><div class="line">     print &apos;Object with id %d born here.&apos; % id(self)</div><div class="line">   def __del__(self):</div><div class="line">     print &apos;Object with id %d dead here.&apos; % id(self)</div><div class="line"></div><div class="line">def foo():</div><div class="line">   A = LeakTest()</div><div class="line">   B = LeakTest()</div><div class="line">   A.b = weakref.proxy(B)</div><div class="line">   B.a = weakref.proxy(A)</div><div class="line">if __name__ = =&quot;__main__&quot;:</div><div class="line">  foo()</div></pre></td></tr></table></figure>
<h4 id="弱引用对象使用"><a href="#弱引用对象使用" class="headerlink" title="弱引用对象使用"></a>弱引用对象使用</h4><p>弱引用和代理对象都可以设置callback，在没有强引用时，python要进行销毁时调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from socket import *</div><div class="line">&gt;&gt;&gt; import weakref</div><div class="line">&gt;&gt;&gt; s=socket(AF_INET,SOCK_STREAM)</div><div class="line">&gt;&gt;&gt; ref=weakref.ref(s) # 通过调用弱引用来获取被弱引用的对象</div><div class="line">&gt;&gt;&gt; pref=weakref.proxy(s) #代理对象就是弱引用对象</div><div class="line">&gt;&gt;&gt; s</div><div class="line">&lt;socket.socket fd=8, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=(&apos;0.0.0.0&apos;, 0)&gt;</div><div class="line">&gt;&gt;&gt; ref</div><div class="line">&lt;weakref at 0x103275598; to &apos;socket&apos; at 0x10325aee8&gt;</div><div class="line">&gt;&gt;&gt; ref()</div><div class="line">&lt;socket.socket fd=8, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=(&apos;0.0.0.0&apos;, 0)&gt;</div><div class="line">&gt;&gt;&gt; pref</div><div class="line">&lt;weakproxy at 0x103275548 to socket at 0x10325aee8&gt;</div></pre></td></tr></table></figure>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2016-12-10</span><i class="fa fa-tag"></i><a href="/categories/python/" title="python" class="tag">python </a><a href="/tags/python/" title="python" class="tag">python </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://jmpews.github.com/2016/12/10/python/python引用计数深度解析/,jmpews,python引用计数深度解析,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2016/12/10/python/python技巧与笔记/" title="python技巧与笔记" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2016/12/10/python/tornado中ioloop-yield-Future与thread的配合/" title="tornado中ioloop-yield-Future与thread的配合" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>