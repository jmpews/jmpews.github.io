<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="jmpews,jmpews@gmail.com"><title>Redis备忘笔记 · jmpews</title><meta name="description" content="Pipelines
Pipelines are a subclass of the base Redis class that provide support for buffering multiple commands to the server in a single request.

12"><meta name="keywords" content="py,go,pwn,reverse"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">jmpews</a></h3><div class="description"><p>py &amp; go &amp; pwn &amp; reverse</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/jmpews"><i class="fa fa-twitter"></i></a></li><li><a href="http://weibo.com/winter1ife"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/jmpews"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Redis备忘笔记</a></h3></div><div class="post-content"><h2 id="Pipelines"><a href="#Pipelines" class="headerlink" title="Pipelines"></a>Pipelines</h2><blockquote>
<p>Pipelines are a subclass of the base Redis class that provide support for buffering multiple commands to the server in a single request.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">pipe=r.pipeline()</div><div class="line">pipe.set(&apos;a&apos;,1)</div><div class="line">pipe.set(&apos;b&apos;,2)</div><div class="line">pipe.get(&apos;a&apos;)</div><div class="line">pipe.get(&apos;b&apos;)</div><div class="line">pipe.execute()</div><div class="line">#[True, True, b&apos;1&apos;, b&apos;2&apos;]</div></pre></td></tr></table></figure>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><strong>Important:事务中每个命令的执行结果都是最后一起返回的，无法讲前一条命令的结果作为下一条命令的参数。</strong></p>
<p>事务实现<code>incr()</code>，不能在事务中实现+1的操作。<code>watch</code>监视一个变量直到<code>execute()</code>,如果在此期间变量值被修改则异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">with r.pipeline() as pipe:</div><div class="line">    while 1:</div><div class="line">        try:</div><div class="line">            # put a WATCH on the key that holds our sequence value</div><div class="line">            pipe.watch(&apos;OUR-SEQUENCE-KEY&apos;)</div><div class="line">            # after WATCHing, the pipeline is put into immediate execution</div><div class="line">            # mode until we tell it to start buffering commands again.</div><div class="line">            # this allows us to get the current value of our sequence</div><div class="line">            current_value = pipe.get(&apos;OUR-SEQUENCE-KEY&apos;)</div><div class="line">            next_value = int(current_value) + 1</div><div class="line">            # now we can put the pipeline back into buffered mode with MULTI</div><div class="line">            pipe.multi()</div><div class="line">            pipe.set(&apos;OUR-SEQUENCE-KEY&apos;, next_value)</div><div class="line">            # and finally, execute the pipeline (the set command)</div><div class="line">            pipe.execute()</div><div class="line">            # if a WatchError wasn&apos;t raised during execution, everything</div><div class="line">            # we just did happened atomically.</div><div class="line">            break</div><div class="line">       except WatchError:</div><div class="line">            # another client must have changed &apos;OUR-SEQUENCE-KEY&apos; between</div><div class="line">            # the time we started WATCHing it and the pipeline&apos;s execution.</div><div class="line">            # our best bet is to just retry.</div><div class="line">            continue</div></pre></td></tr></table></figure>
<p>transaction,更简便的实现方式</p>
<blockquote>
<p>A convenience method named “transaction” exists for handling all the boilerplate of handling and retrying watch errors. It takes a callable that should expect a single parameter, a pipeline object, and any number of keys to be WATCHed. Our client-side INCR command above can be written like this, which is much easier to read:</p>
</blockquote>
<p><code>transaction(func,&#39;key&#39;)</code>，该函数参数为可调函数<code>func(pipe)</code>(自动传入一个pipe参数)和需要监视的key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def client_side_incr(pipe):</div><div class="line">    current_value = pipe.get(&apos;OUR-SEQUENCE-KEY&apos;)</div><div class="line">    next_value = int(current_value) + 1</div><div class="line">    pipe.multi()</div><div class="line">    pipe.set(&apos;OUR-SEQUENCE-KEY&apos;, next_value)</div><div class="line"></div><div class="line">r.transaction(client_side_incr, &apos;OUR-SEQUENCE-KEY&apos;)</div><div class="line">#[True]</div></pre></td></tr></table></figure>
<h2 id="3-发布订阅"><a href="#3-发布订阅" class="headerlink" title="3.发布订阅"></a>3.发布订阅</h2><p>基本code</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import redis</div><div class="line">db=redis.StrictRedis(host=&apos;linevery.com&apos;, port=6379, db=0)</div><div class="line">p = db.pubsub()</div><div class="line"># 忽略订阅消息</div><div class="line">p = r.pubsub(ignore_subscribe_messages=True)</div><div class="line"># 订阅channel</div><div class="line">p.subscribe(&apos;channel1&apos;, &apos;channel2&apos;)</div><div class="line"># 通配符订阅</div><div class="line">p.psubscribe(&apos;channel*&apos;)</div><div class="line"># 发送消息，返回有几个channel接收到message</div><div class="line">r.publish(&apos;channel1&apos;, &apos;some data&apos;)</div><div class="line"># 获取消息 &#123;&apos;channel&apos;: &apos;my-first-channel&apos;, &apos;data&apos;: &apos;some data&apos;, &apos;pattern&apos;: None, &apos;type&apos;: &apos;message&apos;&#125;</div><div class="line">p.get_message()</div><div class="line"># 退订channel</div><div class="line">p.unsubscribe()</div><div class="line">p.punsubscribe(&apos;my-*&apos;)</div></pre></td></tr></table></figure>
<p><code>get_message()</code>的回调函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def my_handler(message):</div><div class="line">	print(&apos;MY HANDLER: &apos;, message[&apos;data&apos;])</div><div class="line">p.subscribe(**&#123;&apos;my-channel&apos;: my_handler&#125;)</div><div class="line"># 直接调用回调函数，不再返回值。</div><div class="line">p.get_message()</div></pre></td></tr></table></figure>
<p><code>get_message()</code>的几种方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># 循环读取</div><div class="line">while True:</div><div class="line">    message = p.get_message()</div><div class="line">    if message:</div><div class="line">        # do something with the message</div><div class="line">    time.sleep(0.001)  # be nice to the system :)</div><div class="line"></div><div class="line"># 阻塞读取</div><div class="line">for message in p.listen():</div><div class="line">    # do something with the message</div></pre></td></tr></table></figure>
<p>线程loop,必须要存在回调函数的channel，因为thread不能自动的处理message。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 必须存在回调</div><div class="line">p.subscribe(**&#123;&apos;my-channel&apos;: my_handler&#125;)</div><div class="line">thread = p.run_in_thread(sleep_time=0.001)</div><div class="line"># the event loop is now running in the background processing messages</div><div class="line"># when it&apos;s time to shut it down...</div><div class="line">thread.stop()</div></pre></td></tr></table></figure>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2016-12-10</span><i class="fa fa-tag"></i><a href="/categories/notes/" title="notes" class="tag">notes </a><a href="/tags/redis/" title="redis" class="tag">redis </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://jmpews.github.com/2016/12/10/notes/Redis备忘笔记/,jmpews,Redis备忘笔记,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2016/12/10/notes/IPSecVPN搭建/" title="IPSec VPN搭建" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2016/12/11/notes/使用goaccess进行日志分析/" title="" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>